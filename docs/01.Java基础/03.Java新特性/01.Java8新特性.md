---
title: Java8新特性
date: 2023-11-29 09:17:34
permalink: /pages/802d86/
---



# 流式编程

## 流式编程入门

### 基础示例

#### 需求

有一个菜肴类，其定义如下：

```java
public class Dish {

    /**
     * 名称
     */
    private final String name;
    /**
     * 是否是素食
     */
    private final boolean vegetarian;
    /**
     * 卡路里
     */
    private final int calories;
    /**
     * 类型
     */
    private final Type type;
    
    //类型枚举 分别是是:肉类 鱼类 其他
    public enum Type {MEAT, FISH, OTHER}

    public Dish(String name, boolean vegetarian, int calories, Type type) {
        this.name = name;
        this.vegetarian = vegetarian;
        this.calories = calories;
        this.type = type;
    }

    public String getName() {
        return name;
    }

    public boolean isVegetarian() {
        return vegetarian;
    }

    public int getCalories() {
        return calories;
    }

    public Type getType() {
        return type;
    }


    @Override
    public String toString() {
        return name;
    }
}
```

初始化一个菜肴集合：

```java
 public static final List<Dish> menu =
            Arrays.asList( new Dish("pork", false, 800, Dish.Type.MEAT),
                    new Dish("beef", false, 700, Dish.Type.MEAT),
                    new Dish("chicken", false, 400, Dish.Type.MEAT),
                    new Dish("french fries", true, 530, Dish.Type.OTHER),
                    new Dish("rice", true, 350, Dish.Type.OTHER),
                    new Dish("season fruit", true, 120, Dish.Type.OTHER),
                    new Dish("pizza", true, 550, Dish.Type.OTHER),
                    new Dish("prawns", false, 400, Dish.Type.FISH),
                    new Dish("salmon", false, 450, Dish.Type.FISH));
```

从中筛选出400卡的菜肴名，并且我们希望筛选出来的结果按照热量升序排列。

#### 不使用流的做法

使用`java8`之前版本的写法步骤比较繁琐，逻辑也很清晰，整体步骤为:

1. 筛选出400卡以下的菜肴。
2. 创建一个匿名比较器，并基于这个比较器对菜肴进行升序排列。
3. 将排列后的菜肴集合的名字存入字符串列表。
4. 输出结果。

```java
public static void main(String[] args) {
        List<Dish> lowCaloricDishes = new ArrayList<>();

        //筛选出小于400卡的菜肴
        for (Dish d : menu) {
            if (d.getCalories() < 400) {
                lowCaloricDishes.add(d);
            }
        }

        //按照升序进行排序
        List<String> lowCaloricDishesName = new ArrayList<>();
        Collections.sort(lowCaloricDishes, new Comparator<Dish>() {
            public int compare(Dish d1, Dish d2) {
                return Integer.compare(d1.getCalories(), d2.getCalories());
            }
        });

        //存入string列表
        for (Dish d : lowCaloricDishes) {
            lowCaloricDishesName.add(d.getName());
        }

        //输出
        for (Dish lowCaloricDish : lowCaloricDishes) {
            System.out.println(lowCaloricDish);
        }
}
```

#### 使用流的做法

```java
public static void main(String[] args) {
        menu.stream()
                //找出低于400卡的菜肴
                .filter(d -> d.getCalories() < 400)
                //按照升序排列
                .sorted(comparing(Dish::getCalories))
                //得到这些菜肴的名称
                .map(Dish::getName)
                //组成list
                .collect(toList())
                //输出结果
                .forEach(m -> System.out.println(m));
}
```



### 流的优势

1. 声明性：流式编程的所有操作都是语义化的，我们完全可以通过方法名大致猜出操作目的。
2. 可复合：流式编程无需像`jdk8`之前的版本为了实现组合操作而取创建各种临时集合，取而代之的是基于一段连续的流自顶而下的实现组合操作。
3. 可并行：当我们需要提高计算密集型任务的性能时，只需将`stream`改为`parallelStream`，就可以开启并行流开启多个线程一起工作(默认情况下，线程数和计算机的CPU核心数是一样的)。
4. 流水线：流式编程会将组合操作构成一个大的流水线，这使得我们代码能够更进一步优化，例如延迟和短路操作，使得代码可以实现类似于数据库式的查询。
5. 内部迭代：流式编程将迭代操作封装起来，对开发者透明，如此一来，开发者专注与对流内部的元素的操作，而无需关注繁琐的非业务代码

### 流的工作原理

比如从菜肴中找到前三个菜肴大于300卡的菜名：

```java
public static void main(String[] args) {
        List<String> menuNameList = menu.stream()
                //找到大于300卡的菜肴
                .filter(d -> d.getCalories() > 300)
                //取出这个菜肴的名称
                .map(Dish::getName)
                //取前3个
                .limit(3)
                //存入list中
                .collect(Collectors.toList());
        //输出结果
        System.out.println(menuNameList);
    }
```

流式编程的工作原理非常高效，它将组合操作比作一条流水线，将集合中的每一个元素都放到这个流水线上进行操作。上面的代码       工作过程是这样的：

1. 拿到`pork`，进入`filter`操作，因为其热量大于300卡，继续走到流水线下一个步骤。
2. 进入`map`操作，拿到pork对象的name。
3. 进入`limit`操作，pork还在limit限定范围，继续走到下一个操作。
4. 进入`toList`操作，将`pork`存入`list`中。
5. 同理对`beef`和`chicken`完成同样的操作，然后limit达到上限，停止流水线。

![在这里插入图片描述](https://upload.yolo912.icu/mdImage/img202310171013999.png)



### 流与集合的关系

#### 每一个集合的流只能使用一次

如下代码所示，每一个集合对应的流只能操作一次，每次操作完成之后这个流就会被关闭，这意味着用户再次使用这个流就会报错：

```java
List<String> strings = Arrays.asList("java8", "in", "action");
Stream<String> stream = strings.stream();
stream.forEach(System.out::println);
stream.forEach(System.out::println);
```

输出结果如下，可以看到对于同一个流的多次操作抛出`IllegalStateException`错误：

```java
java8
Exception in thread "main" java.lang.IllegalStateException: stream has already been operated upon or closed
in
action
	at java.util.stream.AbstractPipeline.sourceStageSpliterator(AbstractPipeline.java:279)
	at java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:580)
	at com.sharkChili.lambda.Main.main(Main.java:27)
```

#### 集合的外部迭代和流的内部迭代

流式编程将循环操作内置，对于用户是无感的，如下代码所示，我们使用peek方法打印经过这个组合操作的元素有哪些：

```java
public static void main(String[] args) {
    List<String> menuNameList = menu.stream()
    //找到大于300卡的菜肴
    .filter(d -> d.getCalories() > 300)
    .peek(d -> System.out.println("步骤1:" + d))
    //取出这个菜肴的名称
    .map(Dish::getName)
    .peek(d -> System.out.println("步骤2:" + d))
    //取前3个
    .limit(3)
    .peek(d -> System.out.println("步骤3:" + d))
    //存入list中
    .collect(Collectors.toList());
}
```

我们就会得到这样一个结果，可以看到每一个元素都会依次经过`filter`、和`map`、`limit`，这就是`jdk8`流式编程的循环合并技术：

```text
步骤1:pork
步骤2:pork
步骤3:pork
步骤1:beef
步骤2:beef
步骤3:beef
步骤1:chicken
步骤2:chicken
步骤3:chicken
```



### 流的两种操作

#### 中间操作

例如`filter`、`map`、`limit`、`sort`等只涉及元素的流水线单一步骤且最终会返回`stream`类型的方法都是中间操作，它们只有在调用终端操作(即真正要结果的方法)才会开始工作：

1. `filter`:过滤出符合预期的元素，如果不符合预期就不会走到流水线的下一步。
2. `map`:映射，将流水线的A元素转为B元素，例如上文示例中基于`Menu`的`name`字段将`Menu`对象转为`String`对象。
3. `limit`:截取前n个对象，例如上文`limit(3)`，这意味着流水线收集到3个元素之后就停止工作。
4. `sorted`:排序操作，将流水线的元素按照指定顺序排序。
5. `distinct`:去重，收集当前流水线上不重复的元素。

#### 终端操作

终端操作通俗的理解就是将中间操作得到的元素放到流水线的终点开始真正的输出，一旦中间操作得到的元素都经过终端操作后，这个流就会被关闭。例如上文中经过`filter`、`map`、`limit`得到的元素都走到`collect`这个收集元素的终端操作后，流就关闭了，一旦我们再次使用这个流就会报错。

`java8`对应的终端操作有:

1. `forEach`:将中间操作得到的元素进行一次遍历。
2. `count`:统计中间操作得到的元素个数，个数的类型为long类型。
3. `collect`:将中间操作得到的元素归为一个集合。





## 流式编程详解

### 元素的筛选

#### 常规过滤筛选

菜肴类的`vegetarian`这个布尔值决定了菜肴是否为蔬菜，我们希望从这个集合中找到所有的蔬菜并返回一个list。

```java
public static void main(String[] args) {
        List<Dish> vegetarianMenu =
                menu.stream()
                        //使用filter 结合函数式编程筛选出vegetarian 为true的菜肴
                        .filter(Dish::isVegetarian)
                        //将这些流组成一个list数组
                        .collect(toList());
        //遍历vegetarianMenu
        vegetarianMenu.forEach(System.out::println);

}
```

将每一个元素放到流式操作的流水线上，符合预期的存入list，不符合预期的淘汰

#### 找出不重复元素

现有一个无序且包含重复元素的整型数组，从中筛选出能够被2整除的数字并构成一个list集合：

```java
  List<Integer> numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4);
```

在`java8`之前：

1. for循环找到被2整除的元素。
2. 将该元素存到set中。
3. 将set转转为list。

`java8`之后使用流：

1. 拿到集合流。
2. 使用filter过滤出被2整除的元素，传到流水线下一步工序。
3. 使用distinct判断是否重复。
4. 存入list中。

```java
public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4);
        List<Integer> integerList = numbers.stream()
                //过滤出能够被2整除的数字
                .filter(i -> i % 2 == 0)
                //去重
                .distinct()
                //循环遍历
                .collect(Collectors.toList());
}
```

#### 限制筛选元素

找到热量大于300卡的前3道菜

`java8`之前：for循环加上一个count变量，当找到三道菜了就停止循环。

`java8`之后：提供语义化的操作`limit`方法，只需通过`filter`找到大于300卡的菜肴后，直接使用`limit`完成限制筛选

```java
public static void main(String[] args) {
        List<Dish> menuList = menu.stream()
                //过滤出300卡的菜肴
                .filter(d -> d.getCalories() > 300)
                //筛选出最先3个符合预期的菜肴
                .limit(3)
                .collect(toList());
}
```

#### 跳过某些元素进行筛选

跳过前两个高于`300`卡的菜，再筛选出3道高于300卡的菜肴

对于`java8`而言，只需加一个`skip`操作即可完成:

```java
public static void main(String[] args) {
        List<Dish> menuList = menu.stream()
                //过滤出300卡的菜肴
                .filter(d -> d.getCalories() > 300)
                //跳过前两道热量高于300卡的菜
                .skip(2)
                //筛选出最先3个符合预期的菜肴
                .limit(3)
                .collect(toList());
}
```



### 映射

从菜肴中拿到所有菜肴的名字

`java8`之前：声明一个`List<String>`的临时集合，然后遍历菜肴集合，获取到每个菜肴的名字，添加到`List<String>`这个集合中。

`java8`之后：基于`map`方法即可映射出所需要的成员属性，结合终端操作`collect(toList())`将映射结果转为`list`

```java
public static void main(String[] args) {
        List<String> dishNames = menu.stream()
                //拿到每一个菜肴的名字
                .map(Dish::getName)
                //存入list集合中
                .collect(toList());
}
```

####  映射扁平化

从 `List<String>` 的单词数组中找出所有不重复的字母，对应的单词数组定义如下：

```text
 List<String> words = Arrays.asList("Hello", "World");
```

①第一时间可能想到这样，将数组中每个单词切成一个个字母，然后`distinct`去重，最后转成`list`输出

```java
public static void main(String[] args) {
        List<String> words = Arrays.asList("Hello", "World");
        List<String[]> resultList = words.stream()
                //这里映射的是stream<String[]> 后续的中间操作没有什么作用
                .map(w -> w.split(""))
                .distinct()
                .collect(toList());

        for (String[] strings : resultList) {
            for (String string : strings) {
                System.out.print(string);
            }
            System.out.println();
        }
}
```

这样的做法，最终得到的是一个 `List<String[]>`，`map(w -> w.split(""))`会将`hello World`分别切割成`String[]`,然后两个`String[]`，很显然对一个数组`distinct`自然是没有任何作用的

②通过`map(Arrays::stream)`，将切割后的`string[]`转为`Stream<String>`再进行去重:

```java
public static void main(String[] args) {
        List<String> words = Arrays.asList("Hello", "World");
        List<Stream<String>> list = words.stream()
                .map(w -> w.split(""))
                //将stream<String[]>转为stream<String> 但还是没有解决问题 因为将数组变成string流
                .map(Arrays::stream)
                .distinct()
                .collect(toList());

        for (Stream<String> stream : list) {
            List<String> stringList = stream.collect(Collectors.toList());
            for (String s : stringList) {
                System.out.print(s);
            }
            System.out.println();
        }
}
```

但是去重再转为数组后得到类型却是 `List<Stream<String>>`，这意味着我们只是将两个单词转为两个独立的`stream<String>`，去重的对象并不是我们希望的

**③正确的写法**：通过`flatMap`调用`Arrays::stream`，即可完成将两个独立的`Stream<String>`合并成一个扁平的`Stream<String>`

```java
public static void main(String[] args) {
        List<String> words = Arrays.asList("Hello", "World");

        List<String> wordList = words.stream()
                .map(w -> w.split(""))
                //将数组扁平化合并为流
                .flatMap(Arrays::stream)
                .distinct()
                .collect(toList());

        for (String s : wordList) {
            System.out.println(s);
        }
    	/*
    	
        words.stream()
            .flatMap((String line) -> Arrays.stream(line.split("")))
            .distinct()
            .forEach(System.out::println);
        */

}
```



### 查找和匹配

#### 检查是否至少匹配一个元素

想知道菜肴集合中是否存在素菜，可以使用`anyMatch`方法，该方法是一个终端操作，返回一个`boolean`值，只要集合中看到一个素食的菜肴，那么就会返回`true`：

```java
public static void main(String[] args) {
        System.out.println(menu.stream().anyMatch(Dish::isVegetarian));
}
```

输出结果：

`anyMatch`只要匹配到符合要求的元素之后，就立即停止并关闭流

```java
true
```

#### 检查流元素是否都匹配

同理如果需要全部匹配，就用`allMatch`，例如判断菜肴中的菜肴是否都是低于1000卡的：

```java
menu.stream()
.allMatch(d -> d.getCalories() < 1000);
```

#### 检查流元素是否都不都匹配

反过来找低于1000卡的

```java
menu.stream()
.noneMatch(d -> d.getCalories() >= 1000);
```

#### 查找元素

找出菜肴中是否包含素食，如果有则告知查到的素食是什么菜，可以通过使用`findAny`方法做到这一点：

```java
public static void main(String[] args) {
        Optional<Dish> optionalDish = menu.stream()
                .filter(Dish::isVegetarian)
                //只要找到符合要求的菜肴，就直接停止并关闭流
                .findAny();

        //如果可以找到符合要求的元素，则直接输出打印
        if (optionalDish.isPresent()){
            System.out.println(optionalDish.get());
        }
}
```

但是返回值不是`Dish`而是`Optional<Dish>`

Optional的相关概念：

1. `Optional`有个`isPresent()`方法，就以本例来说，假如集合中包含素食，我们调用这个方法就会返回`true`，说明找到了素食，反之返回`false`
2. `get()`方法，以本示例来说，假如找到了素食，get就会返回菜肴对象，若没找到则报出`NoSuchElement`异常
3. `orElse()`相比上一个方法更加友好，假如我们找到值就返回值，反之就返回`orElse`传入的参数值。

输出结果:

```java
french fries
```

#### 查找第一个元素

相比于查找元素，查找第一个元素语义化更加明显，例如想找到第一道素食，就可以使用`findFirst`，实际上关于`findAny`和`findFirst`的使用场景区别不大，但是在并行的情况下，你想找到第一道素食的话，建议你使用`findFirst`，反之使用`findAny`即可，因为它使用并行流来说限制较少一些：

```java
 public static void main(String[] args) {
        Optional<Dish> optionalDish = menu.stream()
                .filter(Dish::isVegetarian)
                //只要找到符合要求的菜肴，就直接停止并关闭流
                .findFirst();

        //如果可以找到符合要求的元素，则直接输出打印
        if (optionalDish.isPresent()){
            System.out.println(optionalDish.get());
        }
}
```



### 规约

#### 元素求和

在`java8`之前，元素求和计算都需要经过这三步：

1. 创建`sum`变量。
2. 遍历集合，取出集合元素。
3. 元素就和。

`java8`之后只需使用`reduce`结合求和表达式即可实现元素求和：

```java
public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(4, 5, 3, 9);
        //起始数字为0，将列表中的元素全部累加
        int res = numbers.stream()
                .reduce(0, (sum, num) ->sum+num);
        //输出结果
        System.out.println(res);
    }
```

输出结果如下：

```java
21
```

基于上述代码我们使用`Integer`内置的一个相加的方法`sum`，于是代码就可以简化成下面这样：

```java
public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(4, 5, 3, 9);
        //起始数字为0，将列表中的元素全部累加
        int res = numbers.stream()
                .reduce(0, Integer::sum);
        //输出结果
        System.out.println(res);

    }
```

假如统计操作无需初始值的话，也可以像下文这种写法，这正是java8的高明之处，返回一个Optional操作，让你有余地进行判空操作

```java
·//无需初始值
Optional<Integer> res = numbers.stream().reduce(Integer::sum);
System.out.println(res.get());
```

#### 求最大值和最小值

```java
//求最大值
int max = numbers.stream().reduce(0, (a, b) -> Integer.max(a, b));
System.out.println(max);
//求最最小值
Optional<Integer> min = numbers.stream().reduce(Integer::min);
min.ifPresent(System.out::println);
```



例子：用流式编程统计出菜肴的数量，可以看到笔者的做法很巧妙，通过映射将每道菜计算为1，传到reduce流中统计计算

```java
 Optional<Integer> menuCount = menu.stream()
                .map(d -> 1)
                .reduce(Integer::sum);
 System.out.println(menuCount.get());
```

甚至可以简写成这样，因为`java8`为我们提供了这样的终端操作

```java
 long count = menu.stream().count();
 System.out.println(count);
```



### 实践

定义一个交易员的类

```java
public class Trader {

    /**
     * 姓名
     */
    private String name;
    /**
     * 居住城市
     */
    private String city;

    public Trader(String n, String c) {
        this.name = n;
        this.city = c;
    }

    public String getName() {
        return this.name;
    }

    public String getCity() {
        return this.city;
    }

    public void setCity(String newCity) {
        this.city = newCity;
    }

    public String toString() {
        return "Trader:" + this.name + " in " + this.city;
    }
}
```

交易订单类

```java
public class Transaction{

    /**
     * 交易员
     */
    private Trader trader;
    /**
     * 交易年份
     */
    private int year;
    /**
     * 交以金额
     */
    private int value;

    public Transaction(Trader trader, int year, int value)
    {
        this.trader = trader;
        this.year = year;
        this.value = value;
    }

    public Trader getTrader(){
        return this.trader;
    }

    public int getYear(){
        return this.year;
    }

    public int getValue(){
        return this.value;
    }

    public String toString(){
        return "{" + this.trader + ", " +
                "year: "+this.year+", " +
                "value:" + this.value +"}";
    }
}
```

用这两个类，构成了一个关于订单的列表:

```java
//4个交易员
Trader raoul = new Trader("Raoul", "Cambridge");
Trader mario = new Trader("Mario", "Milan");
Trader alan = new Trader("Alan", "Cambridge");
Trader brian = new Trader("Brian", "Cambridge");

//4个交易员的订单总表
List<Transaction> transactions = Arrays.asList(
    new Transaction(brian, 2011, 300),
    new Transaction(raoul, 2012, 1000),
    new Transaction(raoul, 2011, 400),
    new Transaction(mario, 2012, 710),
    new Transaction(mario, 2012, 700),
    new Transaction(alan, 2012, 950)
);
```

#### 问题

基于上述代码，给出下面几道问题:

```
(1) 找出2011年发生的所有交易，并按交易额排序（从低到高）。
(2) 交易员都在哪些不同的城市工作过？
(3) 查找所有来自于剑桥的交易员，并按姓名排序。
(4) 返回所有交易员的姓名字符串，按字母顺序排序。
(5) 有没有交易员是在米兰工作的？
(6) 打印生活在剑桥的交易员的所有交易额。
(7) 所有交易中，最高的交易额是多少？
(8) 找到交易额最小的交易。
```

#### 对应答案

问题1：

```java
//找出2011年发生的所有交易，并按交易额排序（从低到高）
List<Transaction> transactions_2011 = transactions.stream()
    .filter(t -> t.getYear() == 2011)
    .sorted(comparing(Transaction::getValue))
    .collect(toList());
System.out.println(transactions_2011);
```

问题2：

```java
//交易员都在哪些不同的城市工作过
List<String> citys = transactions.stream()
    .map(Transaction::getTrader)
    .map(Trader::getCity)
    .distinct()
    .collect(toList());
System.out.println(citys);
```

问题3：

```java
//查找所有来自于剑桥的交易员，并按姓名排序
List<Trader> cambridgeTraders = transactions.stream()
    .map(Transaction::getTrader)
    .filter(t -> "Cambridge".equals(t.getCity()))
    .distinct()
    .sorted(comparing(Trader::getName))
    .collect(toList());
System.out.println(cambridgeTraders);
```

问题4：

```java
//返回所有交易员的姓名字符串，按字母顺序排序。×
String names = transactions.stream()
    .map(Transaction::getTrader)
    .map(Trader::getName)
    .distinct()
    .sorted()
    .reduce("", (s1, s2) -> s1 + s2);
System.out.println(names);
```

问题5：

```java
//有没有交易员是在米兰工作的？ 
boolean hasMilan = transactions.stream()
    .anyMatch(t -> "Milan".equals(t.getTrader().getCity()));
```

问题6：

```java
//打印生活在剑桥的交易员的所有交易额。
Optional<Integer> sum = transactions.stream()
    .filter(t -> "Cambridge".equals(t.getTrader().getCity()))
    .map(Transaction::getValue)
    .reduce(Integer::sum);
System.out.println(sum.get());
```

问题7:

```java
//所有交易中，最高的交易额是多少？
Optional<Integer> max = transactions.stream()
    .map(Transaction::getValue)
    .reduce(Integer::max);
System.out.println(max.get());
```

问题8:

```java
//找到交易额最小的交易
Optional<Transaction> min = transactions.stream()
    .min(comparing(Transaction::getValue));
System.out.println(min);
```
