---
title: Spring6源码
date: 2024-08-05 17:23:12
permalink: /pages/aade10/
---





# 一. IOC容器

## 1.1 @Configuration注解

@Configuration注解是从Spring 3.0版本开始加入的一个使Spring能够支持注解驱动开发的标注型注解，主要用于标注在类上。当某个类标注了@Configuration注解时，表示这个类是Spring的一个配置类。@Configuration注解能够替代Spring的applicationContext.xml文件，并且被@Configuration注解标注的类，能够自动注册到IOC容器并进行实例化。

### 注解源码

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Configuration {
	@AliasFor(annotation = Component.class)
	String value() default "";
    //Since: 5.2
	boolean proxyBeanMethods() default true;
    //Since: 6.0
	boolean enforceUniqueMethods() default true;
}
```

@Configuration注解中每个属性的含义如下所示。

* value：存入到Spring IOC容器中的Bean的id。
* proxyBeanMethods：表示被@Configuration注解标注的配置类是否会被代理，并且在配置类中使用@Bean注解生成的Bean对象在IOC容器中是否是单例对象，取值为true或者false。当取值为true时，表示full（全局）模式，此模式下被@Configuration注解标注的配置类会被代理，在配置类中使用@Bean注解注入到IOC容器中的Bean对象是单例模式，无论调用多少次被@Bean注解标注的方法，返回的都是同一个Bean对象。当取值为false时，表示lite（轻量级）模式，此模式下被@Configuration注解标注的配置类不会被代理，在配置类中使用@Bean注解注入到IOC容器中的Bean对象不是单例模式，每次调用被@Bean注解标注的方法时，都会返回一个新的Bean对象。默认的取值为true。
* enforceUniqueMethods：指定使用@Bean注解标注的方法是否需要具有唯一的方法名称，取值为true或者false。当取值为true时，表示使用@Bean注解标注的方法具有唯一的方法名称，并且这些方法名称不会重叠。当取值为false时，表示使用@Bean注解标注的方法名称不唯一，存在被重叠的风险。默认取值为true。

@Configuration注解本质上是一个@Component注解，所以被@Configuration注解标注的配置类本身也会被注册到IOC容器中。同时，@Configuration注解也会被@ComponentScan注解扫描到。

### 源码时序图

@Configuration注解在源码层面的执行流程涉及到注册与实例化两种执行流程。

* 注册流程：涉及到Spring内部的ConfigurationClassPostProcessor类的Bean定义信息的注册，以及标注了@Configuration注解的Config配置类的Bean定义信息注册。
* 实例化流程：Spring IOC容器在启动过程中，最终会调用AnnotationConfigApplicationContext类的refresh()方法刷新IOC容器，刷新IOC容器的过程中就会对标注了@Configuration注解的配置类进行实例化。

#### **注册ConfigurationClassPostProcessor流程源码时序图**

ConfigurationClassPostProcessor后置处理器是解析@Configuration注解的核心类，Spring IOC容器启动时，会向IOC容器中注册ConfigurationClassPostProcessor类的Bean定义信息。

![图1-1](https://upload.yolo912.icu/mdImage/spring-core-2022-12-05-001.png)

#### **注册配置类流程源码时序图**

在配置类上标注了@Configuration注解，当Spring IOC容器启动时，也会将配置类的Bean定义信息注册到Spring IOC容器中

![图1-2](https://upload.yolo912.icu/mdImage/spring-core-2022-12-05-002.png)

> Spring IOC容器在启动时，会向IOC容器中注册ConfigurationClassPostProcessor类的bean定义信息和使用@Configuration注解标注的配置类的Bean定义信息。当Spring IOC容器再刷新时，会递归处理所有使用@Configuration注解标注的类，解析@Bean等注解标注的方法，解析成一个个ConfigurationClassBeanDefinition类型的BeanDefinition对象，注册到IOC容器中。

#### **实例化流程源码时序图**

Spring IOC容器在启动过程中，最终会调用AnnotationConfigApplicationContext类的refresh()方法刷新IOC容器，刷新IOC容器的过程中就会对标注了@Configuration注解的配置类进行实例化。

![图1-3-1](https://upload.yolo912.icu/mdImage/spring-core-2022-12-05-003.png)

![图1-3-2](https://upload.yolo912.icu/mdImage/spring-core-2022-12-05-004.png)

### 源码解析

#### 注册ConfigurationClassPostProcessor流程源码解析

（1）运行案例程序启动类ConfigurationAnnotationTest的main()方法

```java
public class ConfigurationAnnotationTest {

    private static final Logger LOGGER = LoggerFactory.getLogger(ConfigurationAnnotationTest.class);

    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ConfigurationAnnotationConfig.class);
        ConfigurationAnnotationConfig config = context.getBean(ConfigurationAnnotationConfig.class);
        Person person1 = config.person();
        Person person2 = config.person();
        LOGGER.info("person1 是否等于 person2 ===>> {}", (person1 == person2));
    }
}
```

在main()方法中会调用AnnotationConfigApplicationContext类的构造方法传入配置类ConfigurationAnnotationConfig的Class对象来创建IOC容器。接下来，会进入AnnotationConfigApplicationContext类的构造方法。

（2）解析AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext(Class<?>... componentClasses)构造方法

```java
public AnnotationConfigApplicationContext(Class<?>... componentClasses) {
    this();
    register(componentClasses);
    refresh();
}
```

上述构造方法中，会通过this()调用AnnotationConfigApplicationContext类的无参构造方法。

（3）解析AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext()无参构造方法

```java
public AnnotationConfigApplicationContext() {
    StartupStep createAnnotatedBeanDefReader = this.getApplicationStartup().start("spring.context.annotated-bean-reader.create");
    this.reader = new AnnotatedBeanDefinitionReader(this);
    createAnnotatedBeanDefReader.end();
    this.scanner = new ClassPathBeanDefinitionScanner(this);
}
```

在AnnotationConfigApplicationContext类的无参构造方法中，主要的逻辑就是实例化了AnnotatedBeanDefinitionReader类型的reader成员变量和ClassPathBeanDefinitionScanner类型的scanner成员变量。

* reader：表示注解类型的Bean定义信息读取器，主要就是读取通过注解方式进行实例化的Bean的定义信息。
* scanner：表示类路径下的Bean定义扫描器，主要就是扫描类路径下的Bean定义信息。

接下来会调用AnnotatedBeanDefinitionReader类中的AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry)构造方法。

（4）解析AnnotatedBeanDefinitionReader类中的AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry)构造方法

```java
public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry) {
    this(registry, getOrCreateEnvironment(registry));
}
```

在上述构造方法中，通过this调用了AnnotatedBeanDefinitionReader类的AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment)构造方法。

（5）解析AnnotatedBeanDefinitionReader类的AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment)构造方法

```java
public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment) {
    Assert.notNull(registry, "BeanDefinitionRegistry must not be null");
    Assert.notNull(environment, "Environment must not be null");
    this.registry = registry;
    this.conditionEvaluator = new ConditionEvaluator(registry, environment, null);
    AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);
}
```

在上述构造方法中，最核心的逻辑就是调用了AnnotationConfigUtils工具类的registerAnnotationConfigProcessors()方法，将BeanDefinitionRegistry类型的registry对象传入方法中。registry对象本质上就是一个AnnotationConfigApplicationContext类对象的实例，因为AnnotationConfigApplicationContext类继承了GenericApplicationContext类，而GenericApplicationContext类实现了BeanDefinitionRegistry接口。

（6）解析AnnotationConfigUtils类的registerAnnotationConfigProcessors(BeanDefinitionRegistry registry)方法

```java
public static void registerAnnotationConfigProcessors(BeanDefinitionRegistry registry) {
    registerAnnotationConfigProcessors(registry, null);
}
```

（7）解析AnnotationConfigUtils类的registerAnnotationConfigProcessors(BeanDefinitionRegistry registry, Object source)方法

```java
public static Set<BeanDefinitionHolder> registerAnnotationConfigProcessors(
			BeanDefinitionRegistry registry, @Nullable Object source) {

    // 获取默认的ListableBeanFactory
    DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);
    if (beanFactory != null) {
        // 如果依赖比较器不是AnnotationAwareOrderComparator的实例，则设置依赖比较器为AnnotationAwareOrderComparator
        if (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) {
            beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);
        }
        // 如果自动装配候选解析器不是ContextAnnotationAutowireCandidateResolver的实例，则设置自动装配候选解析器为新的ContextAnnotationAutowireCandidateResolver
        if (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) {
            beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());
        }
    }

    // 创建一个LinkedHashSet来存储bean定义
    Set<BeanDefinitionHolder> beanDefs = new LinkedHashSet<>(8);

    // 如果注册表中不存在CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME的bean定义
    if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {
        // 创建一个新的RootBeanDefinition实例，并设置其类为ConfigurationClassPostProcessor
        RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);
        // 设置bean定义的源为传入的source
        def.setSource(source);
        // 注册后处理器，并将返回的BeanDefinitionHolder添加到beanDefs集合中
        beanDefs.add(registerPostProcessor(registry, def,CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));
    }

    // 如果注册表中不存在AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME的bean定义
    if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {
        // 创建一个新的RootBeanDefinition实例，并设置其类为AutowiredAnnotationBeanPostProcessor
        RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);
        // 设置bean定义的源为传入的source
        def.setSource(source);
        // 注册后处理器，并将返回的BeanDefinitionHolder添加到beanDefs集合中
        beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));
    }

    // 检查是否存在Jakarta Annotations支持，如果存在则添加CommonAnnotationBeanPostProcessor
    // Check for Jakarta Annotations support, and if present add the CommonAnnotationBeanPostProcessor.
    if (jakartaAnnotationsPresent && !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) {
        // 创建一个新的RootBeanDefinition实例，并设置其类为CommonAnnotationBeanPostProcessor
        RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);
        // 设置bean定义的源为传入的source
        def.setSource(source);
        // 注册后处理器，并将返回的BeanDefinitionHolder添加到beanDefs集合中
        beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));
    }

    // 检查是否支持JSR-250，如果支持则添加InitDestroyAnnotationBeanPostProcessor用于javax的PostConstruct/PreDestroy注解
    if (jsr250Present && !registry.containsBeanDefinition(JSR250_ANNOTATION_PROCESSOR_BEAN_NAME)) {
        try {
            // 创建InitDestroyAnnotationBeanPostProcessor的RootBeanDefinition
            RootBeanDefinition def = new RootBeanDefinition(InitDestroyAnnotationBeanPostProcessor.class);
            // 添加initAnnotationType属性，值为javax.annotation.PostConstruct的Class对象
            def.getPropertyValues().add("initAnnotationType", classLoader.loadClass("javax.annotation.PostConstruct"));
            // 添加destroyAnnotationType属性，值为javax.annotation.PreDestroy的Class对象
            def.getPropertyValues().add("destroyAnnotationType", classLoader.loadClass("javax.annotation.PreDestroy"));
            // 设置bean定义的源为传入的source
            def.setSource(source);
            // 注册后处理器，并将返回的BeanDefinitionHolder添加到beanDefs集合中
            beanDefs.add(registerPostProcessor(registry, def, JSR250_ANNOTATION_PROCESSOR_BEAN_NAME));
        }
        catch (ClassNotFoundException ex) {
            // 加载javax注解类型的类失败，忽略异常
            // Failed to load javax variants of the annotation types -> ignore.
        }
    }

    // 检查是否支持JPA，如果支持则添加PersistenceAnnotationBeanPostProcessor
    if (jpaPresent && !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) {
        // 创建RootBeanDefinition
        RootBeanDefinition def = new RootBeanDefinition();
        try {
            // 设置bean的类为PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME指定的类
            def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,
                                                AnnotationConfigUtils.class.getClassLoader()));
        }
        catch (ClassNotFoundException ex) {
            // 抛出异常，无法加载可选的框架类
            throw new IllegalStateException(
                "Cannot load optional framework class: " + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);
        }
        // 设置bean定义的源为传入的source
        def.setSource(source);
        // 注册后处理器，并将返回的BeanDefinitionHolder添加到beanDefs集合中
        beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));
    }

    // 如果注册表中不存在EVENT_LISTENER_PROCESSOR_BEAN_NAME的bean定义
    if (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) {
        // 创建EventListenerMethodProcessor的RootBeanDefinition
        RootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);
        // 设置bean定义的源为传入的source
        def.setSource(source);
        // 注册后处理器，并将返回的BeanDefinitionHolder添加到beanDefs集合中
        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));
    }

    // 如果注册表中不存在EVENT_LISTENER_FACTORY_BEAN_NAME的bean定义
    if (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) {
        // 创建DefaultEventListenerFactory的RootBeanDefinition
        RootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);
        // 设置bean定义的源为传入的source
        def.setSource(source);
        // 注册后处理器，并将返回的BeanDefinitionHolder添加到beanDefs集合中
        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));
    }

    // 返回beanDefs集合
    return beanDefs;
}
```

其中将@Configuration注解涉及到的ConfigurationClassPostProcessor类的Bean定义信息注册到IOC容器中的核心代码为：

```java
public static Set<BeanDefinitionHolder> registerAnnotationConfigProcessors(
			BeanDefinitionRegistry registry, @Nullable Object source) {
    //################省略其他代码########################
    // 如果注册表中不存在CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME的bean定义
    if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {
        // 创建一个新的RootBeanDefinition实例，并设置其类为ConfigurationClassPostProcessor
        RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);
        // 设置bean定义的源为传入的source
        def.setSource(source);
        // 注册后处理器，并将返回的BeanDefinitionHolder添加到beanDefs集合中
        beanDefs.add(registerPostProcessor(registry, def,CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));
    }
    //################省略其他代码########################
}
```

（8）解析registerPostProcessor(BeanDefinitionRegistry registry, RootBeanDefinition definition, String beanName)方法

```java
private static BeanDefinitionHolder registerPostProcessor(
    BeanDefinitionRegistry registry, RootBeanDefinition definition, String beanName) {
    definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
    registry.registerBeanDefinition(beanName, definition);
    return new BeanDefinitionHolder(definition, beanName);
}
```

上述代码调用了registry参数的registerBeanDefinition()方法来注册ConfigurationClassPostProcessor类的Bean定义信息，definition参数本质上就是一个AnnotationConfigApplicationContext类的实例对象。最终会调用DefaultListableBeanFactory类的registerBeanDefinition()方法来注册ConfigurationClassPostProcessor类的Bean定义信息。

（9）解析DefaultListableBeanFactory类的registerBeanDefinition(String beanName, BeanDefinition beanDefinition)方法

```java
@Override
public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
    throws BeanDefinitionStoreException {

    // 断言beanName非空
    Assert.hasText(beanName, "Bean name must not be empty");
    // 断言beanDefinition非空
    Assert.notNull(beanDefinition, "BeanDefinition must not be null");

    // 判断beanDefinition是否是AbstractBeanDefinition的实例
    if (beanDefinition instanceof AbstractBeanDefinition abd) {
        try {
            // 验证bean定义
            abd.validate();
        }
        catch (BeanDefinitionValidationException ex) {
            // 抛出BeanDefinitionStoreException异常，包含bean定义资源描述、beanName以及异常信息
            throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
                                                   "Validation of bean definition failed", ex);
        }
    }

    // 获取beanName对应的BeanDefinition
    BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);

    if (existingDefinition != null) {
        if (!isAllowBeanDefinitionOverriding()) {
            // 如果不允许覆盖Bean定义，则抛出异常
            throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);
        }
        else if (existingDefinition.getRole() < beanDefinition.getRole()) {
            // 如果现有Bean定义的角色小于新Bean定义的角色，则进行覆盖
            // 例如，之前是ROLE_APPLICATION，现在用ROLE_SUPPORT或ROLE_INFRASTRUCTURE覆盖
            if (logger.isInfoEnabled()) {
                logger.info("Overriding user-defined bean definition for bean '" + beanName +
                            "' with a framework-generated bean definition: replacing [" +
                            existingDefinition + "] with [" + beanDefinition + "]");
            }
        }
        else if (!beanDefinition.equals(existingDefinition)) {
            // 如果新Bean定义与现有Bean定义不相等，则进行覆盖
            if (logger.isDebugEnabled()) {
                logger.debug("Overriding bean definition for bean '" + beanName +
                             "' with a different definition: replacing [" + existingDefinition +
                             "] with [" + beanDefinition + "]");
            }
        }
        else {
            // 如果新Bean定义与现有Bean定义相等，则进行覆盖（尽管它们相等，但可能由于其他原因需要覆盖）
            if (logger.isTraceEnabled()) {
                logger.trace("Overriding bean definition for bean '" + beanName +
                             "' with an equivalent definition: replacing [" + existingDefinition +
                             "] with [" + beanDefinition + "]");
            }
        }
        // 将新Bean定义放入beanDefinitionMap中，覆盖现有Bean定义
        this.beanDefinitionMap.put(beanName, beanDefinition);
    }
    else {
        if (isAlias(beanName)) {
            if (!isAllowBeanDefinitionOverriding()) {
                String aliasedName = canonicalName(beanName);
                if (containsBeanDefinition(aliasedName)) {
                    // 如果别名指向已存在的Bean定义
                    // alias for existing bean definition
                    throw new BeanDefinitionOverrideException(
                        beanName, beanDefinition, getBeanDefinition(aliasedName));
                }
                else {
                    // 如果别名指向不存在的Bean定义
                    // alias pointing to non-existing bean definition
                    throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
                                                           "Cannot register bean definition for bean '" + beanName +
                                                           "' since there is already an alias for bean '" + aliasedName + "' bound.");
                }
            }
            else {
                // 移除别名
                removeAlias(beanName);
            }
        }
        if (hasBeanCreationStarted()) {
            // 不能再修改启动时的集合元素（为了稳定的迭代）
            // Cannot modify startup-time collection elements anymore (for stable iteration)
            synchronized (this.beanDefinitionMap) {
                this.beanDefinitionMap.put(beanName, beanDefinition);
                List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);
                updatedDefinitions.addAll(this.beanDefinitionNames);
                updatedDefinitions.add(beanName);
                this.beanDefinitionNames = updatedDefinitions;
                removeManualSingletonName(beanName);
            }
        }
        else {
            // 仍然处于启动注册阶段
            // Still in startup registration phase
            this.beanDefinitionMap.put(beanName, beanDefinition);
            this.beanDefinitionNames.add(beanName);
            removeManualSingletonName(beanName);
        }
        this.frozenBeanDefinitionNames = null;
    }

    if (existingDefinition != null || containsSingleton(beanName)) {
        // 重置Bean定义
        resetBeanDefinition(beanName);
    }
    else if (isConfigurationFrozen()) {
        // 清除按类型缓存
        clearByTypeCache();
    }
}
```

向Spring的IOC容器中注册类的Bean定义信息，其实就是向beanDefinitionMap对象中添加元素，beanDefinitionMap对象本质上是一个ConcurrentHashMap对象。向beanDefinitionMap对象中添加的元素的Key为Bean的名称，Value为Bean的定义信息。

```java
@Override
public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
    throws BeanDefinitionStoreException {
    //##################省略其他代码###############
	this.beanDefinitionMap.put(beanName, beanDefinition);
    //##################省略其他代码###############
}
```

beanDefinitionMap源码:

```java
private final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>(256);
```

#### 注册配置类流程源码解析

（1）AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext(Class<?>... componentClasses)构造方法中调用了register()方法，传入componentClasses参数进行注册。

```java
public AnnotationConfigApplicationContext(Class<?>... componentClasses) {
    this();
    register(componentClasses);
    refresh();
}
```

（2）解析AnnotationConfigApplicationContext类的register(Class<?>... componentClasses)方法

```java
@Override
public void register(Class<?>... componentClasses) {
	//###########省略其他代码##############
    this.reader.register(componentClasses);
    //###########省略其他代码##############
}
```

（3）解析AnnotatedBeanDefinitionReader类的register(Class<?>... componentClasses)方法

```java
public void register(Class<?>... componentClasses) {
    for (Class<?> componentClass : componentClasses) {
        registerBean(componentClass);
    }
}
```

（4）解析AnnotatedBeanDefinitionReader类的registerBean(Class<?> beanClass)方法

```java
public void registerBean(Class<?> beanClass) {
    doRegisterBean(beanClass, null, null, null, null);
}
```

（5）解析AnnotatedBeanDefinitionReader类的doRegisterBean(Class<T> beanClass, String name, Class<? extends Annotation>[] qualifiers, Supplier<T> supplier, BeanDefinitionCustomizer[] customizers)方法。

```java
private <T> void doRegisterBean(Class<T> beanClass, @Nullable String name,@Nullable Class<? extends Annotation>[] qualifiers, @Nullable Supplier<T> supplier, @Nullable BeanDefinitionCustomizer[] customizers) {

    AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(beanClass);
    //###########################省略其他代码#############################
    String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));
    //###########################省略其他代码#############################
    BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);
    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
    BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
}
```

（6）解析BeanDefinitionReaderUtils类的registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)方法

```java
public static void registerBeanDefinition(
    BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
    throws BeanDefinitionStoreException {

    // Register bean definition under primary name.
    String beanName = definitionHolder.getBeanName();
    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
    //###########################省略其他代码#############################
}
```

在registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)方法中通过调用registry的registerBeanDefinition()方法来向IOC容器中注册Bean定义信息。

#### 实例化流程源码解析

（1）AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext(Class<?>... componentClasses)构造方法中会调用refresh()方法刷新IOC容器。

```java
public AnnotationConfigApplicationContext(Class<?>... componentClasses) {
    this();
    register(componentClasses);
    refresh();
}
```

（2）解析AbstractApplicationContext类的refresh()方法

```java
@Override
public void refresh() throws BeansException, IllegalStateException {
    synchronized (this.startupShutdownMonitor) {
		//#############省略其他代码#####################
        try {
            //#############省略其他代码#####################
            invokeBeanFactoryPostProcessors(beanFactory);
			//#############省略其他代码#####################
        }
        catch (BeansException ex) {
           //#############省略其他代码#####################
        }
        finally {
           //#############省略其他代码#####################
        }
    }
}
```

在refresh()方法中调用了invokeBeanFactoryPostProcessors()方法。

（3）解析AbstractApplicationContext类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory)方法

```java
protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
	//################省略其他代码####################
}
```

（4）解析PostProcessorRegistrationDelegate类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors)方法

```java
public static void invokeBeanFactoryPostProcessors(
    ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {
	//#################省略其他代码##################
    invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
	invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
    //#################省略其他代码##################
}
```

在invokeBeanFactoryPostProcessors()方法中会解析标注了@Configuration注解的类中标注了@Bean等注解的方法，生成相应的Bean定义信息注册到IOC容器中。这里主要关注的是标注了@Configuration注解的类的实例化过程

（5）解析PostProcessorRegistrationDelegate类的invokeBeanFactoryPostProcessors(Collection<? extends BeanFactoryPostProcessor> postProcessors, ConfigurableListableBeanFactory beanFactory)方法

```java
private static void invokeBeanFactoryPostProcessors(Collection<? extends BeanFactoryPostProcessor> postProcessors, ConfigurableListableBeanFactory beanFactory) {
    for (BeanFactoryPostProcessor postProcessor : postProcessors) {
        StartupStep postProcessBeanFactory = beanFactory.getApplicationStartup().start("spring.context.bean-factory.post-process")
            .tag("postProcessor", postProcessor::toString);
        postProcessor.postProcessBeanFactory(beanFactory);
        postProcessBeanFactory.end();
    }
}
```

可以看到在invokeBeanFactoryPostProcessors()方法中，会循环遍历传递进来的所有postProcessors集合，每次循环时，都会使用一个postProcessor对象来接收postProcessors集合中的每一个元素，调用postProcessor对象的postProcessBeanFactory()方法，并传入beanFactory来实例化对象。

（6）解析ConfigurationClassPostProcessor类中的postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)方法

```java
@Override
public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
    //##############省略其他代码###############
    enhanceConfigurationClasses(beanFactory);
    beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory));
}
```

（7）解析ConfigurationClassPostProcessor类的enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory)方法

```java
public void enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory) {
    //################省略其他代码########################
    ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer();
    for (Map.Entry<String, AbstractBeanDefinition> entry : configBeanDefs.entrySet()) {
        AbstractBeanDefinition beanDef = entry.getValue();
        // If a @Configuration class gets proxied, always proxy the target class
        beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);
        // Set enhanced subclass of the user-specified bean class
        Class<?> configClass = beanDef.getBeanClass();
        Class<?> enhancedClass = enhancer.enhance(configClass, this.beanClassLoader);
        if (configClass != enhancedClass) {
            //################省略其他代码###################
            beanDef.setBeanClass(enhancedClass);
        }
    }
    enhanceConfigClasses.tag("classCount", () -> String.valueOf(configBeanDefs.keySet().size())).end();
}
```

enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory)方法主要是使用ConfigurationClassEnhancer对象的enhance()方法生成代理类，也就是使用CGLib生成代理类。

（8）解析ConfigurationClassEnhancer类的enhance(Class<?> configClass, ClassLoader classLoader)方法

```java
public Class<?> enhance(Class<?> configClass, @Nullable ClassLoader classLoader) {
    //###################省略其他代码###############
    Class<?> enhancedClass = createClass(newEnhancer(configClass, classLoader));
    //###################省略其他代码###############
    return enhancedClass;
}
```

enhance(Class<?> configClass, ClassLoader classLoader)方法中调用了createClass()方法创建代理类，在这之前先调用newEnhancer()方法实例化Enhancer对象。

（9）解析ConfigurationClassEnhancer类的newEnhancer(Class<?> configSuperClass, ClassLoader classLoader)方法

```java
private Enhancer newEnhancer(Class<?> configSuperClass, @Nullable ClassLoader classLoader) {
    Enhancer enhancer = new Enhancer();
    enhancer.setSuperclass(configSuperClass);
    enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class});
    enhancer.setUseFactory(false);
    enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
    enhancer.setAttemptLoad(true);
    enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader));
    enhancer.setCallbackFilter(CALLBACK_FILTER);
    enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());
    return enhancer;
}
```

newEnhancer()方法中主要是生成CGLib动态代理的Enhancer对象，后续会使用Enhancer对象生成代理类。

在newEnhancer()方法中为要生成的代理类设置了父类和接口，由于为要生成的代理类设置的接口为EnhancedConfiguration，同时，EnhancedConfiguration接口继承了BeanFactoryAware接口，所以，在后续生成的代理类中可以调用BeanFactoryAware接口的setBeanFactory(BeanFactory beanFactory)方法获取到beanFactory对象。

（10）解析ConfigurationClassEnhancer类的createClass(Enhancer enhancer)方法

```java
private Class<?> createClass(Enhancer enhancer) {
    Class<?> subclass = enhancer.createClass();
    Enhancer.registerStaticCallbacks(subclass, CALLBACKS);
    return subclass;
}
```

在createClass(Enhancer enhancer)方法中主要调用了enhancer对象的createClass()方法来创建代理类，这里创建出来的代理类就是目标类的子类。。

（11）解析CALLBACKS

```java
static final Callback[] CALLBACKS = new Callback[] {
    new BeanMethodInterceptor(),
    new BeanFactoryAwareMethodInterceptor(),
    NoOp.INSTANCE
};
```

CALLBACKS是一个Callback类型的数组，数组中的每个元素都是一个Callback类型的对象。其中，BeanMethodInterceptor类和BeanFactoryAwareMethodInterceptor类也是拦截器类型。接下来，以BeanMethodInterceptor类为例进行介绍。

（12）解析BeanMethodInterceptor类

BeanMethodInterceptor实现了MethodInterceptor接口和ConditionalCallback接口，主要的作用就是对标注了@Bean的注解的方法进行拦截，执行intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,  MethodProxy  cglibMethodProxy)方法，生成Bean的实例对象。

```java
public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,
					MethodProxy cglibMethodProxy) throws Throwable {
    //如果已经创建了Bean的代理实例对象，则调用父类的方法。
    if (isCurrentlyInvokedFactoryMethod(beanMethod)) {
        //#################省略其他代码###############
        return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs);
    }
    return resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName);   
}
```

上述代码能够保证在类上添加@Configuration注解后，只会为类生成一个代理对象。也就是上述代码的逻辑能够保证标注了@Configuration注解的类生成的代理类是单例模式的。

因为使用CGLib创建出来的代理类是目标类的子类，所以第一次执行上述代码片段时，会调用cglibMethodProxy的invokeSuper()方法执行父类的方法，也就是执行目标类的方法。第二次执行上述代码片段时，会调用resolveBeanReference()方法。

（13）解析BeanMethodInterceptor类的resolveBeanReference(Method beanMethod, Object[] beanMethodArgs,  ConfigurableBeanFactory beanFactory, String beanName)方法

```java
private Object resolveBeanReference(Method beanMethod, Object[] beanMethodArgs, ConfigurableBeanFactory beanFactory, String beanName) {
    //##############省略其他代码###############
    boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName);
    try {
        //##############省略其他代码###############
        Object beanInstance = (useArgs ? beanFactory.getBean(beanName, beanMethodArgs) :
                               beanFactory.getBean(beanName));
       //##############省略其他代码###############
        return beanInstance;
    }
    finally {
       //##############省略其他代码###############
    }
}
```

resolveBeanReference()方法中会通过beanFactory获取已经初始化好的Bean对象，并将这个已经初始化好的bean对象返回。并不会再进行第二次初始化的操作。所以在类上添加@Configuration注解后，Spring能够保证为类生成的代理类是单例的。

### 思考

#### 1. Spring为何在创建IOC容器时先注册ConfigurationClassPostProcessor类后置处理器的Bean定义信息，随后才是注册标注了@Configuration注解的ConfigurationAnnotationConfig配置类的Bean定义信息？

Spring在创建IOC容器时首先注册`ConfigurationClassPostProcessor`类后置处理器的Bean定义信息，是因为`ConfigurationClassPostProcessor`是Spring框架用于处理带有`@Configuration`注解的类的核心组件。它负责扫描和处理这些配置类，进而解析其中的`@Bean`方法和其他相关注解。将其先注册为Bean定义，是为了在容器后续的启动和初始化过程中，能够尽早地获取到这个处理器，并利用它来解析和注册其他配置类中的Bean定义。

这种设计确保了Spring在正式解析和注册其他Bean之前，已经准备好了处理配置类的机制，从而能够有序、高效地处理整个配置过程，保证配置类中的元信息被正确处理。。

#### 2. Spring为何先将类的Bean定义信息注册到IOC容器？为何不是直接注册实例化后的对象？

Spring先将类的Bean定义信息注册到IOC容器，而不是直接注册实例化后的对象，主要是因为这种方式提供了更高的灵活性和控制力。通过注册Bean定义（包括类的信息、构造方法、依赖关系等），Spring能够在需要的时候（通常是Bean被使用时）再创建Bean的实例。这种延迟初始化的策略有助于减少启动时的内存消耗和初始化时间，同时也可以通过配置来控制Bean的创建时机和生命周期。

此外，注册Bean定义还允许Spring在创建Bean实例时应用各种依赖注入（DI）和AOP（面向切面编程）特性，如自动装配、代理创建等，从而增强了Spring框架的功能。

#### 3. Spring为何是在刷新IOC容器时，实例化标注了@Configuration注解的配置类的代理对象？为何不是在创建IOC容器时就进行实例化？

Spring在刷新IOC容器时实例化标注了`@Configuration`注解的配置类的代理对象，而不是在创建IOC容器时就进行实例化，主要是出于两个考虑：

1. **延迟加载**：通过延迟实例化配置类的代理对象，Spring可以在需要时再进行加载，这有助于减少应用启动时的初始化时间和内存消耗。
2. **增强功能**：配置类的代理对象在Spring中扮演着特殊角色，它们不仅包含了配置类的逻辑，还通过代理机制提供了额外的功能，如增强`@Bean`方法的调用（以确保每个`@Bean`方法只被调用一次并返回相同的实例）。Spring可以支持诸如`@Bean`方法的拦截，从而实现诸如条件判断、生命周期管理等功能。这种增强功能需要在容器启动和Bean创建过程中进行，因此延迟到容器刷新时再进行实例化是合理的。



## 1.2 @ComponentScans与@ComponentScan注解

@ComponentScans注解可以看作是@ComponentScan注解的一个数组，在@ComponentScans注解中可以多次标注@ComponentScan注解。@ComponentScan注解最核心的功能就是Spring IOC容器在刷新的时候会扫描对应包下标注了@Component注解、@Configuration注解、@Repository注解、@Service注解和@Controller等等注解的类，生成扫描到的类的Bean定义信息，整体流程与注册ConfigurationClassPostProcessor类的Bean定义信息的流程基本一致，最终都会将其保存到BeanFactory中的beanDefinitionMap中。

### 注解源码

**@ComponentScans注解源码**

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
public @interface ComponentScans {
	ComponentScan[] value();
}
```

**@ComponentScan注解源码**

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Repeatable(ComponentScans.class)
public @interface ComponentScan {

	@AliasFor("basePackages")
	String[] value() default {};

	@AliasFor("value")
	String[] basePackages() default {};

	Class<?>[] basePackageClasses() default {};

	Class<? extends BeanNameGenerator> nameGenerator() default BeanNameGenerator.class;

	Class<? extends ScopeMetadataResolver> scopeResolver() default AnnotationScopeMetadataResolver.class;

	ScopedProxyMode scopedProxy() default ScopedProxyMode.DEFAULT;

	String resourcePattern() default ClassPathScanningCandidateComponentProvider.DEFAULT_RESOURCE_PATTERN;

	boolean useDefaultFilters() default true;

	Filter[] includeFilters() default {};

	Filter[] excludeFilters() default {};

	boolean lazyInit() default false;

	@Retention(RetentionPolicy.RUNTIME)
	@Target({})
	@interface Filter {

		FilterType type() default FilterType.ANNOTATION;

		@AliasFor("classes")
		Class<?>[] value() default {};

		@AliasFor("value")
		Class<?>[] classes() default {};

		String[] pattern() default {};

	}
}
```

@ComponentScan注解中的每个属性的含义如下所示。

* value：作用同basePackages属性，String[]数组类型，指定要扫描的包名。如果指定了要扫描的包名，则Spring会扫描指定的包及其子包下的所有类。
* basePackages：作用同value属性，String[]数组类型，指定要扫描的包名。如果指定了要扫描的包名，则Spring会扫描指定的包及其子包下的所有类。
* basePackageClasses：Class<?>[]数组类型，指定要扫描的类的Class对象。
* nameGenerator：Class<? extends BeanNameGenerator>类型，指定扫描类时，向IOC注入Bean对象时的命名规则。
* scopeResolver：Class<? extends ScopeMetadataResolver>类型，扫描类时，用于处理并转换符合条件的Bean的作用范围。
* scopedProxy：ScopedProxyMode类型，指定生成Bean对象时的代理方式，默认的代理方法是DEFAULT，也就是不使用代理。
* resourcePattern：String类型，用于指定扫描的文件类型，默认是扫描指定包下的`**/*.class`。
* useDefaultFilters：boolean类型，是否自动检测@Component @Repository @Service @Controller注解，默认是true。
* includeFilters：Filter[]数组类型，自定义组件扫描过滤规则，符合过滤规则的类的Bean定义信息会被注册到IOC容器中。includeFilters表示只包含对应的规则，当使用includeFilters()来指定只包含哪些注解标注的类时，需要禁用默认的过滤规则，也就是需要将useDefaultFilters属性设置为false。并且，除了符合过滤规则的类外，Spring内置的如下名称的类的Bean定义信息注册到IOC容器时不受过滤规则限制，如下所示。

```bash
org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
```

* excludeFilters：Filter[]数组类型，自定义组件扫描过滤规则，excludeFilters表示排除使用对应的规则，符合过滤规则的类的Bean定义信息不会被注册到IScopedProxyMode枚举类表示Spring指定生成Bean对象时的代理方式OC容器中。
* lazyInit：boolean类型，表示Spring扫描组件时是否采用懒加载 ，默认false，表示不开启懒加载。

@Filter注解中的每个属性的含义如下所示。

* type：FilterType类型，表示过滤规则的类型。
* value：Class<?>[]数组类型，过滤符合规则的类，作用同classes属性。
* classes：Class<?>[]数组类型，过滤符合规则的类，作用同value属性。
* pattern：如果FilterType取值为ASPECTJ，则此属性表示ASPECTJ表达式。

ScopedProxyMode枚举类表示Spring指定生成Bean对象时的代理方式：

```java
public enum ScopedProxyMode {
	DEFAULT,
	NO,
	INTERFACES,
	TARGET_CLASS
}
```

ScopedProxyMode类每个属性的含义：

* DEFAULT：默认的代理方式，也就是不使用代理，除非在component-scan级别使用了不同的配置。
* NO：不使用代理。
* INTERFACES：基于JDK动态代理实现接口代理对象。
* TARGET_CLASS：基于CGLib动态代理创建类代理对象。

FilterType枚举类表示Spring扫描类时的过滤类型：

```java
public enum FilterType {
	ANNOTATION,
	ASSIGNABLE_TYPE,
	ASPECTJ,
	REGEX,
	CUSTOM
}
```

FilterType类每个属性的含义：

* ANNOTATION：按照注解进行过滤。
* ASSIGNABLE_TYPE：按照给定的类型进行过滤。
* ASPECTJ：按照ASPECTJ表达式进行过滤。
* REGEX：按照正则表达式进行过滤。
* CUSTOM：按照自定义规则进行过滤，使用自定义过滤规则时，自定义的过滤器需要实现org.springframework.core.type.filter.TypeFilter接口。

### 源码时序图

![图2-1](https://upload.yolo912.icu/mdImage/spring-core-2022-12-16-002.png)

![图2-2](https://upload.yolo912.icu/mdImage/spring-core-2022-12-16-003.png)

![图2-3](https://upload.yolo912.icu/mdImage/spring-core-2022-12-16-004.png)

### 源码解析

（1）运行ComponentScanTest类的main()方法。

```java
public static void main(String[] args) {
    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ComponentScanConfig.class);
    String[] names = context.getBeanDefinitionNames();
    Arrays.stream(names).forEach(System.out::println);
}
```

（2）解析AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext(Class<?>... componentClasses)构造方法

```java
public AnnotationConfigApplicationContext(Class<?>... componentClasses) {
    this();
    register(componentClasses);
    refresh();
}
```

（3）解析AbstractApplicationContext类的refresh()方法

```java
@Override
public void refresh() throws BeansException, IllegalStateException {
    synchronized (this.startupShutdownMonitor) {
        //############省略其他代码##############
        try {
            //############省略其他代码##############
            invokeBeanFactoryPostProcessors(beanFactory);
           //############省略其他代码##############
        }catch (BeansException ex) {
            //############省略其他代码##############
        }finally {
            //############省略其他代码##############
        }
    }
}
```

（4）解析AbstractApplicationContext类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory)方法

```java
protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
    if (!NativeDetector.inNativeImage() && beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
        beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
        beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
    }
}
```

（5）解析PostProcessorRegistrationDelegate类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors)方法

```java
public static void invokeBeanFactoryPostProcessors(
    ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {

    //############省略其他代码##############
    List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();

    // 首先，调用实现PriorityOrdered接口的BeanDefinitionRegistryPostProcessor
    String[] postProcessorNames =
        beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
    for (String ppName : postProcessorNames) {
        if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
        }
    }
    sortPostProcessors(currentRegistryProcessors, beanFactory);
    registryProcessors.addAll(currentRegistryProcessors);
    invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());
    currentRegistryProcessors.clear();

    // 接着，调用实现Ordered接口的BeanDefinitionRegistryPostProcessor
    postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
    for (String ppName : postProcessorNames) {
        if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
        }
    }
    sortPostProcessors(currentRegistryProcessors, beanFactory);
    registryProcessors.addAll(currentRegistryProcessors);
    invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());
    currentRegistryProcessors.clear();

    // 最后，循环调用其他BeanDefinitionRegistryPostProcessor，直到没有新的出现
    boolean reiterate = true;
    while (reiterate) {
        reiterate = false;
        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
        for (String ppName : postProcessorNames) {
            if (!processedBeans.contains(ppName)) {
                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                processedBeans.add(ppName);
                reiterate = true;
            }
        }
        sortPostProcessors(currentRegistryProcessors, beanFactory);
        registryProcessors.addAll(currentRegistryProcessors);
        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());
        currentRegistryProcessors.clear();
    }
    //############省略其他代码##############
}
```

BeanDefinitionRegistryPostProcessor的实现类在执行逻辑上会有先后顺序，并且最终都会调用invokeBeanDefinitionRegistryPostProcessors()方法。

（6）解析PostProcessorRegistrationDelegate类的invokeBeanDefinitionRegistryPostProcessors(Collection<? extends BeanDefinitionRegistryPostProcessor> postProcessors, BeanDefinitionRegistry registry, ApplicationStartup applicationStartup)方法

```java
private static void invokeBeanDefinitionRegistryPostProcessors(
    Collection<? extends BeanDefinitionRegistryPostProcessor> postProcessors, BeanDefinitionRegistry registry, ApplicationStartup applicationStartup) {

    for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {
        // 启动一个名为 "spring.context.beandef-registry.post-process" 的启动步骤，并为其添加一个标签 "postProcessor"，标签的值为 postProcessor 的字符串表示形式
        StartupStep postProcessBeanDefRegistry = applicationStartup.start("spring.context.beandef-registry.post-process")
            .tag("postProcessor", postProcessor::toString);
        // 调用 postProcessor 的 postProcessBeanDefinitionRegistry 方法，对 BeanDefinitionRegistry 注册Bean的定义信息
        postProcessor.postProcessBeanDefinitionRegistry(registry);
        // 结束启动步骤
        postProcessBeanDefRegistry.end();
    }
}
```

在invokeBeanDefinitionRegistryPostProcessors()方法中，会循环遍历postProcessors集合中的每个元素，调用postProcessBeanDefinitionRegistry()方法注册Bean的定义信息。

（7）解析ConfigurationClassPostProcessor类的postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)方法

```java
@Override
public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
	//##########省略其他代码###################
    processConfigBeanDefinitions(registry);
}
```

（8）解析ConfigurationClassPostProcessor类的processConfigBeanDefinitions(BeanDefinitionRegistry registry)方法

```java
public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
    //############省略其他代码#################
    // Parse each @Configuration class
    ConfigurationClassParser parser = new ConfigurationClassParser(
        this.metadataReaderFactory, this.problemReporter, this.environment,
        this.resourceLoader, this.componentScanBeanNameGenerator, registry);

    // 存储待解析的 Bean 定义持有者
    Set<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);
    // 存储已经解析过的配置类
    Set<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());
    do {
        // 启动一个名为 "spring.context.config-classes.parse" 的启动步骤
        StartupStep processConfig = this.applicationStartup.start("spring.context.config-classes.parse");
        // 解析配置类
        parser.parse(candidates);
        // 验证配置类
        parser.validate();
        // 获取解析后的配置类集合
        Set<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());
        // 移除已经解析过的配置类
        configClasses.removeAll(alreadyParsed);

        // 根据模型内容读取并创建 Bean 定义
        // Read the model and create bean definitions based on its content
        if (this.reader == null) {
            // 初始化 Bean 定义读取器
            this.reader = new ConfigurationClassBeanDefinitionReader(
                registry, this.sourceExtractor, this.resourceLoader, this.environment,
                this.importBeanNameGenerator, parser.getImportRegistry());
        }
        // 加载 Bean 定义
        this.reader.loadBeanDefinitions(configClasses);
        // 将已解析的配置类添加到已解析集合中
        alreadyParsed.addAll(configClasses);
        // 结束启动步骤，并标记解析的配置类数量
        processConfig.tag("classCount", () -> String.valueOf(configClasses.size())).end();

        // 清空待解析的 Bean 定义持有者集合
        candidates.clear();
        // 如果当前注册的 Bean 定义数量大于候选名称的数量
        if (registry.getBeanDefinitionCount() > candidateNames.length) {
            // 获取当前所有注册的 Bean 名称
            String[] newCandidateNames = registry.getBeanDefinitionNames();
            // 将候选名称转换为集合
            Set<String> oldCandidateNames = Set.of(candidateNames);
            // 存储已经解析过的配置类名称
            Set<String> alreadyParsedClasses = new HashSet<>();
            // 遍历已解析的配置类
            for (ConfigurationClass configurationClass : alreadyParsed) {
                // 添加配置类名称到已解析集合中
                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
            }
            // 遍历新的候选名称
            for (String candidateName : newCandidateNames) {
                // 如果旧的候选名称集合中不包含当前候选名称
                if (!oldCandidateNames.contains(candidateName)) {
                    // 获取 Bean 定义
                    BeanDefinition bd = registry.getBeanDefinition(candidateName);
                    // 判断 Bean 定义是否是配置类候选
                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &&
                        // 并且配置类名称不在已解析集合中
                        !alreadyParsedClasses.contains(bd.getBeanClassName())) {
                        // 将新的 Bean 定义持有者添加到待解析集合中
                        candidates.add(new BeanDefinitionHolder(bd, candidateName));
                    }
                }
            }
            // 更新候选名称数组
            candidateNames = newCandidateNames;
        }
    }
    // 循环直到待解析集合为空
    while (!candidates.isEmpty());
    //############省略其他代码#################
}
```

在processConfigBeanDefinitions()方法中，创建了一个ConfigurationClassParser类型的对象parser，并且调用了parser的parse()方法来解析类的配置信息。

（9）解析ConfigurationClassParser类的parse(Set<BeanDefinitionHolder> configCandidates)方法

```java
public void parse(Set<BeanDefinitionHolder> configCandidates) {
    for (BeanDefinitionHolder holder : configCandidates) {
        BeanDefinition bd = holder.getBeanDefinition();
        try {
            if (bd instanceof AnnotatedBeanDefinition) {
                // 如果 BeanDefinition 是 AnnotatedBeanDefinition 类型
                parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
            }
            else if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {
                // 如果 BeanDefinition 是 AbstractBeanDefinition 类型，并且存在 BeanClass
                parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());
            }
            else {
                // 其他情况
                parse(bd.getBeanClassName(), holder.getBeanName());
            }
        }
        catch (BeanDefinitionStoreException ex) {
            // 如果发生 BeanDefinitionStoreException 异常，则直接抛出
            throw ex;
        }
        catch (Throwable ex) {
            // 如果发生其他异常，则包装为 BeanDefinitionStoreException 异常并抛出
            throw new BeanDefinitionStoreException(
                "Failed to parse configuration class [" + bd.getBeanClassName() + "]", ex);
        }
    }
    this.deferredImportSelectorHandler.process();
}
```

（10）解析ConfigurationClassParser类的parse(AnnotationMetadata metadata, String beanName)方法

```java
protected final void parse(AnnotationMetadata metadata, String beanName) throws IOException {
    processConfigurationClass(new ConfigurationClass(metadata, beanName), DEFAULT_EXCLUSION_FILTER);
}
```

（11）解析ConfigurationClassParser类的processConfigurationClass(ConfigurationClass configClass, Predicate<String> filter)方法

```java
protected void processConfigurationClass(ConfigurationClass configClass, Predicate<String> filter) throws IOException {
    //###############省略其他代码####################
    // 递归处理配置类及其超类层次结构
    SourceClass sourceClass = asSourceClass(configClass, filter);
    do {
        // 处理配置类
        sourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);
    }
    while (sourceClass != null);
    // 将配置类放入配置类集合中
    this.configurationClasses.put(configClass, configClass);
}
```

在processConfigurationClass()方法中，会通过do-while()循环获取配置类和其父类的注解信息，SourceClass类中会封装配置类上注解的详细信息。

（12）解析ConfigurationClassParser类的doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)方法

```java
protected final SourceClass doProcessConfigurationClass(
    ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)
    throws IOException {
    //##############省略其他代码################
    // 处理任何@ComponentScan注解
    // Process any @ComponentScan annotations
    Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(
        sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
    if (!componentScans.isEmpty() &&
        !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
        for (AnnotationAttributes componentScan : componentScans) {
            // 如果配置类被注解为@ComponentScan -> 立即执行扫描
            // The config class is annotated with @ComponentScan -> perform the scan immediately
            Set<BeanDefinitionHolder> scannedBeanDefinitions =
                this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
            // 检查扫描到的定义集合中是否有其他配置类，如果需要则递归解析
            // Check the set of scanned definitions for any further config classes and parse recursively if needed
            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
                BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
                if (bdCand == null) {
                    bdCand = holder.getBeanDefinition();
                }
                if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
                    // 解析配置类
                    parse(bdCand.getBeanClassName(), holder.getBeanName());
                }
            }
        }
    }
  	//##############省略其他代码################
    // No superclass -> processing is complete
    return null;
}
```

在上述处理@ComponentScan注解的逻辑中，通过componentScanParser的parse()方法对@ComponentScan注解进行解析。

（13）解析ComponentScanAnnotationParser类的parse(AnnotationAttributes componentScan, String declaringClass)方法

```java
public Set<BeanDefinitionHolder> parse(AnnotationAttributes componentScan, String declaringClass) {
    // 创建ClassPathBeanDefinitionScanner实例
    ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry,
                                                                                componentScan.getBoolean("useDefaultFilters"), this.environment, this.resourceLoader);
    // 获取BeanNameGenerator类的Class对象
    Class<? extends BeanNameGenerator> generatorClass = componentScan.getClass("nameGenerator");
    // 判断是否使用继承的BeanNameGenerator
    boolean useInheritedGenerator = (BeanNameGenerator.class == generatorClass);
    // 设置BeanNameGenerator
    scanner.setBeanNameGenerator(useInheritedGenerator ? this.beanNameGenerator :
                                 BeanUtils.instantiateClass(generatorClass));
    // 获取ScopedProxyMode枚举值
    ScopedProxyMode scopedProxyMode = componentScan.getEnum("scopedProxy");
    if (scopedProxyMode != ScopedProxyMode.DEFAULT) {
        // 设置ScopedProxyMode
        scanner.setScopedProxyMode(scopedProxyMode);
    }
    else {
        // 获取ScopeMetadataResolver类的Class对象
        Class<? extends ScopeMetadataResolver> resolverClass = componentScan.getClass("scopeResolver");
        // 设置ScopeMetadataResolver
        scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));
    }
    // 设置资源匹配模式
    scanner.setResourcePattern(componentScan.getString("resourcePattern"));
    // 遍历includeFilters
    for (AnnotationAttributes includeFilterAttributes : componentScan.getAnnotationArray("includeFilters")) 	{
        // 创建TypeFilter列表
        List<TypeFilter> typeFilters = TypeFilterUtils.createTypeFiltersFor(includeFilterAttributes, this.environment,
                                                                            this.resourceLoader, this.registry);
        // 遍历TypeFilter列表，并添加到scanner中
        for (TypeFilter typeFilter : typeFilters) {
            scanner.addIncludeFilter(typeFilter);
        }
    }
    // 遍历excludeFilters
    for (AnnotationAttributes excludeFilterAttributes : componentScan.getAnnotationArray("excludeFilters")) 	{
        // 创建TypeFilter列表
        List<TypeFilter> typeFilters = TypeFilterUtils.createTypeFiltersFor(excludeFilterAttributes, this.environment,
                                                                            this.resourceLoader, this.registry);
        // 遍历TypeFilter列表，并添加到scanner中
        for (TypeFilter typeFilter : typeFilters) {
            scanner.addExcludeFilter(typeFilter);
        }
    }

    // 获取lazyInit的值
    boolean lazyInit = componentScan.getBoolean("lazyInit");
    if (lazyInit) {
        // 设置Bean定义默认的懒加载属性
        scanner.getBeanDefinitionDefaults().setLazyInit(true);
    }

    // 创建basePackages集合
    Set<String> basePackages = new LinkedHashSet<>();
    // 获取basePackages数组
    String[] basePackagesArray = componentScan.getStringArray("basePackages");
    // 遍历basePackages数组
    for (String pkg : basePackagesArray) {
        // 解析并添加包名到basePackages集合中
        String[] tokenized = StringUtils.tokenizeToStringArray(this.environment.resolvePlaceholders(pkg),
                                                               ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);
        Collections.addAll(basePackages, tokenized);
    }
    // 遍历basePackageClasses数组
    for (Class<?> clazz : componentScan.getClassArray("basePackageClasses")) {
        // 获取包名并添加到basePackages集合中
        basePackages.add(ClassUtils.getPackageName(clazz));
    }
    // 如果basePackages集合为空，则添加声明类的包名到集合中
    if (basePackages.isEmpty()) {
        basePackages.add(ClassUtils.getPackageName(declaringClass));
    }

    // 添加自定义的excludeFilter
    scanner.addExcludeFilter(new AbstractTypeHierarchyTraversingFilter(false, false) {
        @Override
        protected boolean matchClassName(String className) {
            // 判断是否为声明类的类名
            return declaringClass.equals(className);
        }
    });
		// 执行扫描并返回结果
    return scanner.doScan(StringUtils.toStringArray(basePackages));
}
```

在parse()方法中，会创建一个ClassPathBeanDefinitionScanner类型的扫描器scanner，将@ComponentScan注解上配置的信息都设置到扫描器scanner中，最后调用扫描器scanner的doScan()方法进行扫描。

（14）解析ClassPathBeanDefinitionScanner类的doScan(String... basePackages)方法

```java
protected Set<BeanDefinitionHolder> doScan(String... basePackages) {
    // 断言basePackages不为空，至少指定一个基础包
    Assert.notEmpty(basePackages, "At least one base package must be specified");
    Set<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<>();
    for (String basePackage : basePackages) {
        // 在基础包中查找候选组件
        Set<BeanDefinition> candidates = findCandidateComponents(basePackage);
        for (BeanDefinition candidate : candidates) {
            // 解析候选组件的作用域元数据
            ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
            // 设置候选组件的作用域
            candidate.setScope(scopeMetadata.getScopeName());
            // 生成候选组件的Bean名称
            String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
            // 如果候选组件是AbstractBeanDefinition类型
            if (candidate instanceof AbstractBeanDefinition) {
                // 对候选组件进行后处理
                postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
            }
            // 如果候选组件是AnnotatedBeanDefinition类型
            if (candidate instanceof AnnotatedBeanDefinition) {
                // 处理候选组件的通用定义注解
                AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
            }
            // 检查候选组件是否满足条件
            if (checkCandidate(beanName, candidate)) {
                // 创建BeanDefinitionHolder对象
                BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
                // 应用作用域代理模式
                definitionHolder =
                    AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
                // 将BeanDefinitionHolder添加到beanDefinitions集合中
                beanDefinitions.add(definitionHolder);
                // 注册BeanDefinitionHolder到注册中心
                registerBeanDefinition(definitionHolder, this.registry);
            }
        }
    }
    // 返回beanDefinitions集合
    return beanDefinitions;
}
```

在doScan()方法中，会遍历传入的每个包路径，调用findCandidateComponents()方法来扫描带有注解（例如@Component注解）的类。

（15）解析ClassPathScanningCandidateComponentProvider类的findCandidateComponents(String basePackage)方法

```java
public Set<BeanDefinition> findCandidateComponents(String basePackage) {
    // 如果组件索引不为空，并且索引支持包含过滤器
    if (this.componentsIndex != null && indexSupportsIncludeFilters()) {
        // 从索引中添加候选组件
        return addCandidateComponentsFromIndex(this.componentsIndex, basePackage);
    }
    else {
        // 扫描候选组件
        return scanCandidateComponents(basePackage);
    }
}
```

（16）解析ClassPathScanningCandidateComponentProvider类的scanCandidateComponents(String basePackage)方法

```java
private Set<BeanDefinition> scanCandidateComponents(String basePackage) {
    Set<BeanDefinition> candidates = new LinkedHashSet<>();
    try {
        String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +
            resolveBasePackage(basePackage) + '/' + this.resourcePattern;
        Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);
        boolean traceEnabled = logger.isTraceEnabled();
        boolean debugEnabled = logger.isDebugEnabled();
        for (Resource resource : resources) {
            String filename = resource.getFilename();
            if (filename != null && filename.contains(ClassUtils.CGLIB_CLASS_SEPARATOR)) {
                // 忽略classpath中CGLIB生成的类
                // Ignore CGLIB-generated classes in the classpath
                continue;
            }
            if (traceEnabled) {
                // 跟踪日志，扫描资源
                logger.trace("Scanning " + resource);
            }
            try {
                // 获取资源的元数据读取器
                MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);
                // 判断是否为候选组件
                if (isCandidateComponent(metadataReader)) {
                    // 创建扫描到的泛型Bean定义
                    ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
                    // 设置资源来源
                    sbd.setSource(resource);
                    // 再次判断是否为候选组件
                    if (isCandidateComponent(sbd)) {
                        if (debugEnabled) {
                            // 调试日志，识别候选组件类
                            logger.debug("Identified candidate component class: " + resource);
                        }
                        // 将候选组件添加到候选集合中
                        candidates.add(sbd);
                    }
                    else {
                        if (debugEnabled) {
                            // 调试日志，忽略非具体的顶层类
                            logger.debug("Ignored because not a concrete top-level class: " + resource);
                        }
                    }
                }
                else {
                    if (traceEnabled) {
                        // 跟踪日志，忽略不符合任何过滤器的资源
                        logger.trace("Ignored because not matching any filter: " + resource);
                    }
                }
            }
            catch (FileNotFoundException ex) {
                if (traceEnabled) {
                    // 跟踪日志，忽略不可读资源
                    logger.trace("Ignored non-readable " + resource + ": " + ex.getMessage());
                }
            }
            catch (Throwable ex) {
                throw new BeanDefinitionStoreException(
                    // 抛出Bean定义存储异常，读取候选组件类失败
                    "Failed to read candidate component class: " + resource, ex);
            }
        }
    catch (IOException ex) {
        throw new BeanDefinitionStoreException("I/O failure during classpath scanning", ex);
    }
    return candidates;
}
```

在scanCandidateComponents()方法中，会调用isCandidateComponent()方法来判断当前注解是不是要扫描的注解。

（17）解析ClassPathScanningCandidateComponentProvider类的isCandidateComponent(MetadataReader metadataReader)方法

```java
protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException {
    // 遍历排除过滤器列表
    for (TypeFilter tf : this.excludeFilters) {
        // 如果当前过滤器匹配给定的元数据读取器
        if (tf.match(metadataReader, getMetadataReaderFactory())) {
            // 返回false，表示不是候选组件
            return false;
        }
    }
    // 遍历包含过滤器列表
    for (TypeFilter tf : this.includeFilters) {
        // 如果当前过滤器匹配给定的元数据读取器
        if (tf.match(metadataReader, getMetadataReaderFactory())) {
            // 调用isConditionMatch方法判断条件是否匹配
            return isConditionMatch(metadataReader);
        }
    }
    // 如果都不匹配，则返回false，表示不是候选组件
    return false;
}
```

isCandidateComponent()方法的逻辑还是比较简单的，就是遍历匹配excludeFilters和includeFilters指定的规则。

优先匹配excludeFilters指定的规则，如果匹配excludeFilters指定的规则，直接返回false。接下来，匹配includeFilters指定的规则，匹配成功，则调用isConditionMatch()方法进行条件匹配。

其中，对于includeFilters而言，默认的过滤规则如下所示。

```java
protected void registerDefaultFilters() {
    this.includeFilters.add(new AnnotationTypeFilter(Component.class));
    ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();
    try {
        this.includeFilters.add(new AnnotationTypeFilter(
            ((Class<? extends Annotation>) ClassUtils.forName("jakarta.annotation.ManagedBean", cl)), false));
        logger.trace("JSR-250 'jakarta.annotation.ManagedBean' found and supported for component scanning");
    }
    catch (ClassNotFoundException ex) {
        // JSR-250 1.1 API (as included in Jakarta EE) not available - simply skip.
    }
    try {
        this.includeFilters.add(new AnnotationTypeFilter(
            ((Class<? extends Annotation>) ClassUtils.forName("jakarta.inject.Named", cl)), false));
        logger.trace("JSR-330 'jakarta.inject.Named' annotation found and supported for component scanning");
    }
    catch (ClassNotFoundException ex) {
        // JSR-330 API not available - simply skip.
    }
}
```

对于includeFilters而言，默认的过滤规则会匹配@Component注解，JSR-250中的注解和JSR-330中的注解。

（18）回到ClassPathScanningCandidateComponentProvider类的scanCandidateComponents(String basePackage)方法

在ClassPathScanningCandidateComponentProvider类的scanCandidateComponents(String basePackage)方法中，会将标注了@Component注解，JSR-250中的注解和JSR-330中的注解的类信息封装成ScannedGenericBeanDefinition类对象，也就是类的Bean定义信息。

ScannedGenericBeanDefinition类的构造方法如下所示。

```java
public ScannedGenericBeanDefinition(MetadataReader metadataReader) {
    Assert.notNull(metadataReader, "MetadataReader must not be null");
    this.metadata = metadataReader.getAnnotationMetadata();
    setBeanClassName(this.metadata.getClassName());
    setResource(metadataReader.getResource());
}
```

（19）回到ClassPathBeanDefinitionScanner类的doScan(String... basePackages)方法

在ClassPathBeanDefinitionScanner类的doScan(String... basePackages)方法中，会将扫描到的类的Bean定义信息注册到IOC容器中，如下代码片段所示。

```java
if (checkCandidate(beanName, candidate)) {
    BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
    definitionHolder =
        AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
    beanDefinitions.add(definitionHolder);
    registerBeanDefinition(definitionHolder, this.registry);
}
```

在doScan()方法中，会调用registerBeanDefinition()注册Bean定义信息。

（20）解析ClassPathBeanDefinitionScanner类的registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)方法

```java
protected void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) {
    BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry);
}
```

在方法中直接调用了BeanDefinitionReaderUtils类的registerBeanDefinition()方法。

（21）解析BeanDefinitionReaderUtils类的registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)方法。

```java
public static void registerBeanDefinition(
    BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
    throws BeanDefinitionStoreException {

    // Register bean definition under primary name.
    String beanName = definitionHolder.getBeanName();
    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
	//###########省略其他代码###################
}
```

在上述代码中，会继续调用BeanDefinitionRegistry类型的对象registry的registerBeanDefinition()方法，将类的Bean定义信息注册到IOC容器。

（22）解析DefaultListableBeanFactory类的registerBeanDefinition(String beanName, BeanDefinition beanDefinition)方法

```java
@Override
public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
    throws BeanDefinitionStoreException {
	//##############省略其他代码#################
    BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
    if (existingDefinition != null) {
        //##############省略其他代码#################
        this.beanDefinitionMap.put(beanName, beanDefinition);
    }
    else {
        //##############省略其他代码#################
        if (hasBeanCreationStarted()) {
            // Cannot modify startup-time collection elements anymore (for stable iteration)
            synchronized (this.beanDefinitionMap) {
                this.beanDefinitionMap.put(beanName, beanDefinition);
                List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);
                updatedDefinitions.addAll(this.beanDefinitionNames);
                updatedDefinitions.add(beanName);
                this.beanDefinitionNames = updatedDefinitions;
                removeManualSingletonName(beanName);
            }
        }
        else {
            // Still in startup registration phase
            this.beanDefinitionMap.put(beanName, beanDefinition);
            this.beanDefinitionNames.add(beanName);
            removeManualSingletonName(beanName);
        }
        this.frozenBeanDefinitionNames = null;
    }
    if (existingDefinition != null || containsSingleton(beanName)) {
        resetBeanDefinition(beanName);
    }
    else if (isConfigurationFrozen()) {
        clearByTypeCache();
    }
}
```

Spring会将扫描到的标注了符合过滤规则的注解的类封装成对应的Bean定义信息，最终会将这些Bean定义信息注册到beanDefinitionMap中。

### 思考

#### 1.Spring扫描指定包的逻辑为何复杂？

Spring扫描指定包的逻辑之所以看起来复杂，主要是因为其设计需要兼顾灵活性、可扩展性和性能。Spring的组件扫描（Component Scanning）机制允许开发者通过注解（如`@Component`、`@Service`、`@Repository`等）自动注册bean到Spring的IoC容器中，而无需显式地在XML配置文件中声明每一个bean。为了实现这一功能，Spring需要：

1. **灵活性**：允许开发者自定义扫描的包路径、过滤规则等，以适应不同的项目结构和需求。
2. **可扩展性**：通过提供TypeFilter接口等机制，允许开发者自定义过滤逻辑，以排除或包含特定的类。
3. **性能**：在大型项目中，可能需要扫描成百上千个类，Spring的扫描机制需要优化以减少扫描时间和内存消耗。

为了实现这些目标，Spring的组件扫描逻辑需要处理多种情况，包括但不限于：处理类路径资源、解析注解、应用过滤规则、注册bean定义等。

#### 2.配置类上不标注@ComponentScans或@ComponentScan能扫描到哪些包下的类？

如果在Spring Boot的配置类（通常是带有`@Configuration`注解的类）上不标注`@ComponentScans`或`@ComponentScan`注解，Spring Boot会采用默认行为。具体来说，Spring Boot会从主应用类（带有`@SpringBootApplication`注解的类）所在的包开始，扫描这个包及其子包下的所有类。这意味着，只要你的`@Component`注解的类位于主应用类所在的包或其子包下，它们就会被自动扫描并注册到IoC容器中。

#### 3.@ComponentScan注解中的basePackages或value属性可以设置任意包名吗？

是的，`@ComponentScan`注解中的`basePackages`或`value`属性可以设置任意包名（前提是这些包在类路径上确实存在）。这些属性用于指定Spring应该扫描哪些包以查找带有`@Component`、`@Service`、`@Repository`等注解的类。如果指定的包不存在于应用的类路径中，Spring在启动时会抛出异常，提示找不到指定的包。

因此，当使用`@ComponentScan`注解时，务必确保指定的包是真实存在的，并且包含了你想要自动注册为Spring bean的类。如果希望从多个不同的包中扫描组件，可以使用`@ComponentScans`注解，并在其中指定多个`@ComponentScan`。



## 1.3 @Bean注解

@Bean注解可以标注到方法上，将当前方法的返回值注入到IOC容器中。@Bean注解也可以标注到注解上，作为元注解使用。

### 注解源码

```java
@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Bean {
	//Since: 4.3.3
	@AliasFor("name")
	String[] value() default {};

	@AliasFor("value")
	String[] name() default {};
	
    //Since: 5.1
	boolean autowireCandidate() default true;

	String initMethod() default "";

	String destroyMethod() default AbstractBeanDefinition.INFER_METHOD;
}
```

注解中各个属性的含义如下所示。

* name：String[]数组类型，指定注入到IOC容器中的Bean的名称，可以指定多个名称。如果不指定name属性和value属性的值，则注入到IOC容器中的Bean的名称默认是方法的名称。
* value：String[]数组类型，作用与name属性相同。
* autowireCandidate：boolean类型，表示是否支持自动按照类型注入到其他的Bean中。此属性会影响@Autowired注解，不会响应@Resource注解，默认为true，表示支持自动按照类型注入到其他的Bean中。
* initMethod：指定初始化的方法。
* destroyMethod：指定销毁的方法。

### 源码时序图

#### 注册Bean的流程

![图3-1](https://upload.yolo912.icu/mdImage/spring-core-2022-12-21-001.png)

![图3-2](https://upload.yolo912.icu/mdImage/spring-core-2022-12-21-002.png)

#### 调用初始化方法

![图3-3](https://upload.yolo912.icu/mdImage/spring-core-2022-12-21-003.png)

![图3-4](https://upload.yolo912.icu/mdImage/spring-core-2022-12-21-004.png)

#### 调用销毁方法

![图3-5](https://upload.yolo912.icu/mdImage/spring-core-2022-12-21-005.png)

### 源码解析

#### 注册bean的流程

（1）运行BeanTest类的main()方法。

在BeanTest类的main()方法中调用了AnnotationConfigApplicationContext类的构造方法，并传入了ComponentScanConfig类的Class对象来创建IOC容器。接下来，会进入AnnotationConfigApplicationContext类的构造方法。

（2）解析AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext(Class<?>... componentClasses)构造方法

```java
public AnnotationConfigApplicationContext(Class<?>... componentClasses) {
    this();
    register(componentClasses);
    refresh();
}
```

（3）解析AbstractApplicationContext类的refresh()方法

```java
@Override
public void refresh() throws BeansException, IllegalStateException {
    synchronized (this.startupShutdownMonitor) {
        //############省略其他代码##############
        try {
            //############省略其他代码##############
            invokeBeanFactoryPostProcessors(beanFactory);
           //############省略其他代码##############
        }catch (BeansException ex) {
            //############省略其他代码##############
        }finally {
            //############省略其他代码##############
        }
    }
}
```

（4）解析AbstractApplicationContext类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory)方法

```java
protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
    if (!NativeDetector.inNativeImage() && beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
        beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
        beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
    }
}
```

（5）解析PostProcessorRegistrationDelegate类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors)方法

```java
public static void invokeBeanFactoryPostProcessors(
    ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {

    //############省略其他代码##############
    List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();

    // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
    String[] postProcessorNames =
        beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
    for (String ppName : postProcessorNames) {
        if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
        }
    }
    sortPostProcessors(currentRegistryProcessors, beanFactory);
    registryProcessors.addAll(currentRegistryProcessors);
    invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());
    currentRegistryProcessors.clear();

    // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
    postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
    for (String ppName : postProcessorNames) {
        if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
        }
    }
    sortPostProcessors(currentRegistryProcessors, beanFactory);
    registryProcessors.addAll(currentRegistryProcessors);
    invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());
    currentRegistryProcessors.clear();

    // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
    boolean reiterate = true;
    while (reiterate) {
        reiterate = false;
        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
        for (String ppName : postProcessorNames) {
            if (!processedBeans.contains(ppName)) {
                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                processedBeans.add(ppName);
                reiterate = true;
            }
        }
        sortPostProcessors(currentRegistryProcessors, beanFactory);
        registryProcessors.addAll(currentRegistryProcessors);
        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());
        currentRegistryProcessors.clear();
    }
    //############省略其他代码##############
}
```

在PostProcessorRegistrationDelegate类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors)方法中，BeanDefinitionRegistryPostProcessor的实现类在执行逻辑上会有先后顺序，并且最终都会调用invokeBeanDefinitionRegistryPostProcessors()方法。

（6）解析PostProcessorRegistrationDelegate类的invokeBeanDefinitionRegistryPostProcessors(Collection<? extends BeanDefinitionRegistryPostProcessor> postProcessors, BeanDefinitionRegistry registry, ApplicationStartup applicationStartup)方法

```java
private static void invokeBeanDefinitionRegistryPostProcessors(
    Collection<? extends BeanDefinitionRegistryPostProcessor> postProcessors, BeanDefinitionRegistry registry, ApplicationStartup applicationStartup) {

    for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {
        StartupStep postProcessBeanDefRegistry = applicationStartup.start("spring.context.beandef-registry.post-process")
            .tag("postProcessor", postProcessor::toString);
        postProcessor.postProcessBeanDefinitionRegistry(registry);
        postProcessBeanDefRegistry.end();
    }
}
```

在invokeBeanDefinitionRegistryPostProcessors()方法中，会循环遍历postProcessors集合中的每个元素，调用postProcessBeanDefinitionRegistry()方法注册Bean的定义信息。

（7）解析ConfigurationClassPostProcessor类的postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)方法

```java
@Override
public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
	//##########省略其他代码###################
    processConfigBeanDefinitions(registry);
}
```

在postProcessBeanDefinitionRegistry()方法中，会调用processConfigBeanDefinitions()方法。

（8）解析ConfigurationClassPostProcessor类的processConfigBeanDefinitions(BeanDefinitionRegistry registry)方法

```java
public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
    //############省略其他代码#################
    // Parse each @Configuration class
    ConfigurationClassParser parser = new ConfigurationClassParser(
        this.metadataReaderFactory, this.problemReporter, this.environment,
        this.resourceLoader, this.componentScanBeanNameGenerator, registry);
    
    Set<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);
    Set<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());
    do {
        StartupStep processConfig = this.applicationStartup.start("spring.context.config-classes.parse");
        parser.parse(candidates);
        parser.validate();
        //############省略其他代码#################
        this.reader.loadBeanDefinitions(configClasses);
        alreadyParsed.addAll(configClasses);
        processConfig.tag("classCount", () -> String.valueOf(configClasses.size())).end();
        //############省略其他代码#################
    }
    while (!candidates.isEmpty());
    //############省略其他代码#################
}
```

在processConfigBeanDefinitions()方法中，创建了一个ConfigurationClassParser类型的对象parser，并且调用了parser的parse()方法来解析类的配置信息。

（9）解析ConfigurationClassParser类的parse(Set<BeanDefinitionHolder> configCandidates)方法

```java
public void parse(Set<BeanDefinitionHolder> configCandidates) {
    for (BeanDefinitionHolder holder : configCandidates) {
        BeanDefinition bd = holder.getBeanDefinition();
        try {
            if (bd instanceof AnnotatedBeanDefinition) {
                parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
            }
            else if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {
                parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());
            }
            else {
                parse(bd.getBeanClassName(), holder.getBeanName());
            }
        }
        catch (BeanDefinitionStoreException ex) {
            throw ex;
        }
        catch (Throwable ex) {
            throw new BeanDefinitionStoreException(
                "Failed to parse configuration class [" + bd.getBeanClassName() + "]", ex);
        }
    }
    this.deferredImportSelectorHandler.process();
}
```

（10）解析ConfigurationClassParser类的parse(AnnotationMetadata metadata, String beanName)方法

```java
protected final void parse(AnnotationMetadata metadata, String beanName) throws IOException {
    processConfigurationClass(new ConfigurationClass(metadata, beanName), DEFAULT_EXCLUSION_FILTER);
}
```

（11）解析ConfigurationClassParser类的processConfigurationClass(ConfigurationClass configClass, Predicate<String> filter)方法

```java
protected void processConfigurationClass(ConfigurationClass configClass, Predicate<String> filter) throws IOException {
    //###############省略其他代码####################
    SourceClass sourceClass = asSourceClass(configClass, filter);
    do {
        sourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);
    }
    while (sourceClass != null);
    this.configurationClasses.put(configClass, configClass);
}
```

在processConfigurationClass()方法中，会通过do-while()循环获取配置类和其父类的注解信息，SourceClass类中会封装配置类上注解的详细信息。在在processConfigurationClass()方法中，调用了doProcessConfigurationClass()方法。

（12）解析ConfigurationClassParser类的doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)方法

```java
protected final SourceClass doProcessConfigurationClass(
    ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)
    throws IOException {
    //##################省略其他代码##################
    // Process individual @Bean methods
    Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);
    for (MethodMetadata methodMetadata : beanMethods) {
        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
    }
    //##################省略其他代码##################
    // No superclass -> processing is complete
    return null;
}
```

（13）解析ConfigurationClassParser类的retrieveBeanMethodMetadata(SourceClass sourceClass)方法

```java
private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {
    AnnotationMetadata original = sourceClass.getMetadata();
    Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName());
    if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {
        try {
            AnnotationMetadata asm = this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata();
            Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName());
            if (asmMethods.size() >= beanMethods.size()) {
                Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size());
                for (MethodMetadata asmMethod : asmMethods) {
                    for (MethodMetadata beanMethod : beanMethods) {
                        if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {
                            selectedMethods.add(beanMethod);
                            break;
                        }
                    }
                }
                if (selectedMethods.size() == beanMethods.size()) {
                    beanMethods = selectedMethods;
                }
            }
        }
        catch (IOException ex) {
            logger.debug("Failed to read class file via ASM for determining @Bean method order", ex);
        }
    }
    return beanMethods;
}
```

在retrieveBeanMethodMetadata()方法中主要是解析@Bean注解，并且将解析到的方法元数据存入 Set<MethodMetadata>集合中并返回。

（14）回到ConfigurationClassParser类的doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)方法。

```java
Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);
for (MethodMetadata methodMetadata : beanMethods) {
    configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
}
```

调用retrieveBeanMethodMetadata()方法获取到标注了@Bean注解的方法的元数据集合后，遍历方法的元数据集合，将方法的元数据methodMetadata和配置类configClass传入BeanMethod类的构造方法，创建BeanMethod对象，并调用configClass的addBeanMethod()方法传入创建的BeanMethod对象。

configClass的addBeanMethod()方法的源码

```java
void addBeanMethod(BeanMethod method) {
    this.beanMethods.add(method);
}
```

在addBeanMethod()方法中，调用了beanMethods的add()方法添加BeanMethod对象。

beanMethods的源码详见：org.springframework.context.annotation.ConfigurationClass#beanMethods，如下所示。

```java
private final Set<BeanMethod> beanMethods = new LinkedHashSet<>();
```

beanMethods是一个LinkedHashSet类型的集合。也就是说，在ConfigurationClassParser类的doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)方法中，会将解析出的标注了@Bean注解的元数据封装成BeanMethod对象，添加到一个LinkedHashSet类型的beanMethods集合中。

（15）回到ConfigurationClassPostProcessor类的processConfigBeanDefinitions(BeanDefinitionRegistry registry)方法

```java
public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
    //############省略其他代码#################
    do {
        //############省略其他代码#################
        this.reader.loadBeanDefinitions(configClasses);
        alreadyParsed.addAll(configClasses);
        processConfig.tag("classCount", () -> String.valueOf(configClasses.size())).end();
        //############省略其他代码#################
    }
    while (!candidates.isEmpty());
    //############省略其他代码#################
}
```

在processConfigBeanDefinitions()方法的do-while()循环中，调用了reader的loadBeanDefinitions()方法来加载Bean的定义信息。

（16）解析ConfigurationClassBeanDefinitionReader类的loadBeanDefinitions(Set<ConfigurationClass> configurationModel)方法

```java
public void loadBeanDefinitions(Set<ConfigurationClass> configurationModel) {
    TrackedConditionEvaluator trackedConditionEvaluator = new TrackedConditionEvaluator();
    for (ConfigurationClass configClass : configurationModel) {
        loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);
    }
}
```

在loadBeanDefinitions()方法中，会循环遍历传入的configurationModel集合，并调用loadBeanDefinitionsForConfigurationClass()方法处理遍历的每个元素。

（17）解析ConfigurationClassBeanDefinitionReader类的loadBeanDefinitionsForConfigurationClass(ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator)方法

```java
private void loadBeanDefinitionsForConfigurationClass(
    ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) {
    //###############省略其他代码################
    for (BeanMethod beanMethod : configClass.getBeanMethods()) {
        loadBeanDefinitionsForBeanMethod(beanMethod);
    }
	//###############省略其他代码################
}
```

在loadBeanDefinitionsForConfigurationClass()方法中，会循环遍历通过configClass获取到的BeanMethod集合，并调用loadBeanDefinitionsForBeanMethod()方法处理遍历的每个BeanMethod对象。

（18）解析ConfigurationClassBeanDefinitionReader类的loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod)方法

```java
private void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {
    ConfigurationClass configClass = beanMethod.getConfigurationClass();
    MethodMetadata metadata = beanMethod.getMetadata();
    String methodName = metadata.getMethodName();
    if (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {
        configClass.skippedBeanMethods.add(methodName);
        return;
    }
    if (configClass.skippedBeanMethods.contains(methodName)) {
        return;
    }
    AnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);
    Assert.state(bean != null, "No @Bean annotation attributes");
    List<String> names = new ArrayList<>(Arrays.asList(bean.getStringArray("name")));
    String beanName = (!names.isEmpty() ? names.remove(0) : methodName);
    for (String alias : names) {
        this.registry.registerAlias(beanName, alias);
    }
    if (isOverriddenByExistingDefinition(beanMethod, beanName)) {
        if (beanName.equals(beanMethod.getConfigurationClass().getBeanName())) {
            throw new BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource().getDescription(),
                                                   beanName, "Bean name derived from @Bean method '" + beanMethod.getMetadata().getMethodName() +
                                                   "' clashes with bean name for containing configuration class; please make those names unique!");
        }
        return;
    }

    ConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass, metadata, beanName);
    beanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));

    if (metadata.isStatic()) {
        // static @Bean method
        if (configClass.getMetadata() instanceof StandardAnnotationMetadata sam) {
            beanDef.setBeanClass(sam.getIntrospectedClass());
        }
        else {
            beanDef.setBeanClassName(configClass.getMetadata().getClassName());
        }
        beanDef.setUniqueFactoryMethodName(methodName);
    }
    else {
        // instance @Bean method
        beanDef.setFactoryBeanName(configClass.getBeanName());
        beanDef.setUniqueFactoryMethodName(methodName);
    }

    if (metadata instanceof StandardMethodMetadata sam) {
        beanDef.setResolvedFactoryMethod(sam.getIntrospectedMethod());
    }

    beanDef.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);
    AnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);

    boolean autowireCandidate = bean.getBoolean("autowireCandidate");
    if (!autowireCandidate) {
        beanDef.setAutowireCandidate(false);
    }

    String initMethodName = bean.getString("initMethod");
    if (StringUtils.hasText(initMethodName)) {
        beanDef.setInitMethodName(initMethodName);
    }

    String destroyMethodName = bean.getString("destroyMethod");
    beanDef.setDestroyMethodName(destroyMethodName);
    ScopedProxyMode proxyMode = ScopedProxyMode.NO;
    AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(metadata, Scope.class);
    if (attributes != null) {
        beanDef.setScope(attributes.getString("value"));
        proxyMode = attributes.getEnum("proxyMode");
        if (proxyMode == ScopedProxyMode.DEFAULT) {
            proxyMode = ScopedProxyMode.NO;
        }
    }
    BeanDefinition beanDefToRegister = beanDef;
    if (proxyMode != ScopedProxyMode.NO) {
        BeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(
            new BeanDefinitionHolder(beanDef, beanName), this.registry,
            proxyMode == ScopedProxyMode.TARGET_CLASS);
        beanDefToRegister = new ConfigurationClassBeanDefinition(
            (RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata, beanName);
    }

    if (logger.isTraceEnabled()) {
        logger.trace(String.format("Registering bean definition for @Bean method %s.%s()",
                                   configClass.getMetadata().getClassName(), beanName));
    }
    this.registry.registerBeanDefinition(beanName, beanDefToRegister);
}
```

在loadBeanDefinitionsForBeanMethod()方法中解析了@Bean注解中的属性信息，并将解析出的信息封装到一个BeanDefinition对象中，最终会调用registry对象的registerBeanDefinition()方法将封装的BeanDefinition对象注册到IOC容器中。

（19）解析DefaultListableBeanFactory类的registerBeanDefinition(String beanName, BeanDefinition beanDefinition)方法

```java
@Override
public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
    throws BeanDefinitionStoreException {
	//##############省略其他代码#################
    BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
    if (existingDefinition != null) {
        //##############省略其他代码#################
        this.beanDefinitionMap.put(beanName, beanDefinition);
    }
    else {
        //##############省略其他代码#################
        if (hasBeanCreationStarted()) {
            // Cannot modify startup-time collection elements anymore (for stable iteration)
            synchronized (this.beanDefinitionMap) {
                this.beanDefinitionMap.put(beanName, beanDefinition);
                List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);
                updatedDefinitions.addAll(this.beanDefinitionNames);
                updatedDefinitions.add(beanName);
                this.beanDefinitionNames = updatedDefinitions;
                removeManualSingletonName(beanName);
            }
        }
        else {
            // Still in startup registration phase
            this.beanDefinitionMap.put(beanName, beanDefinition);
            this.beanDefinitionNames.add(beanName);
            removeManualSingletonName(beanName);
        }
        this.frozenBeanDefinitionNames = null;
    }
    if (existingDefinition != null || containsSingleton(beanName)) {
        resetBeanDefinition(beanName);
    }
    else if (isConfigurationFrozen()) {
        clearByTypeCache();
    }
}
```

Spring会解析这些标注了@Bean注解的方法，将解析出的信息封装成BeanDefinition对象注册到beanDefinitionMap中。

#### 调用初始化方法

（1）在BeanTest类的main()方法中，会调用AnnotationConfigApplicationContext类的构造方法创建IOC容器。

（2）解析AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext(Class<?>... componentClasses)方法

```java
public AnnotationConfigApplicationContext(Class<?>... componentClasses) {
    this();
    register(componentClasses);
    refresh();
}
```

（3）解析AbstractApplicationContext类的refresh()方法

```java
@Override
public void refresh() throws BeansException, IllegalStateException {
    synchronized (this.startupShutdownMonitor) {
         /*************省略其他代码**************/
        try {
            /*************省略其他代码**************/
            // Instantiate all remaining (non-lazy-init) singletons.
            finishBeanFactoryInitialization(beanFactory);
 			/*************省略其他代码**************/
        }
        catch (BeansException ex) {
            /*************省略其他代码**************/
        }
        finally {
            /*************省略其他代码**************/
        }
    }
}
```

在AbstractApplicationContext类的refresh()方法中，会调用finishBeanFactoryInitialization()方法实例化未延迟创建的单例Bean。

（4）解析AbstractApplicationContext类的finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory)方法

```java
protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
    /*************省略其他代码**************/
    // Instantiate all remaining (non-lazy-init) singletons.
    beanFactory.preInstantiateSingletons();
}
```

在AbstractApplicationContext类的finishBeanFactoryInitialization()方法中，会调用beanFactory的preInstantiateSingletons()方法来创建非懒加载的Bean。

（5）解析DefaultListableBeanFactory类的preInstantiateSingletons()方法

```java
@Override
public void preInstantiateSingletons() throws BeansException {
   /*************省略其他代码**************/
    List<String> beanNames = new ArrayList<>(this.beanDefinitionNames);
    // Trigger initialization of all non-lazy singleton beans...
    for (String beanName : beanNames) {
        RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
        if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
            /*************省略其他代码**************/
            }
            else {
                getBean(beanName);
            }
        }
    }
	/*************省略其他代码**************/
}
```

在DefaultListableBeanFactory类的preInstantiateSingletons()方法中，会循环遍历所有非懒加载的单例Bean的名称，调用getBean()方法创建单例Bean对象。

（6）解析AbstractBeanFactory类的getBean(String name)方法

```java
@Override
public Object getBean(String name) throws BeansException {
    return doGetBean(name, null, null, false);
}
```

在AbstractBeanFactory类的getBean()方法中，会调用doGetBean()方法创建Bean对象。

（7）解析AbstractBeanFactory类的doGetBean(String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly)方法

```java
protected <T> T doGetBean(String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException {
    String beanName = transformedBeanName(name);
    Object beanInstance;
    // Eagerly check singleton cache for manually registered singletons.
    Object sharedInstance = getSingleton(beanName);
    if (sharedInstance != null && args == null) {
        /***********省略其他代码*************/
    }
    else {
        /***********省略其他代码*************/
        try {
            /***********省略其他代码*************/
            // Create bean instance.
            if (mbd.isSingleton()) {
                sharedInstance = getSingleton(beanName, () -> {
                    try {
                        return createBean(beanName, mbd, args);
                    }
                    catch (BeansException ex) {
                        /***********省略其他代码*************/
                    }
                });
                beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
            }
			/***********省略其他代码*************/
        }
        catch (BeansException ex) {
           /***********省略其他代码*************/
        }
        finally {
           /***********省略其他代码*************/
        }
    }
    return adaptBeanInstance(name, beanInstance, requiredType);
}
```

在AbstractBeanFactory类的doGetBean()方法中，会调用createBean()方法创建Bean对象。

（8）解析AbstractAutowireCapableBeanFactory类的createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)方法

```java
@Override
protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {
	/***********省略其他代码*************/
    try {
        Object beanInstance = doCreateBean(beanName, mbdToUse, args);
        if (logger.isTraceEnabled()) {
            logger.trace("Finished creating instance of bean '" + beanName + "'");
        }
        return beanInstance;
    }
    catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {
        /***********省略其他代码*************/
    }
    catch (Throwable ex) {
        /***********省略其他代码*************/
    }
}
```

在AbstractAutowireCapableBeanFactory类的createBean()方法中，会调用doCreateBean()方法创建Bean对象。

（9）解析AbstractAutowireCapableBeanFactory类的doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)方法

```java
protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {
	/***********省略其他代码*************/
    Object exposedObject = bean;
    try {
        populateBean(beanName, mbd, instanceWrapper);
        exposedObject = initializeBean(beanName, exposedObject, mbd);
    }
    catch (Throwable ex) {
       /***********省略其他代码*************/
    }
	/***********省略其他代码*************/
    return exposedObject;
}
```

在AbstractAutowireCapableBeanFactory类的doCreateBean()方法中，会调用initializeBean()方法初始化Bean对象。

（10）解析AbstractAutowireCapableBeanFactory类的initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd)方法

```java
protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) {
    /***********省略其他代码*************/
    try {
        invokeInitMethods(beanName, wrappedBean, mbd);
    }
    catch (Throwable ex) {
       /***********省略其他代码*************/
    }
    /***********省略其他代码*************/
    return wrappedBean;
}
```

在AbstractAutowireCapableBeanFactory类的initializeBean()方法中，会调用invokeInitMethods()方法来调用初始化方法。

（11）解析AbstractAutowireCapableBeanFactory类的invokeInitMethods(String beanName, Object bean, @Nullable RootBeanDefinition mbd)方法

```java
protected void invokeInitMethods(String beanName, Object bean, @Nullable RootBeanDefinition mbd) throws Throwable {
	/***********省略其他代码*************/
    if (mbd != null && bean.getClass() != NullBean.class) {
        String[] initMethodNames = mbd.getInitMethodNames();
        if (initMethodNames != null) {
            for (String initMethodName : initMethodNames) {
                if (StringUtils.hasLength(initMethodName) &&
                    !(isInitializingBean && "afterPropertiesSet".equals(initMethodName)) &&
                    !mbd.hasAnyExternallyManagedInitMethod(initMethodName)) {
                    invokeCustomInitMethod(beanName, bean, mbd, initMethodName);
                }
            }
        }
    }
}
```

在AbstractAutowireCapableBeanFactory类的invokeInitMethods()方法中，会调用invokeCustomInitMethod()方法来执行自定义的初始化方法。

（12）解析AbstractAutowireCapableBeanFactory类的invokeCustomInitMethod(String beanName, Object bean, RootBeanDefinition mbd, String initMethodName)方法

```java
protected void invokeCustomInitMethod(String beanName, Object bean, RootBeanDefinition mbd, String initMethodName)  throws Throwable {
    Method initMethod = (mbd.isNonPublicAccessAllowed() ? BeanUtils.findMethod(bean.getClass(), initMethodName) : ClassUtils.getMethodIfAvailable(bean.getClass(), initMethodName));
	/***********省略其他代码*************/
    Method methodToInvoke = ClassUtils.getInterfaceMethodIfPossible(initMethod, bean.getClass());
    try {
        ReflectionUtils.makeAccessible(methodToInvoke);
        methodToInvoke.invoke(bean);
    }
    catch (InvocationTargetException ex) {
        throw ex.getTargetException();
    }
}
```

在AbstractAutowireCapableBeanFactory类的invokeCustomInitMethod()方法中，会通过Java的反射机制调用自定义的初始化方法。

#### 调用销毁方法

（1）在BeanTest类的main()方法中，会调用context对象的close()方法来关闭IOC容器

```java
public static void main(String[] args) {
    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(BeanConfig.class);
    /*********省略其他代码***********/
    context.close();
}
```

（2）解析AbstractApplicationContext类的close()方法

```java
@Override
public void close() {
    synchronized (this.startupShutdownMonitor) {
        doClose();
        /*********省略其他代码***********/
    }
}
```

在AbstractApplicationContext类的close()方法中，调用了doClose()方法来关闭IOC容器。

（3）解析AbstractApplicationContext类的doClose()方法

```java
protected void doClose() {
    // Check whether an actual close attempt is necessary...
    if (this.active.get() && this.closed.compareAndSet(false, true)) {
         /*********省略其他代码***********/
        // Destroy all cached singletons in the context's BeanFactory.
        destroyBeans();
 		/*********省略其他代码***********/
    }
}
```

在AbstractApplicationContext类的doClose()方法中，会调用destroyBeans()方法销毁所有的单例Bean。

（4）解析AbstractApplicationContext类的destroyBeans()方法

```java
protected void destroyBeans() {
    getBeanFactory().destroySingletons();
}
```

在AbstractApplicationContext类的destroyBeans()方法中，调用了beanFactory的destroySingletons()方法来销毁单例Bean。

（5）解析DefaultListableBeanFactory类的destroySingletons()方法

```java
@Override
public void destroySingletons() {
    super.destroySingletons();
    /*********省略其他代码***********/
}
```

在DefaultListableBeanFactory类的destroySingletons()方法中，会调用父类的destroySingletons()方法。

（6）解析DefaultSingletonBeanRegistry类的destroySingletons()方法

```java
public void destroySingletons() {
    /*********省略其他代码***********/
    for (int i = disposableBeanNames.length - 1; i >= 0; i--) {
        destroySingleton(disposableBeanNames[i]);
    }
	/*********省略其他代码***********/
}
```

在DefaultSingletonBeanRegistry类的destroySingletons()方法中，会调用destroySingleton()方法销毁指定的单例Bean对象。

（7）解析DefaultListableBeanFactory类的destroySingleton(String beanName)方法

```java
@Override
public void destroySingleton(String beanName) {
    super.destroySingleton(beanName);
    /*********省略其他代码***********/
}
```

在DefaultListableBeanFactory类的destroySingleton()方法中，会调用父类的destroySingleton()方法销毁指定的单例Bean。

（8）解析DefaultSingletonBeanRegistry类的destroySingleton(String beanName)方法

```java
public void destroySingleton(String beanName) {
    removeSingleton(beanName);
    DisposableBean disposableBean;
    synchronized (this.disposableBeans) {
        disposableBean = (DisposableBean) this.disposableBeans.remove(beanName);
    }
    destroyBean(beanName, disposableBean);
}
```

在DefaultSingletonBeanRegistry类的destroySingleton(方法中，会调用destroyBean()方法来销毁指定的单例Bean对象。

（9）解析DefaultSingletonBeanRegistry类的destroyBean(String beanName, @Nullable DisposableBean bean)方法。

```java
protected void destroyBean(String beanName, @Nullable DisposableBean bean) {
    /***********省略其他代码***********/
    if (bean != null) {
        try {
            bean.destroy();
        }
        catch (Throwable ex) {
            /***********省略其他代码***********/
        }
    }
    /***********省略其他代码***********/
}
```

在DefaultSingletonBeanRegistry类的destroyBean()方法中，会调用bean对象的destroy()方法销毁Bean对象。

（10）解析DisposableBeanAdapter类的destroy()方法

```java
@Override
public void destroy() {
    /***********省略其他代码***********/
    else if (this.destroyMethods != null) {
        for (Method destroyMethod : this.destroyMethods) {
            invokeCustomDestroyMethod(destroyMethod);
        }
    }
    /***********省略其他代码***********/
}
```

在DisposableBeanAdapter类的destroy()方法中，会调用invokeCustomDestroyMethod()方法执行自定义的销毁方法。

（11）解析DisposableBeanAdapter类的invokeCustomDestroyMethod(Method destroyMethod)方法

```java
private void invokeCustomDestroyMethod(Method destroyMethod) {
    /***********省略其他代码***********/
    try {
        ReflectionUtils.makeAccessible(destroyMethod);
        destroyMethod.invoke(this.bean, args);
    } catch (InvocationTargetException ex) {
        /***********省略其他代码***********/
    } catch (Throwable ex) {
        /***********省略其他代码***********/
    }
}
```

在DisposableBeanAdapter类的invokeCustomDestroyMethod()中，最终会通过Java的反射技术调用自定义的销毁方法。在本章的案例程序中，最终会调用User类的destroy()方法。

### 思考

#### 1. @Bean注解为何也是先将Bean定义信息注册到IOC容器中呢？这样做的好处是什么？

**为什么注册到IOC容器**：

`@Bean` 注解用于在配置类中声明一个Bean，并将其注册到Spring的IOC容器中。这样做的目的是为了管理Bean的生命周期，包括创建、配置、装配和销毁。将Bean定义信息（如Bean的类型、依赖、作用域等）先注册到IOC容器中，而不是立即实例化，是为了实现依赖注入（DI）和控制反转（IoC）的核心理念。

**好处**：

1. **延迟实例化**：只有当Bean真正被需要时，Spring容器才会去实例化它。这有助于减少启动时间，因为不是所有的Bean在应用程序启动时都需要被创建。
2. **依赖注入**：Spring容器能够管理Bean之间的依赖关系，并在需要时注入依赖。通过将Bean定义注册到容器中，Spring可以自动解决这些依赖关系。
3. **生命周期管理**：Spring容器可以管理Bean的整个生命周期，包括初始化（通过`initMethod`）、使用和销毁（通过`destroyMethod`）。
4. **灵活性**：将Bean定义与Bean的实例化分离，增加了配置的灵活性。例如，可以通过配置更改Bean的作用域、生命周期回调等，而无需修改Bean的实现代码。

#### 2. @Bean注解标注的方法被Spring解析后将Bean定义信息注册到IOC容器中后，何时会对注册的信息进行实例化呢？实例化的流程是怎样的？

**实例化时机**：

Bean的实例化发生在它被请求时，通常是在依赖注入时。具体来说，当一个Bean被另一个Bean依赖并请求时，Spring容器会检查该Bean是否已实例化；如果没有，则进行实例化。

**实例化流程**：

1. **Bean的查找**：当一个Bean被请求时，Spring容器首先会在容器中查找该Bean的定义。
2. **Bean的实例化**：如果找到了Bean的定义但Bean尚未实例化，Spring容器会根据Bean的定义（如通过构造函数、工厂方法或静态工厂方法等）来实例化Bean。
3. **依赖注入**：在Bean实例化后，Spring容器会检查Bean的依赖关系，并将依赖的Bean注入到当前Bean中。
4. **Bean的初始化**：在依赖注入完成后，Spring容器会调用Bean的初始化方法（如果有的话），这通常是通过Bean定义中的`initMethod`属性指定的。
5. **Bean的可用**：完成上述步骤后，Bean就准备好被应用程序使用了。

#### 3. Spring是如何调用@Bean注解中使用initMethod和destroyMethod属性指定的方法的？调用的流程是怎样的呢？

**initMethod和destroyMethod的调用**：

**initMethod的调用流程**：

1. 在Bean实例化并完成依赖注入后，Spring容器会检查Bean定义中是否指定了`initMethod`。
2. 如果指定了，Spring容器会调用该Bean的`initMethod`指定的方法，进行初始化操作。

**destroyMethod的调用流程**：

1. 当Spring容器关闭时（例如，应用程序停止时），它会开始销毁容器中的Bean。
2. 对于需要销毁的Bean，Spring容器会检查Bean定义中是否指定了`destroyMethod`。
3. 如果指定了，Spring容器会在Bean销毁前调用`destroyMethod`指定的方法，进行清理操作。

**注意**：`destroyMethod`的调用通常发生在Spring容器关闭时，而不是Bean的实例化过程中。此外，对于单例（Singleton）Bean，它们的`destroyMethod`通常只会在容器关闭时被调用一次。而对于其他作用域的Bean（如请求作用域、会话作用域等），它们的生命周期管理可能更加复杂，但基本的`initMethod`和`destroyMethod`调用流程是相似的。



## 1.4 从IOC容器中获取Bean的过程

如果是单实例Bean，则IOC容器启动时，就会创建Bean对象，IOC容器关闭时，销毁Bean对象。如果是多实例Bean，IOC容器在启动时，不会创建Bean对象，在每次从IOC容器中获取Bean对象时，都会创建新的Bean对象返回，IOC容器关闭时，也不会销毁对象。也就是说，如果是多实例Bean，IOC容器不会管理Bean对象。

### 源码时序图

![图4-1](https://upload.yolo912.icu/mdImage/spring-core-2022-12-22-001.png)

![图4-2](https://upload.yolo912.icu/mdImage/spring-core-2022-12-22-002.png)

### 源码解析

从IOC容器中获取Bean的过程的源码执行流程，结合源码执行的时序图，会理解的更加深刻。

（1）在BeanTest类的main()方法中调用了AnnotationConfigApplicationContext类的构造方法，并传入了ComponentScanConfig类的Class对象来创建IOC容器。接下来进入AnnotationConfigApplicationContext类的构造方法。

（2）解析AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext(Class<?>... componentClasses)构造方法

```java
public AnnotationConfigApplicationContext(Class<?>... componentClasses) {
    this();
    register(componentClasses);
    refresh();
}
```

（3）解析AbstractApplicationContext类的refresh()方法

```java
@Override
public void refresh() throws BeansException, IllegalStateException {
    synchronized (this.startupShutdownMonitor) {
        //############省略其他代码##############
        try {
            //############省略其他代码##############
            invokeBeanFactoryPostProcessors(beanFactory);
           //############省略其他代码##############
        }catch (BeansException ex) {
            //############省略其他代码##############
        }finally {
            //############省略其他代码##############
        }
    }
}
```

（4）解析AbstractApplicationContext类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory)方法

```java
protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
    if (!NativeDetector.inNativeImage() && beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
        beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
        beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
    }
}
```

（5）解析PostProcessorRegistrationDelegate类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors)方法

```java
public static void invokeBeanFactoryPostProcessors(
    ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {

    //############省略其他代码##############
    List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();

    // 首先，调用实现了PriorityOrdered接口的BeanDefinitionRegistryPostProcessor
    // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
    String[] postProcessorNames =
        beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
    for (String ppName : postProcessorNames) {
        // 如果bean的名称匹配PriorityOrdered类型
        if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
            // 将该bean添加到当前注册的处理器列表中
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            // 将已处理的bean的名称添加到已处理bean列表中
            processedBeans.add(ppName);
        }
    }
    // 对当前注册的处理器列表进行排序
    sortPostProcessors(currentRegistryProcessors, beanFactory);
    // 将当前注册的处理器列表添加到最终的处理器列表中
    registryProcessors.addAll(currentRegistryProcessors);
    // 调用当前注册的处理器列表中的BeanDefinitionRegistryPostProcessor
    invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());
    // 清空当前注册的处理器列表
    currentRegistryProcessors.clear();

    // 接下来，调用实现了Ordered接口的BeanDefinitionRegistryPostProcessor
    // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
    postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
    for (String ppName : postProcessorNames) {
        // 如果bean的名称不在已处理bean列表中，并且匹配Ordered类型
        if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {
            // 将该bean添加到当前注册的处理器列表中
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            // 将已处理的bean的名称添加到已处理bean列表中
            processedBeans.add(ppName);
        }
    }
    sortPostProcessors(currentRegistryProcessors, beanFactory);
    registryProcessors.addAll(currentRegistryProcessors);
    invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());
    currentRegistryProcessors.clear();

    // 最后，循环调用所有其他未处理的BeanDefinitionRegistryPostProcessors，直到没有新的出现
    // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
    boolean reiterate = true;
    while (reiterate) {
        reiterate = false;
        // 获取所有BeanDefinitionRegistryPostProcessor类型的bean名称
        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
        for (String ppName : postProcessorNames) {
            // 如果该bean名称不在已处理bean列表中
            if (!processedBeans.contains(ppName)) {
                // 将该bean添加到当前注册的处理器列表中
                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                // 将该bean名称添加到已处理bean列表中
                processedBeans.add(ppName);
                // 设置需要再次循环的标志为true
                reiterate = true;
            }
        }
        // 对当前注册的处理器列表进行排序
        sortPostProcessors(currentRegistryProcessors, beanFactory);
        // 将当前注册的处理器列表添加到最终的处理器列表中
        registryProcessors.addAll(currentRegistryProcessors);
        // 调用当前注册的处理器列表中的BeanDefinitionRegistryPostProcessor
        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());
        // 清空当前注册的处理器列表
        currentRegistryProcessors.clear();
    }
    //############省略其他代码##############
}
```

（6）解析AbstractBeanFactory类的getBean(String name, Class<T> requiredType)方法

```java
@Override
public <T> T getBean(String name, Class<T> requiredType) throws BeansException {
    return doGetBean(name, requiredType, null, false);
}
```

（7）解析AbstractBeanFactory类的doGetBean(String name, Class<T> requiredType, Object[] args, boolean typeCheckOnly)方法

```java
protected <T> T doGetBean(
    String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly)
    throws BeansException {

    String beanName = transformedBeanName(name);
    Object beanInstance;

    // 立即检查单例缓存中是否存在手动注册的单例对象。
    // Eagerly check singleton cache for manually registered singletons.
    Object sharedInstance = getSingleton(beanName);
    if (sharedInstance != null && args == null) {
        if (logger.isTraceEnabled()) {
            if (isSingletonCurrentlyInCreation(beanName)) {
                // 如果bean正在创建中，记录日志信息，表示返回的是一个还未完全初始化的单例对象，是循环引用的结果。
                logger.trace("Returning eagerly cached instance of singleton bean '" + beanName +
                             "' that is not fully initialized yet - a consequence of a circular reference");
            }
            else {
                // 如果bean已经创建完成，记录日志信息，表示返回的是一个已缓存的单例对象。
                logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
            }
        }
        // 获取缓存的单例对象实例，并将其转换为合适的Bean实例。
        beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, null);
    }
    else {
        // 如果已经在创建这个bean实例，则抛出异常：
        // 假设我们在一个循环引用中。
        // Fail if we're already creating this bean instance:
        // We're assumably within a circular reference.
        if (isPrototypeCurrentlyInCreation(beanName)) {
            throw new BeanCurrentlyInCreationException(beanName);
        }

        // 检查该工厂中是否存在bean定义。
        // Check if bean definition exists in this factory.
        BeanFactory parentBeanFactory = getParentBeanFactory();
        if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {
            // 未找到 -> 检查父工厂。
            // Not found -> check parent.
            String nameToLookup = originalBeanName(name);
            if (parentBeanFactory instanceof AbstractBeanFactory abf) {
                // 委托给父工厂，并调用doGetBean方法获取bean。
                // Delegation to parent with explicit doGetBean call.
                return abf.doGetBean(nameToLookup, requiredType, args, typeCheckOnly);
            }
            else if (args != null) {
                // 委托给父工厂，并传入明确的参数获取bean。
                // Delegation to parent with explicit args.
                return (T) parentBeanFactory.getBean(nameToLookup, args);
            }
            else if (requiredType != null) {
                // 没有参数 -> 委托给父工厂的标准getBean方法获取bean。
                // No args -> delegate to standard getBean method.
                return parentBeanFactory.getBean(nameToLookup, requiredType);
            }
            else {
                // 直接委托给父工厂获取bean。
                return (T) parentBeanFactory.getBean(nameToLookup);
            }
        }

        if (!typeCheckOnly) {
            // 如果不是仅进行类型检查
            markBeanAsCreated(beanName);
            // 标记bean为已创建
        }
        // 开始记录bean创建过程
        StartupStep beanCreation = this.applicationStartup.start("spring.beans.instantiate")
            .tag("beanName", name);
        try {
            if (requiredType != null) {
                // 如果requiredType不为空，则记录bean的类型信息
                beanCreation.tag("beanType", requiredType::toString);
            }

            // 获取合并后的本地Bean定义
            RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
            // 检查合并后的Bean定义
            checkMergedBeanDefinition(mbd, beanName, args);

            // 保证当前Bean所依赖的Bean已经初始化完成
            // Guarantee initialization of beans that the current bean depends on.
            String[] dependsOn = mbd.getDependsOn();
            if (dependsOn != null) {
                for (String dep : dependsOn) {
                    // 如果存在循环依赖关系，则抛出异常
                    if (isDependent(beanName, dep)) {
                        throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                                        "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
                    }
                    // 注册依赖关系
                    registerDependentBean(dep, beanName);
                    try {
                        // 获取依赖的Bean
                        getBean(dep);
                    }
                    catch (NoSuchBeanDefinitionException ex) {
                        // 如果找不到依赖的Bean，则抛出异常
                        throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                                        "'" + beanName + "' depends on missing bean '" + dep + "'", ex);
                    }
                }
            }

            // 创建bean实例
            // Create bean instance.
            if (mbd.isSingleton()) {
                // 获取单例缓存中的bean实例，如果不存在则调用lambda表达式创建
                sharedInstance = getSingleton(beanName, () -> {
                    try {
                        // 调用createBean方法创建bean实例
                        return createBean(beanName, mbd, args);
                    }
                    catch (BeansException ex) {
                        // 如果创建过程中发生异常，则从单例缓存中显式移除实例
                        // 它可能在创建过程中被急切地放入单例缓存中，以允许解决循环引用
                        // 同时移除任何接收到对该bean的临时引用的bean
                        // Explicitly remove instance from singleton cache: It might have been put there
                        // eagerly by the creation process, to allow for circular reference resolution.
                        // Also remove any beans that received a temporary reference to the bean.
                        destroySingleton(beanName);
                        throw ex;
                    }
                });
                // 将共享的bean实例转换为适当的Bean实例对象
                beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
            }
            else if (mbd.isPrototype()) {
                // 如果Bean是单例模式，则创建一个新的实例
                // It's a prototype -> create a new instance.
                Object prototypeInstance = null;
                try {
                    // 在创建原型实例之前进行预处理
                    beforePrototypeCreation(beanName);
                    // 创建原型实例
                    prototypeInstance = createBean(beanName, mbd, args);
                }
                finally {
                    // 在创建原型实例之后进行后处理
                    afterPrototypeCreation(beanName);
                }
                // 将原型实例转换为合适的Bean实例对象
                beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
            }
            else {
                // 获取Bean的作用域名称
                String scopeName = mbd.getScope();
                // 如果作用域名称为空
                if (!StringUtils.hasLength(scopeName)) {
                    // 抛出异常，提示未定义Bean的作用域名称
                    throw new IllegalStateException("No scope name defined for bean '" + beanName + "'");
                }
                // 根据作用域名称获取对应的作用域对象
                Scope scope = this.scopes.get(scopeName);
                // 如果作用域对象为null
                if (scope == null) {
                    // 抛出异常，提示未注册对应的作用域
                    throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
                }
                try {
                    // 调用作用域对象的get方法获取Bean的实例，并传入Lambda表达式作为参数
                    Object scopedInstance = scope.get(beanName, () -> {
                        // 在创建原型Bean之前执行的逻辑
                        beforePrototypeCreation(beanName);
                        try {
                            // 调用createBean方法创建Bean实例
                            return createBean(beanName, mbd, args);
                        }
                        finally {
                            // 在创建原型Bean之后执行的逻辑
                            afterPrototypeCreation(beanName);
                        }
                    });
                    // 将作用域Bean实例转换为合适的Bean实例对象
                    beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
                }
                catch (IllegalStateException ex) {
                    // 捕获异常，并转换为ScopeNotActiveException异常抛出
                    throw new ScopeNotActiveException(beanName, scopeName, ex);
                }
            }
        }
        catch (BeansException ex) {
            // 添加异常类型标签
            beanCreation.tag("exception", ex.getClass().toString());
            // 添加异常信息标签
            beanCreation.tag("message", String.valueOf(ex.getMessage()));
            // 清理Bean创建失败后的资源
            cleanupAfterBeanCreationFailure(beanName);
            // 抛出异常
            throw ex;
        }
        finally {
            beanCreation.end();
        }
    }
    // 调用adaptBeanInstance方法，将beanInstance适配为所需类型并返回
    return adaptBeanInstance(name, beanInstance, requiredType);
}
```

doGetBean()方法的源码大体流程：

* 先通过transformedBeanName()方法转换bean的名称，可能是FactoryBean的名称（&开头），需要转成不带&开头的名称，如果有别名，再获取别名。
* 从缓存中获取bean，这里的缓存分为一二三级缓存，也就是spring的三级缓存。
* 根据获取到的对象再去获取想要的Bean，因为这里获取到的对象可能是需要的Bean，也可能是FactoryBean（工厂Bean）。
* 如果缓存中没有，就去创建Bean对象。
* 查看有没有父类的BeanFactory，如果有，那么就使用父类去创建Bean对象。
* 获取要创建的Bean对象的@DependsOn注解上的名称，先去创建DependsOn的Bean，并且校验是否存在循环引用。
* 创建Bean，根据类型创建不同的Bean，比如singleton，prototype，request，session等。
* 如果需要转换类型，则进行类型转换。如果不需要转换类型，就不转换类型。

（8）解析DefaultSingletonBeanRegistry类的getSingleton(String beanName)方法

```java
@Override
@Nullable
public Object getSingleton(String beanName) {
    return getSingleton(beanName, true);
}
```

（9）解析DefaultSingletonBeanRegistry类的getSingleton(String beanName, boolean allowEarlyReference)方法

```java
@Nullable
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    // 快速检查是否存在实例，无需获取完整的单例锁
    // Quick check for existing instance without full singleton lock
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
        // 尝试从早期单例对象中获取实例
        singletonObject = this.earlySingletonObjects.get(beanName);
        if (singletonObject == null && allowEarlyReference) {
            synchronized (this.singletonObjects) {
                // 在完整的单例锁下，一致地创建早期引用
                // Consistent creation of early reference within full singleton lock
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    singletonObject = this.earlySingletonObjects.get(beanName);
                    if (singletonObject == null) {
                        // 尝试从单例工厂中获取实例
                        ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
                        if (singletonFactory != null) {
                            singletonObject = singletonFactory.getObject();
                            // 将实例放入早期单例对象中
                            this.earlySingletonObjects.put(beanName, singletonObject);
                            // 从单例工厂中移除对应的工厂
                            this.singletonFactories.remove(beanName);
                        }
                    }
                }
            }
        }
    }
    return singletonObject;
}
```

Spring的三级缓存。

* singletonObjects：一级缓存，实例化的Bean都会存储在这个Map集合中。
* earlySingletonObjects：二级缓存，存放未完成的bean的缓存，如果有代理的话，存放的是代理对象。
* singletonFactories：三级缓存，存放的是一个ObjectFactory，数据通过getObject方法获得。

（10）解析AbstractBeanFactory类的getObjectForBeanInstance(Object beanInstance, String name, String beanName, RootBeanDefinition mbd)方法。

```java
protected Object getObjectForBeanInstance(
    Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) {
    //name是否是以&开头
    if (BeanFactoryUtils.isFactoryDereference(name)) {
        if (beanInstance instanceof NullBean) {
            return beanInstance;
        }
        if (!(beanInstance instanceof FactoryBean)) {
            throw new BeanIsNotAFactoryException(beanName, beanInstance.getClass());
        }
        if (mbd != null) {
            mbd.isFactoryBean = true;
        }
        return beanInstance;
    }
	//如果bean不是FactoryBean，直接返回beanInstance
    if (!(beanInstance instanceof FactoryBean<?> factoryBean)) {
        return beanInstance;
    }

    Object object = null;
    if (mbd != null) {
        mbd.isFactoryBean = true;
    }
    else {
        // 尝试从缓存中获取FactoryBean创建的bean实例//从缓存中获取对象
        object = getCachedObjectForFactoryBean(beanName);
    }
    if (object == null) {
        // 从工厂返回bean实例
        // 如果bean是单例的，则将FactoryBean创建的bean实例缓存起来
        if (mbd == null && containsBeanDefinition(beanName)) {
            mbd = getMergedLocalBeanDefinition(beanName);
        }
        boolean synthetic = (mbd != null && mbd.isSynthetic());
        //通过FactoryBean获取需要的beanInstance
        object = getObjectFromFactoryBean(factoryBean, beanName, !synthetic);
    }
    return object;
}
```

整个getObjectForBeanInstance()方法大体的流程：

* 首先判断name是不是FactoryBean的name，也就是&开头的name，如果beanInstance不是FactoryBean则抛异常。
* 如果name是FactoryBeanName，那么需要获取的就是FactoryBean，直接返回对象。

* 如果都没有返回，那么已经可以确定此时已经可以确定beanInstance是FactoryBean了，因为如果不是FactoryBean在(beanInstance instanceof FactoryBean)就已经返回了。

* 通过FactoryBean的getObject方法获取需要的Bean实例。

（11）解析DefaultSingletonBeanRegistry类的getSingleton(String beanName, ObjectFactory<?> singletonFactory)方法。

```java
public Object getSingleton(String beanName, ObjectFactory<?> singletonFactory) {
    Assert.notNull(beanName, "Bean name must not be null");
    synchronized (this.singletonObjects) {
        // 从单例缓存中获取指定beanName的单例对象
        Object singletonObject = this.singletonObjects.get(beanName);
        // 如果单例对象为空
        if (singletonObject == null) {
            // 如果当前有单例对象正在销毁
            if (this.singletonsCurrentlyInDestruction) {
                //#########省略异常代码################
            }
            if (logger.isDebugEnabled()) {
                logger.debug("Creating shared instance of singleton bean '" + beanName + "'");
            }
            beforeSingletonCreation(beanName);
            boolean newSingleton = false;
            // 记录是否需要记录被抑制的异常
            boolean recordSuppressedExceptions = (this.suppressedExceptions == null);
            if (recordSuppressedExceptions) {
                this.suppressedExceptions = new LinkedHashSet<>();
            }
            try {
                // 通过工厂对象获取单例对象
                singletonObject = singletonFactory.getObject();
                // 设置标志位，表示创建了新的单例对象
                newSingleton = true;
            }
            catch (IllegalStateException ex) {
                // 如果在获取单例对象的过程中出现了IllegalStateException异常，
                // 则尝试从已存在的单例对象集合中获取单例对象
                // Has the singleton object implicitly appeared in the meantime ->
                // if yes, proceed with it since the exception indicates that state.
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    throw ex;
                }
            }
            catch (BeanCreationException ex) {
                if (recordSuppressedExceptions) {
                    // 如果需要记录被抑制的异常，则将已记录的异常添加到BeanCreationException中
                    for (Exception suppressedException : this.suppressedExceptions) {
                        ex.addRelatedCause(suppressedException);
                    }
                }
                throw ex;
            }
            finally {
                if (recordSuppressedExceptions) {
                    // 清空已记录的异常集合
                    this.suppressedExceptions = null;
                }
                // 调用afterSingletonCreation方法，执行单例对象创建后的操作
                afterSingletonCreation(beanName);
            }
            if (newSingleton) {
                // 如果创建了新的单例对象，则将其添加到单例对象集合中
                addSingleton(beanName, singletonObject);
            }
        }
        return singletonObject;
    }
}
```

在上述getSingleton()方法中，创建Bean对象之前调用了 beforeSingletonCreation()方法，在创建对象之后调用了afterSingletonCreation()方法。源码如下：

```java
protected void beforeSingletonCreation(String beanName) {
    if (!this.inCreationCheckExclusions.contains(beanName) && !this.singletonsCurrentlyInCreation.add(beanName)) {
        throw new BeanCurrentlyInCreationException(beanName);
    }
}

protected void afterSingletonCreation(String beanName) {
    if (!this.inCreationCheckExclusions.contains(beanName) && !this.singletonsCurrentlyInCreation.remove(beanName)) {
        throw new IllegalStateException("Singleton '" + beanName + "' isn't currently in creation");
    }
}
```

（12）回到AbstractBeanFactory类的doGetBean(String name, Class<T> requiredType, Object[] args, boolean typeCheckOnly)方法

```java
if (mbd.isSingleton()) {
    sharedInstance = getSingleton(beanName, () -> {
        try {
            return createBean(beanName, mbd, args);
        }
        catch (BeansException ex) {
            destroySingleton(beanName);
            throw ex;
        }
    });
    beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
}
```

（13）解析AbstractAutowireCapableBeanFactory类的createBean(String beanName, RootBeanDefinition mbd, Object[] args)方法

```java
@Override
protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
    throws BeanCreationException {
	//##############省略其他代码############
		try {
			// 创建bean实例
			Object beanInstance = doCreateBean(beanName, mbdToUse, args);
			// 如果开启了trace级别的日志
			if (logger.isTraceEnabled()) {
				// 输出创建bean实例完成的日志
				logger.trace("Finished creating instance of bean '" + beanName + "'");
			}
			// 返回bean实例
			return beanInstance;
		}
   //##############省略其他代码############
}
```

在createBean()方法中，只是做了一些准备工作，并没有真正的创建Bean对象，真正创建Bean对象是在doCreateBean()方法中完成的。

（14）解析AbstractAutowireCapableBeanFactory类的doCreateBean(String beanName, RootBeanDefinition mbd, Object[] args)方法

```java
protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
    throws BeanCreationException {

    // 实例化bean
    // Instantiate the bean.
    BeanWrapper instanceWrapper = null;
    // 如果bean是单例的
    if (mbd.isSingleton()) {
        // 从factoryBeanInstanceCache中移除bean的实例包装器
        instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
    }
    // 如果实例包装器为空
    if (instanceWrapper == null) {
        // 创建bean的实例包装器
        instanceWrapper = createBeanInstance(beanName, mbd, args);
    }
    // 获取bean的实例
    Object bean = instanceWrapper.getWrappedInstance();
    // 获取bean的类型
    Class<?> beanType = instanceWrapper.getWrappedClass();
    // 如果bean的类型不是NullBean类
    if (beanType != NullBean.class) {
        // 设置解析后的目标类型
        mbd.resolvedTargetType = beanType;
    }

    // 允许后处理器修改合并后的bean定义
    // Allow post-processors to modify the merged bean definition.
    synchronized (mbd.postProcessingLock) {
        if (!mbd.postProcessed) {
            try {
                // 应用合并后的bean定义后处理器
                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
            }
            catch (Throwable ex) {
                throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                                // 合并后的bean定义后处理失败
                                                "Post-processing of merged bean definition failed", ex);
            }
            // 标记为已后处理
            mbd.markAsPostProcessed();
        }
    }

    // 提前缓存单例对象，以便能够解决由生命周期接口（如BeanFactoryAware）触发的循环引用问题
    // Eagerly cache singletons to be able to resolve circular references
    // even when triggered by lifecycle interfaces like BeanFactoryAware.
    boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
                                      isSingletonCurrentlyInCreation(beanName));
    if (earlySingletonExposure) {
        // 如果允许提前暴露单例对象
        if (logger.isTraceEnabled()) {
            // 输出日志，表示正在提前缓存bean对象以解析潜在的循环引用问题
            logger.trace("Eagerly caching bean '" + beanName +
                         "' to allow for resolving potential circular references");
        }
        // 将beanName和获取早期bean引用的lambda表达式添加到单例工厂中
        addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
    }

    // 初始化bean实例
    // Initialize the bean instance.
    Object exposedObject = bean;
    try {
        // 为bean填充属性
        populateBean(beanName, mbd, instanceWrapper);
        // 初始化bean
        exposedObject = initializeBean(beanName, exposedObject, mbd);
    }
    catch (Throwable ex) {
        // 如果异常是BeanCreationException且异常中的beanName与当前beanName相同
        if (ex instanceof BeanCreationException bce && beanName.equals(bce.getBeanName())) {
            // 抛出该异常
            throw bce;
        }
        else {
            // 否则，将异常封装为BeanCreationException并抛出
            throw new BeanCreationException(mbd.getResourceDescription(), beanName, ex.getMessage(), ex);
        }
    }

    if (earlySingletonExposure) {
        // 获取早期单例对象的引用
        Object earlySingletonReference = getSingleton(beanName, false);
        if (earlySingletonReference != null) {
            if (exposedObject == bean) {
                // 如果当前暴露的对象和原始的bean相同，则更新暴露对象为早期单例对象引用
                exposedObject = earlySingletonReference;
            } else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {
                // 获取依赖当前bean的其他bean的名称
                String[] dependentBeans = getDependentBeans(beanName);
                Set<String> actualDependentBeans = new LinkedHashSet<>(dependentBeans.length);
                for (String dependentBean : dependentBeans) {
                    // 如果依赖的bean不是仅用于类型检查的，则添加到实际依赖的bean集合中
                    if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                        actualDependentBeans.add(dependentBean);
                    }
                }
                if (!actualDependentBeans.isEmpty()) {
                    // 如果存在实际依赖的bean，则抛出异常，表示循环依赖的问题
                    // 省略异常信息
                }
            }
        }
    }


    // 注册bean为可销毁的bean
    // Register bean as disposable.
    try {
        // 如果需要，将bean注册为可销毁的bean
        registerDisposableBeanIfNecessary(beanName, bean, mbd);
    }
    catch (BeanDefinitionValidationException ex) {
        // 抛出BeanCreationException异常，包含资源描述、bean名称、错误信息以及原始异常
        throw new BeanCreationException(
            mbd.getResourceDescription(), beanName, "Invalid destruction signature", ex);
    }
    // 返回暴露的对象
    return exposedObject;
}
```

doCreateBean()方法的逻辑大体的流程如下：

* 调用createBeanInstance()方法创建bean。

* 调用属于applyMergedBeanDefinitionPostProcessors()方法。对Bean进行一些处理。
* 将bean加入到三级缓存中。
* 填充Bean需要注入的其他Bean对象。
* 调用初始化方法，先去调用@PostConstruct注解方法，然后调用InitializingBean的afterPropertiesSet，以及自定义的init-method方法。在Bean调用初始化方法之后，再去调用后置处理器接口检测是否需要生成Aop代理。
* 接着进行校验。如果从二级缓存能取到，那就说明之前已经从三级缓存获取过。可能是因为循环依赖，也可能是因为别的地方调用了getBean方法。从三级缓存获取时有个getEarlyBeanReference()的方法，就是查看是否要生成代理的bean。如果已经生成代理的Bean，那么在调用初始化方法时，就不会在生成代理Bean了。这样满足exposedObject ==bean，直接只用代理返回。

* 如果exposedObject和bean不相等：这里的情况就是：如果是spring的@Async注解，在从二级缓存生成代理之后，再去调用初始化方法时，一样会生成代理。所以此时exposedObject不等于bean，再往下发现有循环调用，并且Bean还在创建时，就会抛出异常。

### 思考

#### 1.**Spring为何会有循环依赖的问题？**

Spring的循环依赖问题指的是两个或多个Bean在创建过程中互相引用对方，形成了一个闭环，导致无法完成创建。这种情况通常发生在属性注入的情况下。例如，A类依赖B类，B类又依赖A类。在Spring容器初始化时，如果按顺序创建这两个Bean，当创建A时需要注入B，而B还未创建完成，因为B又需要A，这就形成了一个循环依赖。

#### 2.**Spring如何解决循环依赖问题？**

Spring通过使用三级缓存来解决循环依赖问题：

1. **一级缓存（singletonObjects）**：存放已经初始化完成的Bean。
2. **二级缓存（earlySingletonObjects）**：存放早期的Bean引用，即已经实例化但未初始化的Bean。
3. **三级缓存（singletonFactories）**：存放能够生成Bean的工厂对象。

当A类创建时，首先将其工厂对象放入三级缓存，在实例化A后，将A的早期引用放入二级缓存，并从三级缓存中移除其工厂对象。当A需要注入B时，发现B还未创建，就去创建B。B在创建过程中需要A，这时就可以从二级缓存中获取A的早期引用注入B，从而打破了循环依赖。

#### 3.**Spring为何使用三级缓存解决循环依赖问题？使用二级缓存不行吗？为什么？**

使用二级缓存在某些情况下可能无法解决循环依赖问题，特别是涉及到AOP时。三级缓存中存放的是Bean工厂对象，这个工厂能够生成代理对象。如果只有二级缓存，那么当A类需要被代理时（比如使用了@Transactional注解），在注入B类时就直接注入了A的原始对象，而不是代理对象，这会导致AOP功能失效。三级缓存确保了即使在循环依赖的情况下，也能返回正确的代理对象。当B类尝试获取A类时，可以从三级缓存中得到一个工厂对象，这个工厂在必要时能够生成A的代理，保证了AOP能够正常工作。



## 1.5 @Import注解

@Import注解可以将第三方包中的类对象注入到IOC容器中。Spring底层大量使用了@Import注解来向IOC容器中注入Bean对象。

@Import注解只能标注到类或其他注解上，通常与配置类一起使用的，使用此注解引入的类上可以不再使用@Configuration，@Component等注解标注。

### 注解源码

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Import {
	Class<?>[] value();
}
```

* value：Class数组类型，用于指定其他配置类的字节码，支持指定多个配置类。另外value属性指定的必须是普通类、实现了ImportSelector接口的类和实现了ImportBeanDefinitionRegistrar接口的类。

**注意：@Import注解只能标注到类上。**



### 源码时序图

![图5-1](https://upload.yolo912.icu/mdImage/spring-core-2023-02-24-001.png)

![图5-2](https://upload.yolo912.icu/mdImage/spring-core-2023-02-24-002.png)

![图5-3](https://upload.yolo912.icu/mdImage/spring-core-2023-02-24-003.png)

### 源码解析

（1）运行ImportTest类的main()方法中，调用了AnnotationConfigApplicationContext类的构造方法，并传入了ImportConfig类的Class对象来创建IOC容器。接下来，会进入AnnotationConfigApplicationContext类的构造方法。

（2）解析AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext(Class<?>... componentClasses)构造方法

```java
public AnnotationConfigApplicationContext(Class<?>... componentClasses) {
    this();
    register(componentClasses);
    refresh();
}
```

（3）解析AbstractApplicationContext类的refresh()方法

```java
@Override
public void refresh() throws BeansException, IllegalStateException {
    synchronized (this.startupShutdownMonitor) {
        //############省略其他代码##############
        try {
            //############省略其他代码##############
            invokeBeanFactoryPostProcessors(beanFactory);
           //############省略其他代码##############
        }catch (BeansException ex) {
            //############省略其他代码##############
        }finally {
            //############省略其他代码##############
        }
    }
}
```

（4）解析AbstractApplicationContext类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory)方法

```java
protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
    if (!NativeDetector.inNativeImage() && beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
        beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
        beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
    }
}
```

（5）解析PostProcessorRegistrationDelegate类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors)方法

核心的逻辑如下：

```java
public static void invokeBeanFactoryPostProcessors(
    ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {

    //############省略其他代码##############
    List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();

    // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
    String[] postProcessorNames =
        beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
    for (String ppName : postProcessorNames) {
        if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
        }
    }
    sortPostProcessors(currentRegistryProcessors, beanFactory);
    registryProcessors.addAll(currentRegistryProcessors);
    invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());
    currentRegistryProcessors.clear();

    // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
    postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
    for (String ppName : postProcessorNames) {
        if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
        }
    }
    sortPostProcessors(currentRegistryProcessors, beanFactory);
    registryProcessors.addAll(currentRegistryProcessors);
    invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());
    currentRegistryProcessors.clear();

    // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
    boolean reiterate = true;
    while (reiterate) {
        reiterate = false;
        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
        for (String ppName : postProcessorNames) {
            if (!processedBeans.contains(ppName)) {
                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                processedBeans.add(ppName);
                reiterate = true;
            }
        }
        sortPostProcessors(currentRegistryProcessors, beanFactory);
        registryProcessors.addAll(currentRegistryProcessors);
        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());
        currentRegistryProcessors.clear();
    }
    //############省略其他代码##############
}
```

（6）解析PostProcessorRegistrationDelegate类的invokeBeanDefinitionRegistryPostProcessors(Collection<? extends BeanDefinitionRegistryPostProcessor> postProcessors, BeanDefinitionRegistry registry, ApplicationStartup applicationStartup)方法

```java
private static void invokeBeanDefinitionRegistryPostProcessors(
    Collection<? extends BeanDefinitionRegistryPostProcessor> postProcessors, BeanDefinitionRegistry registry, ApplicationStartup applicationStartup) {

    for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {
        StartupStep postProcessBeanDefRegistry = applicationStartup.start("spring.context.beandef-registry.post-process")
            .tag("postProcessor", postProcessor::toString);
        postProcessor.postProcessBeanDefinitionRegistry(registry);
        postProcessBeanDefRegistry.end();
    }
}
```

（7）解析ConfigurationClassPostProcessor类的postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)方法

```java
@Override
public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
	//##########省略其他代码###################
    processConfigBeanDefinitions(registry);
}
```

（8）解析ConfigurationClassPostProcessor类的processConfigBeanDefinitions(BeanDefinitionRegistry registry)方法

重点逻辑如下：

```java
public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
    //############省略其他代码#################
    // Parse each @Configuration class
    ConfigurationClassParser parser = new ConfigurationClassParser(
        this.metadataReaderFactory, this.problemReporter, this.environment,
        this.resourceLoader, this.componentScanBeanNameGenerator, registry);
    
    Set<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);
    Set<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());
    do {
        StartupStep processConfig = this.applicationStartup.start("spring.context.config-classes.parse");
        parser.parse(candidates);
        parser.validate();
        //############省略其他代码#################
        this.reader.loadBeanDefinitions(configClasses);
        alreadyParsed.addAll(configClasses);
        processConfig.tag("classCount", () -> String.valueOf(configClasses.size())).end();
        //############省略其他代码#################
    }
    while (!candidates.isEmpty());
    //############省略其他代码#################
}
```

在processConfigBeanDefinitions()方法中，创建了一个ConfigurationClassParser类型的对象parser，并且调用了parser的parse()方法来解析类的配置信息。

（9）解析ConfigurationClassParser类的parse(Set<BeanDefinitionHolder> configCandidates)方法

```java
public void parse(Set<BeanDefinitionHolder> configCandidates) {
    for (BeanDefinitionHolder holder : configCandidates) {
        BeanDefinition bd = holder.getBeanDefinition();
        try {
            if (bd instanceof AnnotatedBeanDefinition) {
                parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
            }
            //###############省略其他代码###############
        }
        catch (BeanDefinitionStoreException ex) {
            throw ex;
        }
        catch (Throwable ex) {
            throw new BeanDefinitionStoreException(
                "Failed to parse configuration class [" + bd.getBeanClassName() + "]", ex);
        }
    }
    this.deferredImportSelectorHandler.process();
}
```

（10）解析ConfigurationClassParser类的parse(AnnotationMetadata metadata, String beanName)方法

```java
protected final void parse(AnnotationMetadata metadata, String beanName) throws IOException {
    processConfigurationClass(new ConfigurationClass(metadata, beanName), DEFAULT_EXCLUSION_FILTER);
}
```

（11）解析ConfigurationClassParser类的processConfigurationClass(ConfigurationClass configClass, Predicate<String> filter)方法

```java
protected void processConfigurationClass(ConfigurationClass configClass, Predicate<String> filter) throws IOException {
    //###############省略其他代码####################
    SourceClass sourceClass = asSourceClass(configClass, filter);
    do {
        sourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);
    }
    while (sourceClass != null);
    this.configurationClasses.put(configClass, configClass);
}
```

在processConfigurationClass()方法中，会通过do-while()循环获取配置类和其父类的注解信息，SourceClass类中会封装配置类上注解的详细信息。

（12）解析ConfigurationClassParser类的doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)方法

重点代码片段如下：

```java
protected final SourceClass doProcessConfigurationClass(
    ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)
    throws IOException {
	 //#############省略其他代码#############
    // Process any @Import annotations
    processImports(configClass, sourceClass, getImports(sourceClass), filter, true);
    //#############省略其他代码#############
    // No superclass -> processing is complete
    return null;
}
```

在doProcessConfigurationClass()方法中，会调用processImports()方法来解析@Import注解。

（13）解析ConfigurationClassParser类的processImports(ConfigurationClass configClass, SourceClass currentSourceClass, Collection<SourceClass> importCandidates, Predicate<String> exclusionFilter, boolean checkForCircularImports)方法。

```java
private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass,
                            Collection<SourceClass> importCandidates, Predicate<String> exclusionFilter,
                            boolean checkForCircularImports) {
	//################省略其他代码#################
    this.importStack.push(configClass);
    try {
        for (SourceClass candidate : importCandidates) {
            // 引入的是实现了ImportSelector接口的类
            if (candidate.isAssignable(ImportSelector.class)) {
                // Candidate class is an ImportSelector -> delegate to it to determine imports
                Class<?> candidateClass = candidate.loadClass();
                ImportSelector selector = ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class, this.environment, this.resourceLoader, this.registry);
                Predicate<String> selectorFilter = selector.getExclusionFilter();
                if (selectorFilter != null) {
                    exclusionFilter = exclusionFilter.or(selectorFilter);
                }
                if (selector instanceof DeferredImportSelector) {
                    this.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector);
                }
                else {
                    // 调用ImportSelector接口的selectImports()方法获取要注入到IOC容器中的Bean名称数组
                    String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
                    Collection<SourceClass> importSourceClasses = asSourceClasses(importClassNames, exclusionFilter);
                    processImports(configClass, currentSourceClass, importSourceClasses, exclusionFilter, false);
                }
            }
            // 引入的是实现了ImportBeanDefinitionRegistrar接口的类
            else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
                // Candidate class is an ImportBeanDefinitionRegistrar ->
                // delegate to it to register additional bean definitions
                Class<?> candidateClass = candidate.loadClass();
                ImportBeanDefinitionRegistrar registrar =
                    ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class,
                                                         this.environment, this.resourceLoader, this.registry);
                configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
            }
            else {
                // Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar ->
                // process it as an @Configuration class
                this.importStack.registerImport(
                    currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
                processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter);
            }
        }
    }
    catch (BeanDefinitionStoreException ex) {
        throw ex;
    }
    catch (Throwable ex) {
        throw new BeanDefinitionStoreException(
            "Failed to process import candidates for configuration class [" +
            configClass.getMetadata().getClassName() + "]: " + ex.getMessage(), ex);
    }
    finally {
        this.importStack.pop();
    }
}
```

在processImports()方法中，如果使用@Import注解引入的是实现了ImportSelector接口的类，则执行的是` if (candidate.isAssignable(ImportSelector.class)) `条件的逻辑。如果@Import注解引入的是实现了ImportBeanDefinitionRegistrar接口的类，则执行的是` else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class))`条件的逻辑，否则执行的是`else`条件的逻辑。

其中，执行`  if (selector instanceof DeferredImportSelector) { `条件的逻辑时，会调用ImportSelector接口的selectImports()方法获取要注入到IOC容器中的Bean名称数组，如下所示。

```java
String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
```

调用ImportSelector接口的selectImports()方法时，就会调用案例程序中的MyImportSelector类的selectImports()方法。

（14）解析MyImportSelector类的selectImports(AnnotationMetadata importingClassMetadata)方法

```java
@Override
public String[] selectImports(AnnotationMetadata importingClassMetadata) {
    return new String[]{ImportSelectorBean.class.getName()};
}
```

在MyImportSelector类的selectImports()方法中，会返回包含ImportSelectorBean类的全类名的String数组，后续会将ImportSelectorBean类的Bean对象注入IOC容器。

（15）回到ConfigurationClassParser类的processImports(ConfigurationClass configClass, SourceClass currentSourceClass, Collection<SourceClass> importCandidates, Predicate<String> exclusionFilter, boolean checkForCircularImports)方法。

如果@Import注解引入的是实现了ImportBeanDefinitionRegistrar接口的类，则执行的是` else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class))`条件的逻辑，如下所示。

```java
else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
    Class<?> candidateClass = candidate.loadClass();
    ImportBeanDefinitionRegistrar registrar =
        ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class, this.environment, this.resourceLoader, this.registry);
    configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
}
```

在上述代码逻辑中会调用configClass的addImportBeanDefinitionRegistrar()方法来添加ImportBeanDefinitionRegistrar对象。

（16）解析ConfigurationClass类的addImportBeanDefinitionRegistrar(ImportBeanDefinitionRegistrar registrar, AnnotationMetadata importingClassMetadata)方法

```java
void addImportBeanDefinitionRegistrar(ImportBeanDefinitionRegistrar registrar, AnnotationMetadata importingClassMetadata) {
    this.importBeanDefinitionRegistrars.put(registrar, importingClassMetadata);
}
```

在addImportBeanDefinitionRegistrar()方法中，会将传入的registrar参数作为Key，importingClassMetadata参数作为Value存储importBeanDefinitionRegistrars结构中。

importBeanDefinitionRegistrars结构的定义如下所示。

```java
private final Map<ImportBeanDefinitionRegistrar, AnnotationMetadata> importBeanDefinitionRegistrars = new LinkedHashMap<>();
```

importBeanDefinitionRegistrars是一个LinkedHashMap对象，也就是会将ImportBeanDefinitionRegistrar对象和AnnotationMetadata对象的映射关系存入一个LinkedHashMap对象中。

（17）再次回到ConfigurationClassParser类的processImports(ConfigurationClass configClass, SourceClass currentSourceClass, Collection<SourceClass> importCandidates, Predicate<String> exclusionFilter, boolean checkForCircularImports)方法。

如果@Import注解引入的类既没有实现ImportSelector接口，又没有实现ImportBeanDefinitionRegistrar接口，则执行`else`逻辑

```java
else {
    this.importStack.registerImport(
        currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
    processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter);
}
```

在`else`逻辑中，会按照解析@Configuration注解的逻辑执行

其实，在processImports()方法中，如果@Import注解引入的类实现了ImportSelector接口，并且没有实现DeferredImportSelector接口的话，最终还是会执行processImports()方法的`else`逻辑。

（18）回到ConfigurationClassPostProcessor类的processConfigBeanDefinitions(BeanDefinitionRegistry registry)方法。

在ConfigurationClassPostProcessor类的processConfigBeanDefinitions()方法中，执行完ConfigurationClassParser类的parse()方法后，会执行ConfigurationClassBeanDefinitionReader类的loadBeanDefinitions()方法，如下所示。

```java
this.reader.loadBeanDefinitions(configClasses);
```

（19）解析ConfigurationClassBeanDefinitionReader类的loadBeanDefinitions(Set<ConfigurationClass> configurationModel)方法

```java
public void loadBeanDefinitions(Set<ConfigurationClass> configurationModel) {
    TrackedConditionEvaluator trackedConditionEvaluator = new TrackedConditionEvaluator();
    for (ConfigurationClass configClass : configurationModel) {
        loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);
    }
}
```

在loadBeanDefinitions()方法中，会循环遍历传入的configurationModel集合，并调用loadBeanDefinitionsForConfigurationClass()方法处理遍历的每个元素。

（20）解析ConfigurationClassBeanDefinitionReader类的loadBeanDefinitionsForConfigurationClass(ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator)方法

```java
private void loadBeanDefinitionsForConfigurationClass(ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) {
    //################省略其他代码######################
    if (configClass.isImported()) {
        registerBeanDefinitionForImportedConfigurationClass(configClass);
    }
    for (BeanMethod beanMethod : configClass.getBeanMethods()) {
        loadBeanDefinitionsForBeanMethod(beanMethod);
    }

    loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());
    loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());
}
```

在loadBeanDefinitionsForConfigurationClass()方法中，如果@Import注解引入的是普通的类，或者是实现了ImportSelector接口的类，则会执行`if (configClass.isImported())`条件的逻辑，此时会调用registerBeanDefinitionForImportedConfigurationClass()方法向IOC容器中注入配置类的BeanDefinition信息。

（21）解析ConfigurationClassBeanDefinitionReader类的registerBeanDefinitionForImportedConfigurationClass(ConfigurationClass configClass)方法

```java
private void registerBeanDefinitionForImportedConfigurationClass(ConfigurationClass configClass) {
    //###############省略其他代码#################
    BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(configBeanDef, configBeanName);
    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
  this.registry.registerBeanDefinition(definitionHolder.getBeanName(),definitionHolder.getBeanDefinition());
    configClass.setBeanName(configBeanName);
	//###############省略其他代码#################
}
```

在registerBeanDefinitionForImportedConfigurationClass()方法中会调用DefaultListableBeanFactory类的registerBeanDefinition()方法向IOC容器中注入BeanDefinition信息。最终，会将BeanDefinition信息保存到DefaultListableBeanFactory类的beanDefinitionMap中。

（22）回到ConfigurationClassBeanDefinitionReader类的loadBeanDefinitionsForConfigurationClass(ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator)方法

如果@Import注解引入的是实现了ImportBeanDefinitionRegistrar接口的类，则在loadBeanDefinitionsForConfigurationClass()方法中调用loadBeanDefinitionsFromRegistrars()方法时，会通过configClass的getImportBeanDefinitionRegistrars()方法获取第（16）步保存信息的LinkedHashMap对象。

（23）解析ConfigurationClass类的getImportBeanDefinitionRegistrars()方法

```java
Map<ImportBeanDefinitionRegistrar, AnnotationMetadata> getImportBeanDefinitionRegistrars() {
    return this.importBeanDefinitionRegistrars;
}
```

（24）再次ConfigurationClassBeanDefinitionReader类的loadBeanDefinitionsForConfigurationClass(ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator)方法。

在loadBeanDefinitionsForConfigurationClass()会调用loadBeanDefinitionsFromRegistrars()方法从实现了ImportBeanDefinitionRegistrar接口的类中加载Bean定义信息。

（25）解析ConfigurationClassBeanDefinitionReader类的loadBeanDefinitionsFromRegistrars(Map<ImportBeanDefinitionRegistrar, AnnotationMetadata> registrars)方法

```java
private void loadBeanDefinitionsFromRegistrars(Map<ImportBeanDefinitionRegistrar, AnnotationMetadata> registrars) {
    registrars.forEach((registrar, metadata) -> registrar.registerBeanDefinitions(metadata, this.registry, this.importBeanNameGenerator));
}
```

在loadBeanDefinitionsFromRegistrars()方法中，会遍历传入的registrars，并调用每个registrar的registerBeanDefinitions()方法注册BeanDefinition信息。

（26）解析ImportBeanDefinitionRegistrar接口的registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry,BeanNameGenerator importBeanNameGenerator)方法

```java
default void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry,BeanNameGenerator importBeanNameGenerator) {
    registerBeanDefinitions(importingClassMetadata, registry);
}
```

registerBeanDefinitions()方法是ImportBeanDefinitionRegistrar接口的一个默认方法，并在方法中调用了另一个registerBeanDefinitions()方法。其中调用的这个registerBeanDefinitions()方法就是我们自己实现了ImportBeanDefinitionRegistrar接口的类中具体实现的registerBeanDefinitions()方法。

（27）解析MyImportBeanDefinitionRegistrar类的registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)方法

```java
@Override
public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
    String beanName = ImportBeanDefinitionRegistrarBean.class.getName();
    BeanDefinition beanDefinition = new RootBeanDefinition(ImportBeanDefinitionRegistrarBean.class);
    registry.registerBeanDefinition(beanName, beanDefinition);
}
```

在registerBeanDefinitions()方法中，最终会调用DefaultListableBeanFactory类的registerBeanDefinition()方法向IOC容器中注入BeanDefinition信息。最终会将BeanDefinition信息保存到DefaultListableBeanFactory类的beanDefinitionMap中。

### 思考

#### 1. 在ConfigurationClassParser类的processImports()中，如果@Import注解引入的是普通类或者引入的是实现了ImportSelector接口，并且没有实现DeferredImportSelector接口的类，最终还是会执行processImports()方法的`else`逻辑。那么最终是如何执行`else`逻辑的？

当`@Import`注解引入的是普通类或者引入的是实现了`ImportSelector`接口且没有实现`DeferredImportSelector`接口的类时，以下是一般会发生的过程：

1. `processImports()`方法会检查通过`@Import`注解引入的类。
2. 如果引入的类不是`ImportSelector`或者`ImportBeanDefinitionRegistrar`，那么它将被视为一个普通的配置类。
3. 对于实现了`ImportSelector`接口的类，如果它没有实现`DeferredImportSelector`接口，那么它的`selectImports()`方法会被调用以返回一个字符串数组，这些字符串代表了需要被导入的配置类的名称。
4. 对于每个通过`selectImports()`返回的配置类名称，Spring会尝试加载这些类，并递归地调用`processImports()`方法处理这些新加载的配置类。



#### 2. @Import注解的三种案例在Spring底层的源码执行流程分别是什么？

1. **直接导入配置类**：
   - Spring直接解析导入的类，将其视为配置类，并处理其上的注解（如@Bean、@Import等）。
2. **导入实现了ImportSelector接口的类**：
   - 实例化ImportSelector实现类。
   - 调用其`selectImports()`方法获取要导入的类名或配置类。
   - 对这些类进行解析和处理。
3. **导入实现了DeferredImportSelector接口的类**：
   - 与ImportSelector类似，但DeferredImportSelector允许导入操作被延迟到所有常规的ImportSelector和@Configuration类都被处理之后。
   - 这在需要基于其他Bean的存在性条件导入Bean时特别有用

#### 3. 使用@Import注解向IOC容器中注入Bean与使用@Bean注解有什么区别？

- **@Import**：用于导入配置类，可以导入一个或多个类，这些类可以包含@Bean注解定义的Bean，或者它们自身是ImportSelector/DeferredImportSelector的实现，用于动态选择Bean的导入。它主要用于模块化和重用配置。
- **@Bean**：在配置类中声明一个Bean，并指定其创建逻辑（通过方法）。它允许更细粒度地控制Bean的创建过程，包括依赖注入、初始化等。



## 1.6 @PropertySource注解

@PropertySource注解是Spring中提供的一个通过指定配置文件位置来加载配置文件的注解，并且可以将配置文件中的内容存放到Spring的环境变量中。除了可以通过Spring的环境变量读取配置项之外，还可以通过@Value注解获取配置项的值。另外，Spring中还提供了一个@PropertySources注解，在@PropertySources注解注解中，可以引入多个@PropertySource注解。

### 注解源码

**1.@PropertySource注解**

@PropertySource注解只能标注到类上，能够通过指定配置文件的位置来加载配置文件，@PropertySource注解除了可以加载properties配置文件外，也可以加载xml配置文件和yml配置文件。如果加载yml配置文件时，可以自定义PropertySourceFactory实现yml配置文件的解析操作。

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Repeatable(PropertySources.class)
public @interface PropertySource {
	String name() default "";
	String[] value();
	/**
	 * @since 4.0
	 */
	boolean ignoreResourceNotFound() default false;
	/**
	 * @since 4.3
	 */
	String encoding() default "";
	/**
	 * @since 4.3
	 */
	Class<? extends PropertySourceFactory> factory() default PropertySourceFactory.class;
}
```

注解中各个属性的含义如下所示。

* name：表示加载的资源的名称，如果为空，则会根据加载的配置文件自动生成一个名称。
* value：表示加载的资源的路径，这个路径可以是类路径，也可以是文件路径。
* ignoreResourceNotFound：表示当配置文件未找到时，是否忽略文件未找到的错误。默认值为false，也就是说当未找到配置文件时，Spring启动就会报错。
* encoding：表示解析配置文件使用的字符集编码。
* factory：表示读取对应配置文件的工厂类，默认的工厂类是PropertySourceFactory。

**2.@PropertySources注解**

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface PropertySources {
	PropertySource[] value();
}
```

提供了一个PropertySource数组类型的value属性。@PropertySources注解可引入多个@PropertySource注解。

### 源码时序图

![图6-1](https://upload.yolo912.icu/mdImage/spring-core-2023-02-25-001.png)

![图6-2](https://upload.yolo912.icu/mdImage/spring-core-2023-02-25-002.png)

### 源码解析

（1）运行PropertySourceTest类的main()方法，调用了AnnotationConfigApplicationContext类的构造方法并传入了PropertySourceConfig类的Class对象来创建IOC容器。

**@PropertySource注解在Spring源码中的执行流程的（2）~（11）步与@Import注解相同，这里直接跳到ConfigurationClassParser类的doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)方法。**

（2）解析ConfigurationClassParser类的doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)方法

```java
protected final SourceClass doProcessConfigurationClass(
    ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)
    throws IOException {
    //#############省略其他代码################
    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
        sourceClass.getMetadata(), PropertySources.class,
        org.springframework.context.annotation.PropertySource.class)) {
        if (this.propertySourceRegistry != null) {
            this.propertySourceRegistry.processPropertySource(propertySource);
        }
    }
	//#############省略其他代码################
}
```

在ConfigurationClassParser类的doProcessConfigurationClass()方法中，遍历获取到的@PropertySources注解和@PropertySource注解的属性，并且调用propertySourceRegistry对象的processPropertySource()方法解析注解属性的值。

（3）解析PropertySourceRegistry类的processPropertySource(AnnotationAttributes propertySource)方法

```java
void processPropertySource(AnnotationAttributes propertySource) throws IOException {
    String name = propertySource.getString("name");
    if (!StringUtils.hasLength(name)) {
        name = null;
    }
    String encoding = propertySource.getString("encoding");
    if (!StringUtils.hasLength(encoding)) {
        encoding = null;
    }
    String[] locations = propertySource.getStringArray("value");
    Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required");
    boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound");
    Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory");
    Class<? extends PropertySourceFactory> factorClassToUse = (factoryClass != PropertySourceFactory.class ? factoryClass : null);
    PropertySourceDescriptor descriptor = new PropertySourceDescriptor(Arrays.asList(locations), ignoreResourceNotFound, name, factorClassToUse, encoding);
    this.propertySourceProcessor.processPropertySource(descriptor);
    this.descriptors.add(descriptor);
}
```

在PropertySourceRegistry类的processPropertySource()方法中，解析@PropertySource注解中的属性后，将解析出的属性值封装到PropertySourceDescriptor对象中，调用propertySourceProcessor对象的processPropertySource()方法，并传入PropertySourceDescriptor对象进行进一步处理。

（4）解析PropertySourceProcessor类的processPropertySource(PropertySourceDescriptor descriptor)方法

```java
public void processPropertySource(PropertySourceDescriptor descriptor) throws IOException {
    String name = descriptor.name();
    String encoding = descriptor.encoding();
    List<String> locations = descriptor.locations();
    Assert.isTrue(locations.size() > 0, "At least one @PropertySource(value) location is required");
    boolean ignoreResourceNotFound = descriptor.ignoreResourceNotFound();
    PropertySourceFactory factory = (descriptor.propertySourceFactory() != null ? instantiateClass(descriptor.propertySourceFactory()) : DEFAULT_PROPERTY_SOURCE_FACTORY);
    for (String location : locations) {
        try {
            String resolvedLocation = this.environment.resolveRequiredPlaceholders(location);
            Resource resource = this.resourceLoader.getResource(resolvedLocation);
            addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)));
        }
        catch (IllegalArgumentException | FileNotFoundException | UnknownHostException | SocketException ex) {
			//#########省略其他代码################
        }
    }
}
```

在processPropertySource()方法中，会通过@PropertySource注解的属性值解析出配置文件的内容，并且通过factory对象的createPropertySource()方法来创建PropertySource对象。

（5）解析DefaultPropertySourceFactory类的createPropertySource(String name, EncodedResource resource)方法

```java
@Override
public PropertySource<?> createPropertySource(String name, EncodedResource resource) throws IOException {
    return (name != null ? new ResourcePropertySource(name, resource) : new ResourcePropertySource(resource));
}
```

（6）回到PropertySourceProcessor类的processPropertySource(PropertySourceDescriptor descriptor)方法

在PropertySourceProcessor类的processPropertySource()方法中，创建完PropertySource对象后，会调用addPropertySource()方法将获取到的属性值添加到Spring的环境变量中。

（7）解析PropertySourceProcessor类的addPropertySource(PropertySource<?> propertySource)方法

```java
private void addPropertySource(org.springframework.core.env.PropertySource<?> propertySource) {
    String name = propertySource.getName();
    MutablePropertySources propertySources = this.environment.getPropertySources();
    if (this.propertySourceNames.contains(name)) {
        org.springframework.core.env.PropertySource<?> existing = propertySources.get(name);
        if (existing != null) {
            PropertySource<?> newSource = (propertySource instanceof ResourcePropertySource ?((ResourcePropertySource) propertySource).withResourceName() : propertySource);
            if (existing instanceof CompositePropertySource) {
                ((CompositePropertySource) existing).addFirstPropertySource(newSource);
            }
            else {
                if (existing instanceof ResourcePropertySource) {
                    existing = ((ResourcePropertySource) existing).withResourceName();
                }
                CompositePropertySource composite = new CompositePropertySource(name);
                composite.addPropertySource(newSource);
                composite.addPropertySource(existing);
                propertySources.replace(name, composite);
            }
            return;
        }
    }
    if (this.propertySourceNames.isEmpty()) {
        propertySources.addLast(propertySource);
    }
    else {
        String firstProcessed = this.propertySourceNames.get(this.propertySourceNames.size() - 1);
        propertySources.addBefore(firstProcessed, propertySource);
    }
    this.propertySourceNames.add(name);
}
```

在PropertySourceProcessor类的addPropertySource()方法中，会将解析出的配置文件的内容添加到Spring的环境变量中。具体就是在PropertySourceProcessor类的addPropertySource()方法中，获取到ConfigurableEnvironment中的MutablePropertySources对象，用来存储解析出的配置文件中的配置项内容。如果有相同的配置项内容，将existing对象强转为CompositePropertySource类型，把新旧相同的配置项进行合并，再放到MutablePropertySources对象中。后续就可以通过Spring的环境变量，来获取到配置文件中的配置项内容。

### 思考

#### 1. @PropertySource注解的执行流程

@PropertySource注解的执行流程主要涉及Spring框架在启动时如何处理和加载配置文件。执行流程：

1. **配置类扫描**：Spring容器在启动时，会扫描所有带有@Configuration、@Component等注解的类，以发现配置信息。
2. **注解识别**：在扫描到的配置类中，Spring会识别@PropertySource注解。该注解用于指定一个或多个属性文件的位置。
3. **加载配置文件**：根据@PropertySource注解中指定的路径（如classpath:config.properties），Spring会尝试加载这些配置文件。如果指定了多个文件，Spring会按照声明的顺序加载它们。
4. **解析配置文件**：加载配置文件后，Spring会解析文件中的配置项，将它们作为键值对存储在内存中。
5. **添加到环境变量**：解析出的配置项会被添加到Spring的环境变量（Environment）中，这样它们就可以在应用程序的任何地方通过占位符（如${app.name}）来访问了。
6. **属性注入**：在配置类或其他组件中，可以通过@Value注解将环境变量中的配置项注入到字段、方法参数或构造函数参数中。

#### 2. @PropertySource注解是如何将配置文件加载到环境变量的？

@PropertySource注解通过以下步骤将配置文件加载到Spring的环境变量中：

1. **注解声明**：在配置类上使用@PropertySource注解，并指定配置文件的位置。
2. **配置加载**：Spring容器在启动时，会识别并使用PropertySourceLoader（默认是DefaultPropertySourceLoader）来加载@PropertySource注解指定的配置文件。
3. **解析与存储**：加载的配置文件会被解析成一系列的键值对，并作为PropertySource对象存储在Spring的环境变量（ConfigurableEnvironment）中。每个PropertySource对象都有一个唯一的名称，用于区分不同的配置源。
4. **环境变量集成**：最终，这些PropertySource对象会被集成到Spring的环境变量中，使得应用程序可以通过环境变量接口（如Environment接口）来访问这些配置项。

#### 3. @PropertySource注解的使用场景

@PropertySource注解的使用场景主要包括以下几个方面：

1. **配置文件分离**：在大型项目中，可能需要将不同的配置项分散到不同的配置文件中，以便于管理和维护。@PropertySource注解允许开发者指定多个配置文件的位置，从而实现配置文件的分离。
2. **动态配置**：在某些情况下，应用程序可能需要根据不同的环境（如开发环境、测试环境、生产环境）来加载不同的配置文件。通过使用@PropertySource注解和Spring的profiles功能，可以轻松实现动态配置。
3. **外部化配置**：将配置项从代码中分离出来，放到外部的配置文件中，可以提高代码的可维护性和可配置性。@PropertySource注解是实现外部化配置的一种有效方式。
4. **加密配置**：对于敏感信息（如数据库密码、API密钥等），可能需要将其加密后存储在配置文件中。通过使用自定义的PropertySourceLoader和加密/解密机制，可以安全地加载和使用这些加密的配置项。



## 1.7 @DependsOn注解

@DependsOn注解是Spring中提供的一个指定Spring创建Bean的依赖顺序的注解。例如，在Spring中需要创建A对象和B对象，可以使用@DependsOn注解指定创建A对象时依赖B对象，此时，在Spring中就会先创建B对象，然后再创建A对象。

### 注解源码

@DependsOn注解可以标注到类或方法上，可以控制bean的创建、初始化和销毁方法的执行顺序。

```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface DependsOn {
	String[] value() default {};
}
```

* value：表示指定的Bean的唯一标识，被指定的Bean会在Spring创建当前Bean之前被创建。

### 注解使用场景

@DependsOn注解主要用于指定当前Bean对象所依赖的其他Bean对象。Spring在创建当前Bean之前，会先创建由@DependsOn注解指定的依赖Bean，使用@DependsOn注解的场景通常会有以下几种场景：

（1）在某些情况下，Bean不是通过`属性`或`构造函数参数`显式依赖于另一个Bean的，但是却需要在创建一个Bean对象之前，需要先创建另一个Bean对象，此时就可以使用@DependsOn注解。

（2）在单例Bean的情况下`@DependsOn`既可以指定**初始化依赖顺序**，也可以指定Bean相应的**销毁执行顺序**。

（3）@DependsOn注解可标注到任何直接或间接带有@Component注解的Bean或标注到@Bean注解的方法上，可以控制Bean的创建、初始化和销毁方法执行顺序。

（4）观察者模式可以分为事件，事件源和监听器三个组件，如果在Spring中需要实现观察者模式时，就可以使用@DependsOn注解实现监听器的Bean对象在事件源的Bean对象之前被创建。

### 源码时序图

#### 注册Bean的源码时序图

![图7-1](https://upload.yolo912.icu/mdImage/spring-core-2023-02-27-001.png)

#### 调用Bean工厂后置处理器的源码时序图

![图7-2](https://upload.yolo912.icu/mdImage/spring-core-2023-02-27-002.png)

![图7-3](https://upload.yolo912.icu/mdImage/spring-core-2023-02-27-003.png)

####  创建Bean的源码时序图

![图7-5](https://upload.yolo912.icu/mdImage/spring-core-2023-02-27-005.png)

### 源码解析

#### 注册Bean的源码流程

（1）运行DependsOnTest类的main()方法，调用了AnnotationConfigApplicationContext类的构造方法并传入了DependsOnConfig类的Class对象来创建IOC容器。

（2）解析AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext(Class<?>... componentClasses)构造方法

```java
public AnnotationConfigApplicationContext(Class<?>... componentClasses) {
    this();
    register(componentClasses);
    refresh();
}
```

（3）解析AnnotationConfigApplicationContext类的register(Class<?>... componentClasses) 方法

```java
@Override
public void register(Class<?>... componentClasses) {
    /************省略其他代码***************/
    this.reader.register(componentClasses);
    registerComponentClass.end();
}
```

（4）解析AnnotatedBeanDefinitionReader类的register(Class<?>... componentClasses)方法

```java
public void register(Class<?>... componentClasses) {
    for (Class<?> componentClass : componentClasses) {
        registerBean(componentClass);
    }
}
```

在AnnotatedBeanDefinitionReader类的register()方法中，会循环遍历传入的componentClasses数组，并将遍历出的每个componentClass元素作为参数调用registerBean()方法注册Bean。

（5）解析AnnotatedBeanDefinitionReader类的registerBean(Class<?> beanClass)方法

```java
public void registerBean(Class<?> beanClass) {
    doRegisterBean(beanClass, null, null, null, null);
}
```

（6）解析AnnotatedBeanDefinitionReader类的doRegisterBean(Class<T> beanClass, String name, Class<? extends Annotation>[] qualifiers, Supplier<T> supplier, BeanDefinitionCustomizer[] customizers)方法

```java
private <T> void doRegisterBean(Class<T> beanClass, @Nullable String name, @Nullable Class<? extends Annotation>[] qualifiers, @Nullable Supplier<T> supplier, @Nullable BeanDefinitionCustomizer[] customizers) {
    /******************省略其他代码**********************/
    AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);
    /******************省略其他代码**********************/
    BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);
    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
    BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
}
```

（7）解析AnnotationConfigUtils类的processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd)方法

```java
public static void processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd) {
    processCommonDefinitionAnnotations(abd, abd.getMetadata());
}
```

（8）解析AnnotationConfigUtils类的processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata)方法

```java
static void processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata) {
    AnnotationAttributes lazy = attributesFor(metadata, Lazy.class);
    if (lazy != null) {
        abd.setLazyInit(lazy.getBoolean("value"));
    }
    else if (abd.getMetadata() != metadata) {
        lazy = attributesFor(abd.getMetadata(), Lazy.class);
        if (lazy != null) {
            abd.setLazyInit(lazy.getBoolean("value"));
        }
    }

    if (metadata.isAnnotated(Primary.class.getName())) {
        abd.setPrimary(true);
    }
    AnnotationAttributes dependsOn = attributesFor(metadata, DependsOn.class);
    if (dependsOn != null) {
        abd.setDependsOn(dependsOn.getStringArray("value"));
    }

    AnnotationAttributes role = attributesFor(metadata, Role.class);
    if (role != null) {
        abd.setRole(role.getNumber("value").intValue());
    }
    AnnotationAttributes description = attributesFor(metadata, Description.class);
    if (description != null) {
        abd.setDescription(description.getString("value"));
    }
}
```

在processCommonDefinitionAnnotations()方法中解析了@DependsOn注解，并将解析出的@DependsOn注解中的value属性的值设置到AnnotatedBeanDefinition对象的dependsOn属性中。

（9）回到AnnotatedBeanDefinitionReader类的doRegisterBean(Class<T> beanClass, String name, Class<? extends Annotation>[] qualifiers, Supplier<T> supplier, BeanDefinitionCustomizer[] customizers)方法。

在AnnotatedBeanDefinitionReader类的doRegisterBean()方法中，会调用BeanDefinitionReaderUtils类的registerBeanDefinition()方法，并将封装了@DependsOn注解属性的abd对象和beanName封装成BeanDefinitionHolder对象，并且与registry一起作为参数传递给BeanDefinitionReaderUtils类的registerBeanDefinition()方法。

（10）解析BeanDefinitionReaderUtils类的registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)方法

```java
public static void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException {
    String beanName = definitionHolder.getBeanName();
    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
    String[] aliases = definitionHolder.getAliases();
    if (aliases != null) {
        for (String alias : aliases) {
            registry.registerAlias(beanName, alias);
        }
    }
}
```

（11）解析DefaultListableBeanFactory类的registerBeanDefinition(String beanName, BeanDefinition beanDefinition)方法

```java
@Override
public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException {
	/*********省略其他代码**********/
	BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
	if (existingDefinition != null) {
		/*********省略其他代码**********/
	}
	else {
		/*********省略其他代码**********/
		else {
			// Still in startup registration phase
			this.beanDefinitionMap.put(beanName, beanDefinition);
			this.beanDefinitionNames.add(beanName);
			removeManualSingletonName(beanName);
		}
		this.frozenBeanDefinitionNames = null;
	}
    /*********省略其他代码**********/
}
```

在DefaultListableBeanFactory类的registerBeanDefinition()方法中，会将beanName为Key，beanDefinition对象作为Value保存到beanDefinitionMap中。

#### 调用Bean工厂后置处理器的源码流程

**@DependsOn注解在Spring源码层面调用Bean工厂后置处理器的执行流程，执行到ConfigurationClassParser类的doProcessConfigurationClass()方法之前的逻辑与解析@Import注解的代码流程相同，直接从ConfigurationClassParser类的doProcessConfigurationClass()方法开始解析。**

（1）解析ConfigurationClassParser类的doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)方法

```java
protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter) throws IOException {
    /****************省略其他代码****************/
    Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(
        sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
    if (!componentScans.isEmpty() &&
        !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
        for (AnnotationAttributes componentScan : componentScans) {
            Set<BeanDefinitionHolder> scannedBeanDefinitions =
                this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
                BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
                if (bdCand == null) {
                    bdCand = holder.getBeanDefinition();
                }
                if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
                    parse(bdCand.getBeanClassName(), holder.getBeanName());
                }
            }
        }
    }
    /****************省略其他代码****************/
    return null;
}
```

在ConfigurationClassParser类的doProcessConfigurationClass()方法中，会调用componentScanParser的parse()方法来解析配置类上的注解。

（2）解析ComponentScanAnnotationParser类的parse(AnnotationAttributes componentScan, String declaringClass)方法

```java
public Set<BeanDefinitionHolder> parse(AnnotationAttributes componentScan, String declaringClass) {
    /***********省略其他代码*************/
    return scanner.doScan(StringUtils.toStringArray(basePackages));
}
```

在ComponentScanAnnotationParser类的parse()方法中，会调用scanner对象的doScan()方法扫描@ComponentScan注解中basePackages属性设置的包名。

（3）解析ClassPathBeanDefinitionScanner类中的doScan(String... basePackages)方法

```java
protected Set<BeanDefinitionHolder> doScan(String... basePackages) {
    Assert.notEmpty(basePackages, "At least one base package must be specified");
    Set<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<>();
    for (String basePackage : basePackages) {
        Set<BeanDefinition> candidates = findCandidateComponents(basePackage);
        for (BeanDefinition candidate : candidates) {
            /************省略其他代码************/
            if (candidate instanceof AnnotatedBeanDefinition) {
                AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
            }
            if (checkCandidate(beanName, candidate)) {
                BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
                definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
                beanDefinitions.add(definitionHolder);
                registerBeanDefinition(definitionHolder, this.registry);
            }
        }
    }
    return beanDefinitions;
}
```

在ClassPathBeanDefinitionScanner类中的doScan()方法中，会调用AnnotationConfigUtils类的processCommonDefinitionAnnotations()方法来解析注解的信息。

另外，在ClassPathBeanDefinitionScanner类中的doScan()方法中，会调用registerBeanDefinition()方法来注册BeanDefinition信息。

（4）解析ClassPathBeanDefinitionScanner类的registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)方法

```java
protected void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) {
    BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry);
}
```

可以看到，在ClassPathBeanDefinitionScanner类的registerBeanDefinition()方法中，直接调用了BeanDefinitionReaderUtils类的registerBeanDefinition()方法来注册BeanDefinition信息。

（5）解析BeanDefinitionReaderUtils类的registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)方法

```java
public static void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)throws BeanDefinitionStoreException {
    String beanName = definitionHolder.getBeanName();
    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
    /*********省略其他代码************/
}
```

在BeanDefinitionReaderUtils类的registerBeanDefinition()方法中，最终就会调用DefaultListableBeanFactory类的registerBeanDefinition()方法来注册BeanDefinition信息。

#### 创建Bean的源码流程

**@DependsOn注解在Spring源码层面创建Bean的执行流程，执行到AbstractApplicationContext类的refresh()方法的逻辑，与解析@Import注解执行到AbstractApplicationContext类的refresh()方法的逻辑相同**

（1）解析AbstractApplicationContext类的refresh()方法

```java
@Override
public void refresh() throws BeansException, IllegalStateException {
    synchronized (this.startupShutdownMonitor) {
       /*********省略其他代码************/
        try {
            /*********省略其他代码************/
            finishBeanFactoryInitialization(beanFactory);
			/*********省略其他代码************/
        }
        catch (BeansException ex) {
            /*********省略其他代码************/
        }
        finally {
            /*********省略其他代码************/
        }
    }
}
```

在refresh()中会调用finishBeanFactoryInitialization()方法来完成非懒加载的单实例Bean的初始化工作。

（2）解析finishBeanFactoryInitialization类的finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory)方法

```java
protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
    /*******省略其他代码*******/
    beanFactory.preInstantiateSingletons();
}
```

在finishBeanFactoryInitialization类的finishBeanFactoryInitialization()方法中，会调用beanFactory对象的preInstantiateSingletons()方法来初始化所有的非懒加载的单实例Bean。

（3）解析DefaultListableBeanFactory类的preInstantiateSingletons()方法

```java
@Override
public void preInstantiateSingletons() throws BeansException {
    /*********省略其他代码*********/
    for (String beanName : beanNames) {
        RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
        if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
            if (isFactoryBean(beanName)) {
                Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
                if (bean instanceof SmartFactoryBean<?> smartFactoryBean && smartFactoryBean.isEagerInit()) {
                    getBean(beanName);
                }
            }
            else {
                getBean(beanName);
            }
        }
    }
	/*********省略其他代码*********/
}
```

在DefaultListableBeanFactory类的preInstantiateSingletons()方法中，会遍历beanDefinitionNames集合中所有的beanName，并调用getBean()方法初始化所有非懒加载的单实例Bean。

（4）解析AbstractBeanFactory类的getBean(String name)方法

```java
@Override
public Object getBean(String name) throws BeansException {
    return doGetBean(name, null, null, false);
}
```

在AbstractBeanFactory类的getBean()方法中，直接调用了doGetBean()方法来初始化非懒加载的单实例Bean。

（5）解析AbstractBeanFactory类的doGetBean(String name, Class<T> requiredType, Object[] args, boolean typeCheckOnly)方法

源码详见：org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean(String name, Class<T> requiredType, Object[] args, boolean typeCheckOnly)。重点关注如下代码片段。

```java
protected <T> T doGetBean(String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException {
	/*************省略其他代码**************/
	else {
		/*************省略其他代码**************/
		try {
			/*************省略其他代码**************/
			String[] dependsOn = mbd.getDependsOn();
			if (dependsOn != null) {
				for (String dep : dependsOn) {
					if (isDependent(beanName, dep)) {
						throw new BeanCreationException(mbd.getResourceDescription(), beanName,
								"Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
					}
					registerDependentBean(dep, beanName);
					try {
						getBean(dep);
					}
					catch (NoSuchBeanDefinitionException ex) {
						throw new BeanCreationException(mbd.getResourceDescription(), beanName,
								"'" + beanName + "' depends on missing bean '" + dep + "'", ex);
					}
				}
			}
			/*************省略其他代码**************/
		}
		catch (BeansException ex) {
			beanCreation.tag("exception", ex.getClass().toString());
			beanCreation.tag("message", String.valueOf(ex.getMessage()));
			cleanupAfterBeanCreationFailure(beanName);
			throw ex;
		}
		finally {
			beanCreation.end();
		}
	}
	return adaptBeanInstance(name, beanInstance, requiredType);
}
```

在AbstractBeanFactory类的doGetBean()方法中，会获取这些被依赖的beanName，按照数组顺序，再调用AbstractBeanFactory类的getBean()方法来优先创建被依赖的Bean，从而达到控制依赖顺序的目的。



### 思考

#### 1. @DependsOn注解的作用

@DependsOn注解的作用是用于指定一个bean的依赖关系，确保该bean在Spring容器中的初始化顺序。当一个bean依赖于其他bean的初始化完成时，可以使用@DependsOn注解来声明这种依赖关系。这样，Spring容器在初始化bean时，会先确保所有被@DependsOn注解声明的依赖bean都已经完成初始化，然后再进行当前bean的初始化。

#### 2. Bean的循环依赖与@DependsOn注解的关系

Bean的循环依赖指的是两个或多个bean互相依赖，形成一个闭环，导致Spring在实例化这些bean时遇到的问题。具体来说，当尝试初始化一个bean A时，发现它依赖于另一个bean B，而在尝试初始化bean B时，又发现它反过来依赖于bean A，这就构成了一个循环依赖。

**@DependsOn注解与Bean循环依赖的关系**是：**@DependsOn注解并不直接解决循环依赖问题**。它主要用于控制bean的初始化顺序，而不是解决循环依赖。实际上，Spring框架通过一种称为“三级缓存”的机制来解决bean的循环依赖问题。这种机制确保了即使在存在循环依赖的情况下，Spring也能够正确地创建和初始化bean。

需要注意的是，虽然@DependsOn注解可以用于显式地声明bean之间的依赖关系，但如果错误地用于解决循环依赖（例如，两个bean互相使用@DependsOn注解声明对方为依赖），这将会导致Spring无法正确地初始化这些bean，因为它们会陷入一个无限循环的依赖关系中。因此，在实际应用中，应该避免创建循环依赖关系，并考虑通过重新设计类和接口来解决这个问题。



## 1.8 @Conditional注解

@Conditional注解支持按照条件向IOC容器中注册Bean，满足条件的Bean就会被注册到IOC容器中，不满足条件的Bean就不会被注册到IOC容器中。

### 注解源码

```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Conditional {
	Class<? extends Condition>[] value();
}
```

* value：指定Condition接口的实现类，Condition接口的实现类中需要编写具体代码实现向Spring中注入Bean的条件。
