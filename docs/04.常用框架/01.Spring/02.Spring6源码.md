---
title: Spring6源码
date: 2024-08-05 17:23:12
permalink: /pages/aade10/
---





# 一. IOC容器

## 1.1 @Configuration注解

@Configuration注解是从Spring 3.0版本开始加入的一个使Spring能够支持注解驱动开发的标注型注解，主要用于标注在类上。当某个类标注了@Configuration注解时，表示这个类是Spring的一个配置类。@Configuration注解能够替代Spring的applicationContext.xml文件，并且被@Configuration注解标注的类，能够自动注册到IOC容器并进行实例化。

### 注解源码

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Configuration {
	@AliasFor(annotation = Component.class)
	String value() default "";
//Since: 5.2
	boolean proxyBeanMethods() default true;
//Since: 6.0
	boolean enforceUniqueMethods() default true;
}
```

@Configuration注解中每个属性的含义如下所示。

* value：存入到Spring IOC容器中的Bean的id。
* proxyBeanMethods：表示被@Configuration注解标注的配置类是否会被代理，并且在配置类中使用@Bean注解生成的Bean对象在IOC容器中是否是单例对象，取值为true或者false。当取值为true时，表示full（全局）模式，此模式下被@Configuration注解标注的配置类会被代理，在配置类中使用@Bean注解注入到IOC容器中的Bean对象是单例模式，无论调用多少次被@Bean注解标注的方法，返回的都是同一个Bean对象。当取值为false时，表示lite（轻量级）模式，此模式下被@Configuration注解标注的配置类不会被代理，在配置类中使用@Bean注解注入到IOC容器中的Bean对象不是单例模式，每次调用被@Bean注解标注的方法时，都会返回一个新的Bean对象。默认的取值为true。
* enforceUniqueMethods：指定使用@Bean注解标注的方法是否需要具有唯一的方法名称，取值为true或者false。当取值为true时，表示使用@Bean注解标注的方法具有唯一的方法名称，并且这些方法名称不会重叠。当取值为false时，表示使用@Bean注解标注的方法名称不唯一，存在被重叠的风险。默认取值为true。

@Configuration注解本质上是一个@Component注解，所以被@Configuration注解标注的配置类本身也会被注册到IOC容器中。同时，@Configuration注解也会被@ComponentScan注解扫描到。

### 源码时序图

@Configuration注解在源码层面的执行流程涉及到注册与实例化两种执行流程。

* 注册流程：涉及到Spring内部的ConfigurationClassPostProcessor类的Bean定义信息的注册，以及标注了@Configuration注解的Config配置类的Bean定义信息注册。
* 实例化流程：Spring IOC容器在启动过程中，最终会调用AnnotationConfigApplicationContext类的refresh()方法刷新IOC容器，刷新IOC容器的过程中就会对标注了@Configuration注解的配置类进行实例化。

#### **注册ConfigurationClassPostProcessor流程源码时序图**

ConfigurationClassPostProcessor后置处理器是解析@Configuration注解的核心类，Spring IOC容器启动时，会向IOC容器中注册ConfigurationClassPostProcessor类的Bean定义信息。

![图1-1](https://upload.yolo912.icu/mdImage/spring-core-2022-12-05-001.png)

#### **注册配置类流程源码时序图**

在配置类上标注了@Configuration注解，当Spring IOC容器启动时，也会将配置类的Bean定义信息注册到Spring IOC容器中

![图1-2](https://upload.yolo912.icu/mdImage/spring-core-2022-12-05-002.png)

> Spring IOC容器在启动时，会向IOC容器中注册ConfigurationClassPostProcessor类的bean定义信息和使用@Configuration注解标注的配置类的Bean定义信息。当Spring IOC容器再刷新时，会递归处理所有使用@Configuration注解标注的类，解析@Bean等注解标注的方法，解析成一个个ConfigurationClassBeanDefinition类型的BeanDefinition对象，注册到IOC容器中。

#### **实例化流程源码时序图**

Spring IOC容器在启动过程中，最终会调用AnnotationConfigApplicationContext类的refresh()方法刷新IOC容器，刷新IOC容器的过程中就会对标注了@Configuration注解的配置类进行实例化。

![图1-3-1](https://upload.yolo912.icu/mdImage/spring-core-2022-12-05-003.png)

![图1-3-2](https://upload.yolo912.icu/mdImage/spring-core-2022-12-05-004.png)

### 源码解析

#### 注册ConfigurationClassPostProcessor流程源码解析

（1）运行案例程序启动类ConfigurationAnnotationTest的main()方法

```java
public class ConfigurationAnnotationTest {

private static final Logger LOGGER = LoggerFactory.getLogger(ConfigurationAnnotationTest.class);

public static void main(String[] args) {
AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ConfigurationAnnotationConfig.class);
ConfigurationAnnotationConfig config = context.getBean(ConfigurationAnnotationConfig.class);
Person person1 = config.person();
Person person2 = config.person();
LOGGER.info("person1 是否等于 person2 ===>> {}", (person1 == person2));
}
}
```

在main()方法中会调用AnnotationConfigApplicationContext类的构造方法传入配置类ConfigurationAnnotationConfig的Class对象来创建IOC容器。接下来，会进入AnnotationConfigApplicationContext类的构造方法。

（2）解析AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext(Class<?>... componentClasses)构造方法

```java
public AnnotationConfigApplicationContext(Class<?>... componentClasses) {
this();
register(componentClasses);
refresh();
}
```

上述构造方法中，会通过this()调用AnnotationConfigApplicationContext类的无参构造方法。

（3）解析AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext()无参构造方法

```java
public AnnotationConfigApplicationContext() {
StartupStep createAnnotatedBeanDefReader = this.getApplicationStartup().start("spring.context.annotated-bean-reader.create");
this.reader = new AnnotatedBeanDefinitionReader(this);
createAnnotatedBeanDefReader.end();
this.scanner = new ClassPathBeanDefinitionScanner(this);
}
```

在AnnotationConfigApplicationContext类的无参构造方法中，主要的逻辑就是实例化了AnnotatedBeanDefinitionReader类型的reader成员变量和ClassPathBeanDefinitionScanner类型的scanner成员变量。

* reader：表示注解类型的Bean定义信息读取器，主要就是读取通过注解方式进行实例化的Bean的定义信息。
* scanner：表示类路径下的Bean定义扫描器，主要就是扫描类路径下的Bean定义信息。

接下来会调用AnnotatedBeanDefinitionReader类中的AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry)构造方法。

（4）解析AnnotatedBeanDefinitionReader类中的AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry)构造方法

```java
public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry) {
this(registry, getOrCreateEnvironment(registry));
}
```

在上述构造方法中，通过this调用了AnnotatedBeanDefinitionReader类的AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment)构造方法。

（5）解析AnnotatedBeanDefinitionReader类的AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment)构造方法

```java
public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment) {
Assert.notNull(registry, "BeanDefinitionRegistry must not be null");
Assert.notNull(environment, "Environment must not be null");
this.registry = registry;
this.conditionEvaluator = new ConditionEvaluator(registry, environment, null);
AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);
}
```

在上述构造方法中，最核心的逻辑就是调用了AnnotationConfigUtils工具类的registerAnnotationConfigProcessors()方法，将BeanDefinitionRegistry类型的registry对象传入方法中。registry对象本质上就是一个AnnotationConfigApplicationContext类对象的实例，因为AnnotationConfigApplicationContext类继承了GenericApplicationContext类，而GenericApplicationContext类实现了BeanDefinitionRegistry接口。

（6）解析AnnotationConfigUtils类的registerAnnotationConfigProcessors(BeanDefinitionRegistry registry)方法

```java
public static void registerAnnotationConfigProcessors(BeanDefinitionRegistry registry) {
registerAnnotationConfigProcessors(registry, null);
}
```

（7）解析AnnotationConfigUtils类的registerAnnotationConfigProcessors(BeanDefinitionRegistry registry, Object source)方法

```java
public static Set<BeanDefinitionHolder> registerAnnotationConfigProcessors(
			BeanDefinitionRegistry registry, @Nullable Object source) {

// 获取默认的ListableBeanFactory
DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);
if (beanFactory != null) {
// 如果依赖比较器不是AnnotationAwareOrderComparator的实例，则设置依赖比较器为AnnotationAwareOrderComparator
if (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) {
beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);
}
// 如果自动装配候选解析器不是ContextAnnotationAutowireCandidateResolver的实例，则设置自动装配候选解析器为新的ContextAnnotationAutowireCandidateResolver
if (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) {
beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());
}
}

// 创建一个LinkedHashSet来存储bean定义
Set<BeanDefinitionHolder> beanDefs = new LinkedHashSet<>(8);

// 如果注册表中不存在CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME的bean定义
if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {
// 创建一个新的RootBeanDefinition实例，并设置其类为ConfigurationClassPostProcessor
RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);
// 设置bean定义的源为传入的source
def.setSource(source);
// 注册后处理器，并将返回的BeanDefinitionHolder添加到beanDefs集合中
beanDefs.add(registerPostProcessor(registry, def,CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));
}

// 如果注册表中不存在AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME的bean定义
if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {
// 创建一个新的RootBeanDefinition实例，并设置其类为AutowiredAnnotationBeanPostProcessor
RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);
// 设置bean定义的源为传入的source
def.setSource(source);
// 注册后处理器，并将返回的BeanDefinitionHolder添加到beanDefs集合中
beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));
}

// 检查是否存在Jakarta Annotations支持，如果存在则添加CommonAnnotationBeanPostProcessor
// Check for Jakarta Annotations support, and if present add the CommonAnnotationBeanPostProcessor.
if (jakartaAnnotationsPresent && !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) {
// 创建一个新的RootBeanDefinition实例，并设置其类为CommonAnnotationBeanPostProcessor
RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);
// 设置bean定义的源为传入的source
def.setSource(source);
// 注册后处理器，并将返回的BeanDefinitionHolder添加到beanDefs集合中
beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));
}

// 检查是否支持JSR-250，如果支持则添加InitDestroyAnnotationBeanPostProcessor用于javax的PostConstruct/PreDestroy注解
if (jsr250Present && !registry.containsBeanDefinition(JSR250_ANNOTATION_PROCESSOR_BEAN_NAME)) {
try {
// 创建InitDestroyAnnotationBeanPostProcessor的RootBeanDefinition
RootBeanDefinition def = new RootBeanDefinition(InitDestroyAnnotationBeanPostProcessor.class);
// 添加initAnnotationType属性，值为javax.annotation.PostConstruct的Class对象
def.getPropertyValues().add("initAnnotationType", classLoader.loadClass("javax.annotation.PostConstruct"));
// 添加destroyAnnotationType属性，值为javax.annotation.PreDestroy的Class对象
def.getPropertyValues().add("destroyAnnotationType", classLoader.loadClass("javax.annotation.PreDestroy"));
// 设置bean定义的源为传入的source
def.setSource(source);
// 注册后处理器，并将返回的BeanDefinitionHolder添加到beanDefs集合中
beanDefs.add(registerPostProcessor(registry, def, JSR250_ANNOTATION_PROCESSOR_BEAN_NAME));
}
catch (ClassNotFoundException ex) {
// 加载javax注解类型的类失败，忽略异常
// Failed to load javax variants of the annotation types -> ignore.
}
}

// 检查是否支持JPA，如果支持则添加PersistenceAnnotationBeanPostProcessor
if (jpaPresent && !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) {
// 创建RootBeanDefinition
RootBeanDefinition def = new RootBeanDefinition();
try {
// 设置bean的类为PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME指定的类
def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,
AnnotationConfigUtils.class.getClassLoader()));
}
catch (ClassNotFoundException ex) {
// 抛出异常，无法加载可选的框架类
throw new IllegalStateException(
"Cannot load optional framework class: " + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);
}
// 设置bean定义的源为传入的source
def.setSource(source);
// 注册后处理器，并将返回的BeanDefinitionHolder添加到beanDefs集合中
beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));
}

// 如果注册表中不存在EVENT_LISTENER_PROCESSOR_BEAN_NAME的bean定义
if (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) {
// 创建EventListenerMethodProcessor的RootBeanDefinition
RootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);
// 设置bean定义的源为传入的source
def.setSource(source);
// 注册后处理器，并将返回的BeanDefinitionHolder添加到beanDefs集合中
beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));
}

// 如果注册表中不存在EVENT_LISTENER_FACTORY_BEAN_NAME的bean定义
if (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) {
// 创建DefaultEventListenerFactory的RootBeanDefinition
RootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);
// 设置bean定义的源为传入的source
def.setSource(source);
// 注册后处理器，并将返回的BeanDefinitionHolder添加到beanDefs集合中
beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));
}

// 返回beanDefs集合
return beanDefs;
}
```

其中将@Configuration注解涉及到的ConfigurationClassPostProcessor类的Bean定义信息注册到IOC容器中的核心代码为：

```java
public static Set<BeanDefinitionHolder> registerAnnotationConfigProcessors(
			BeanDefinitionRegistry registry, @Nullable Object source) {
//################省略其他代码########################
// 如果注册表中不存在CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME的bean定义
if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {
// 创建一个新的RootBeanDefinition实例，并设置其类为ConfigurationClassPostProcessor
RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);
// 设置bean定义的源为传入的source
def.setSource(source);
// 注册后处理器，并将返回的BeanDefinitionHolder添加到beanDefs集合中
beanDefs.add(registerPostProcessor(registry, def,CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));
}
//################省略其他代码########################
}
```

（8）解析registerPostProcessor(BeanDefinitionRegistry registry, RootBeanDefinition definition, String beanName)方法

```java
private static BeanDefinitionHolder registerPostProcessor(
BeanDefinitionRegistry registry, RootBeanDefinition definition, String beanName) {
definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
registry.registerBeanDefinition(beanName, definition);
return new BeanDefinitionHolder(definition, beanName);
}
```

上述代码调用了registry参数的registerBeanDefinition()方法来注册ConfigurationClassPostProcessor类的Bean定义信息，definition参数本质上就是一个AnnotationConfigApplicationContext类的实例对象。最终会调用DefaultListableBeanFactory类的registerBeanDefinition()方法来注册ConfigurationClassPostProcessor类的Bean定义信息。

（9）解析DefaultListableBeanFactory类的registerBeanDefinition(String beanName, BeanDefinition beanDefinition)方法

```java
@Override
public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
throws BeanDefinitionStoreException {

// 断言beanName非空
Assert.hasText(beanName, "Bean name must not be empty");
// 断言beanDefinition非空
Assert.notNull(beanDefinition, "BeanDefinition must not be null");

// 判断beanDefinition是否是AbstractBeanDefinition的实例
if (beanDefinition instanceof AbstractBeanDefinition abd) {
try {
// 验证bean定义
abd.validate();
}
catch (BeanDefinitionValidationException ex) {
// 抛出BeanDefinitionStoreException异常，包含bean定义资源描述、beanName以及异常信息
throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
   "Validation of bean definition failed", ex);
}
}

// 获取beanName对应的BeanDefinition
BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);

if (existingDefinition != null) {
if (!isAllowBeanDefinitionOverriding()) {
// 如果不允许覆盖Bean定义，则抛出异常
throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);
}
else if (existingDefinition.getRole() < beanDefinition.getRole()) {
// 如果现有Bean定义的角色小于新Bean定义的角色，则进行覆盖
// 例如，之前是ROLE_APPLICATION，现在用ROLE_SUPPORT或ROLE_INFRASTRUCTURE覆盖
if (logger.isInfoEnabled()) {
logger.info("Overriding user-defined bean definition for bean '" + beanName +
"' with a framework-generated bean definition: replacing [" +
existingDefinition + "] with [" + beanDefinition + "]");
}
}
else if (!beanDefinition.equals(existingDefinition)) {
// 如果新Bean定义与现有Bean定义不相等，则进行覆盖
if (logger.isDebugEnabled()) {
logger.debug("Overriding bean definition for bean '" + beanName +
 "' with a different definition: replacing [" + existingDefinition +
 "] with [" + beanDefinition + "]");
}
}
else {
// 如果新Bean定义与现有Bean定义相等，则进行覆盖（尽管它们相等，但可能由于其他原因需要覆盖）
if (logger.isTraceEnabled()) {
logger.trace("Overriding bean definition for bean '" + beanName +
 "' with an equivalent definition: replacing [" + existingDefinition +
 "] with [" + beanDefinition + "]");
}
}
// 将新Bean定义放入beanDefinitionMap中，覆盖现有Bean定义
this.beanDefinitionMap.put(beanName, beanDefinition);
}
else {
if (isAlias(beanName)) {
if (!isAllowBeanDefinitionOverriding()) {
String aliasedName = canonicalName(beanName);
if (containsBeanDefinition(aliasedName)) {
// 如果别名指向已存在的Bean定义
// alias for existing bean definition
throw new BeanDefinitionOverrideException(
beanName, beanDefinition, getBeanDefinition(aliasedName));
}
else {
// 如果别名指向不存在的Bean定义
// alias pointing to non-existing bean definition
throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
   "Cannot register bean definition for bean '" + beanName +
   "' since there is already an alias for bean '" + aliasedName + "' bound.");
}
}
else {
// 移除别名
removeAlias(beanName);
}
}
if (hasBeanCreationStarted()) {
// 不能再修改启动时的集合元素（为了稳定的迭代）
// Cannot modify startup-time collection elements anymore (for stable iteration)
synchronized (this.beanDefinitionMap) {
this.beanDefinitionMap.put(beanName, beanDefinition);
List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);
updatedDefinitions.addAll(this.beanDefinitionNames);
updatedDefinitions.add(beanName);
this.beanDefinitionNames = updatedDefinitions;
removeManualSingletonName(beanName);
}
}
else {
// 仍然处于启动注册阶段
// Still in startup registration phase
this.beanDefinitionMap.put(beanName, beanDefinition);
this.beanDefinitionNames.add(beanName);
removeManualSingletonName(beanName);
}
this.frozenBeanDefinitionNames = null;
}

if (existingDefinition != null || containsSingleton(beanName)) {
// 重置Bean定义
resetBeanDefinition(beanName);
}
else if (isConfigurationFrozen()) {
// 清除按类型缓存
clearByTypeCache();
}
}
```

向Spring的IOC容器中注册类的Bean定义信息，其实就是向beanDefinitionMap对象中添加元素，beanDefinitionMap对象本质上是一个ConcurrentHashMap对象。向beanDefinitionMap对象中添加的元素的Key为Bean的名称，Value为Bean的定义信息。

```java
@Override
public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
throws BeanDefinitionStoreException {
//##################省略其他代码###############
	this.beanDefinitionMap.put(beanName, beanDefinition);
//##################省略其他代码###############
}
```

beanDefinitionMap源码:

```java
private final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>(256);
```

#### 注册配置类流程源码解析

（1）AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext(Class<?>... componentClasses)构造方法中调用了register()方法，传入componentClasses参数进行注册。

```java
public AnnotationConfigApplicationContext(Class<?>... componentClasses) {
this();
register(componentClasses);
refresh();
}
```

（2）解析AnnotationConfigApplicationContext类的register(Class<?>... componentClasses)方法

```java
@Override
public void register(Class<?>... componentClasses) {
	//###########省略其他代码##############
this.reader.register(componentClasses);
//###########省略其他代码##############
}
```

（3）解析AnnotatedBeanDefinitionReader类的register(Class<?>... componentClasses)方法

```java
public void register(Class<?>... componentClasses) {
for (Class<?> componentClass : componentClasses) {
registerBean(componentClass);
}
}
```

（4）解析AnnotatedBeanDefinitionReader类的registerBean(Class<?> beanClass)方法

```java
public void registerBean(Class<?> beanClass) {
doRegisterBean(beanClass, null, null, null, null);
}
```

（5）解析AnnotatedBeanDefinitionReader类的doRegisterBean(Class<T> beanClass, String name, Class<? extends Annotation>[] qualifiers, Supplier<T> supplier, BeanDefinitionCustomizer[] customizers)方法。

```java
private <T> void doRegisterBean(Class<T> beanClass, @Nullable String name,@Nullable Class<? extends Annotation>[] qualifiers, @Nullable Supplier<T> supplier, @Nullable BeanDefinitionCustomizer[] customizers) {

AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(beanClass);
//###########################省略其他代码#############################
String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));
//###########################省略其他代码#############################
BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);
definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
}
```

（6）解析BeanDefinitionReaderUtils类的registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)方法

```java
public static void registerBeanDefinition(
BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
throws BeanDefinitionStoreException {

// Register bean definition under primary name.
String beanName = definitionHolder.getBeanName();
registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
//###########################省略其他代码#############################
}
```

在registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)方法中通过调用registry的registerBeanDefinition()方法来向IOC容器中注册Bean定义信息。

#### 实例化流程源码解析

（1）AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext(Class<?>... componentClasses)构造方法中会调用refresh()方法刷新IOC容器。

```java
public AnnotationConfigApplicationContext(Class<?>... componentClasses) {
this();
register(componentClasses);
refresh();
}
```

（2）解析AbstractApplicationContext类的refresh()方法

```java
@Override
public void refresh() throws BeansException, IllegalStateException {
synchronized (this.startupShutdownMonitor) {
		//#############省略其他代码#####################
try {
//#############省略其他代码#####################
invokeBeanFactoryPostProcessors(beanFactory);
			//#############省略其他代码#####################
}
catch (BeansException ex) {
   //#############省略其他代码#####################
}
finally {
   //#############省略其他代码#####################
}
}
}
```

在refresh()方法中调用了invokeBeanFactoryPostProcessors()方法。

（3）解析AbstractApplicationContext类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory)方法

```java
protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
	//################省略其他代码####################
}
```

（4）解析PostProcessorRegistrationDelegate类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors)方法

```java
public static void invokeBeanFactoryPostProcessors(
ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {
	//#################省略其他代码##################
invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
	invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
//#################省略其他代码##################
}
```

在invokeBeanFactoryPostProcessors()方法中会解析标注了@Configuration注解的类中标注了@Bean等注解的方法，生成相应的Bean定义信息注册到IOC容器中。这里主要关注的是标注了@Configuration注解的类的实例化过程

（5）解析PostProcessorRegistrationDelegate类的invokeBeanFactoryPostProcessors(Collection<? extends BeanFactoryPostProcessor> postProcessors, ConfigurableListableBeanFactory beanFactory)方法

```java
private static void invokeBeanFactoryPostProcessors(Collection<? extends BeanFactoryPostProcessor> postProcessors, ConfigurableListableBeanFactory beanFactory) {
for (BeanFactoryPostProcessor postProcessor : postProcessors) {
StartupStep postProcessBeanFactory = beanFactory.getApplicationStartup().start("spring.context.bean-factory.post-process")
.tag("postProcessor", postProcessor::toString);
postProcessor.postProcessBeanFactory(beanFactory);
postProcessBeanFactory.end();
}
}
```

可以看到在invokeBeanFactoryPostProcessors()方法中，会循环遍历传递进来的所有postProcessors集合，每次循环时，都会使用一个postProcessor对象来接收postProcessors集合中的每一个元素，调用postProcessor对象的postProcessBeanFactory()方法，并传入beanFactory来实例化对象。

（6）解析ConfigurationClassPostProcessor类中的postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)方法

```java
@Override
public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
//##############省略其他代码###############
enhanceConfigurationClasses(beanFactory);
beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory));
}
```

（7）解析ConfigurationClassPostProcessor类的enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory)方法

```java
public void enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory) {
//################省略其他代码########################
ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer();
for (Map.Entry<String, AbstractBeanDefinition> entry : configBeanDefs.entrySet()) {
AbstractBeanDefinition beanDef = entry.getValue();
// If a @Configuration class gets proxied, always proxy the target class
beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);
// Set enhanced subclass of the user-specified bean class
Class<?> configClass = beanDef.getBeanClass();
Class<?> enhancedClass = enhancer.enhance(configClass, this.beanClassLoader);
if (configClass != enhancedClass) {
//################省略其他代码###################
beanDef.setBeanClass(enhancedClass);
}
}
enhanceConfigClasses.tag("classCount", () -> String.valueOf(configBeanDefs.keySet().size())).end();
}
```

enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory)方法主要是使用ConfigurationClassEnhancer对象的enhance()方法生成代理类，也就是使用CGLib生成代理类。

（8）解析ConfigurationClassEnhancer类的enhance(Class<?> configClass, ClassLoader classLoader)方法

```java
public Class<?> enhance(Class<?> configClass, @Nullable ClassLoader classLoader) {
//###################省略其他代码###############
Class<?> enhancedClass = createClass(newEnhancer(configClass, classLoader));
//###################省略其他代码###############
return enhancedClass;
}
```

enhance(Class<?> configClass, ClassLoader classLoader)方法中调用了createClass()方法创建代理类，在这之前先调用newEnhancer()方法实例化Enhancer对象。

（9）解析ConfigurationClassEnhancer类的newEnhancer(Class<?> configSuperClass, ClassLoader classLoader)方法

```java
private Enhancer newEnhancer(Class<?> configSuperClass, @Nullable ClassLoader classLoader) {
Enhancer enhancer = new Enhancer();
enhancer.setSuperclass(configSuperClass);
enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class});
enhancer.setUseFactory(false);
enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
enhancer.setAttemptLoad(true);
enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader));
enhancer.setCallbackFilter(CALLBACK_FILTER);
enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());
return enhancer;
}
```

newEnhancer()方法中主要是生成CGLib动态代理的Enhancer对象，后续会使用Enhancer对象生成代理类。

在newEnhancer()方法中为要生成的代理类设置了父类和接口，由于为要生成的代理类设置的接口为EnhancedConfiguration，同时，EnhancedConfiguration接口继承了BeanFactoryAware接口，所以，在后续生成的代理类中可以调用BeanFactoryAware接口的setBeanFactory(BeanFactory beanFactory)方法获取到beanFactory对象。

（10）解析ConfigurationClassEnhancer类的createClass(Enhancer enhancer)方法

```java
private Class<?> createClass(Enhancer enhancer) {
Class<?> subclass = enhancer.createClass();
Enhancer.registerStaticCallbacks(subclass, CALLBACKS);
return subclass;
}
```

在createClass(Enhancer enhancer)方法中主要调用了enhancer对象的createClass()方法来创建代理类，这里创建出来的代理类就是目标类的子类。。

（11）解析CALLBACKS

```java
static final Callback[] CALLBACKS = new Callback[] {
new BeanMethodInterceptor(),
new BeanFactoryAwareMethodInterceptor(),
NoOp.INSTANCE
};
```

CALLBACKS是一个Callback类型的数组，数组中的每个元素都是一个Callback类型的对象。其中，BeanMethodInterceptor类和BeanFactoryAwareMethodInterceptor类也是拦截器类型。接下来，以BeanMethodInterceptor类为例进行介绍。

（12）解析BeanMethodInterceptor类

BeanMethodInterceptor实现了MethodInterceptor接口和ConditionalCallback接口，主要的作用就是对标注了@Bean的注解的方法进行拦截，执行intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,  MethodProxy  cglibMethodProxy)方法，生成Bean的实例对象。

```java
public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,
					MethodProxy cglibMethodProxy) throws Throwable {
//如果已经创建了Bean的代理实例对象，则调用父类的方法。
if (isCurrentlyInvokedFactoryMethod(beanMethod)) {
//#################省略其他代码###############
return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs);
}
return resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName);   
}
```

上述代码能够保证在类上添加@Configuration注解后，只会为类生成一个代理对象。也就是上述代码的逻辑能够保证标注了@Configuration注解的类生成的代理类是单例模式的。

因为使用CGLib创建出来的代理类是目标类的子类，所以第一次执行上述代码片段时，会调用cglibMethodProxy的invokeSuper()方法执行父类的方法，也就是执行目标类的方法。第二次执行上述代码片段时，会调用resolveBeanReference()方法。

（13）解析BeanMethodInterceptor类的resolveBeanReference(Method beanMethod, Object[] beanMethodArgs,  ConfigurableBeanFactory beanFactory, String beanName)方法

```java
private Object resolveBeanReference(Method beanMethod, Object[] beanMethodArgs, ConfigurableBeanFactory beanFactory, String beanName) {
//##############省略其他代码###############
boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName);
try {
//##############省略其他代码###############
Object beanInstance = (useArgs ? beanFactory.getBean(beanName, beanMethodArgs) :
   beanFactory.getBean(beanName));
   //##############省略其他代码###############
return beanInstance;
}
finally {
   //##############省略其他代码###############
}
}
```

resolveBeanReference()方法中会通过beanFactory获取已经初始化好的Bean对象，并将这个已经初始化好的bean对象返回。并不会再进行第二次初始化的操作。所以在类上添加@Configuration注解后，Spring能够保证为类生成的代理类是单例的。

### 思考

#### 1. Spring为何在创建IOC容器时先注册ConfigurationClassPostProcessor类后置处理器的Bean定义信息，随后才是注册标注了@Configuration注解的ConfigurationAnnotationConfig配置类的Bean定义信息？

Spring在创建IOC容器时首先注册`ConfigurationClassPostProcessor`类后置处理器的Bean定义信息，是因为`ConfigurationClassPostProcessor`是Spring框架用于处理带有`@Configuration`注解的类的核心组件。它负责扫描和处理这些配置类，进而解析其中的`@Bean`方法和其他相关注解。将其先注册为Bean定义，是为了在容器后续的启动和初始化过程中，能够尽早地获取到这个处理器，并利用它来解析和注册其他配置类中的Bean定义。

这种设计确保了Spring在正式解析和注册其他Bean之前，已经准备好了处理配置类的机制，从而能够有序、高效地处理整个配置过程，保证配置类中的元信息被正确处理。。

#### 2. Spring为何先将类的Bean定义信息注册到IOC容器？为何不是直接注册实例化后的对象？

Spring先将类的Bean定义信息注册到IOC容器，而不是直接注册实例化后的对象，主要是因为这种方式提供了更高的灵活性和控制力。通过注册Bean定义（包括类的信息、构造方法、依赖关系等），Spring能够在需要的时候（通常是Bean被使用时）再创建Bean的实例。这种延迟初始化的策略有助于减少启动时的内存消耗和初始化时间，同时也可以通过配置来控制Bean的创建时机和生命周期。

此外，注册Bean定义还允许Spring在创建Bean实例时应用各种依赖注入（DI）和AOP（面向切面编程）特性，如自动装配、代理创建等，从而增强了Spring框架的功能。

#### 3. Spring为何是在刷新IOC容器时，实例化标注了@Configuration注解的配置类的代理对象？为何不是在创建IOC容器时就进行实例化？

Spring在刷新IOC容器时实例化标注了`@Configuration`注解的配置类的代理对象，而不是在创建IOC容器时就进行实例化，主要是出于两个考虑：

1. **延迟加载**：通过延迟实例化配置类的代理对象，Spring可以在需要时再进行加载，这有助于减少应用启动时的初始化时间和内存消耗。
2. **增强功能**：配置类的代理对象在Spring中扮演着特殊角色，它们不仅包含了配置类的逻辑，还通过代理机制提供了额外的功能，如增强`@Bean`方法的调用（以确保每个`@Bean`方法只被调用一次并返回相同的实例）。Spring可以支持诸如`@Bean`方法的拦截，从而实现诸如条件判断、生命周期管理等功能。这种增强功能需要在容器启动和Bean创建过程中进行，因此延迟到容器刷新时再进行实例化是合理的。



## 1.2 @ComponentScans与@ComponentScan注解

@ComponentScans注解可以看作是@ComponentScan注解的一个数组，在@ComponentScans注解中可以多次标注@ComponentScan注解。@ComponentScan注解最核心的功能就是Spring IOC容器在刷新的时候会扫描对应包下标注了@Component注解、@Configuration注解、@Repository注解、@Service注解和@Controller等等注解的类，生成扫描到的类的Bean定义信息，整体流程与注册ConfigurationClassPostProcessor类的Bean定义信息的流程基本一致，最终都会将其保存到BeanFactory中的beanDefinitionMap中。

### 注解源码

**@ComponentScans注解源码**

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
public @interface ComponentScans {
	ComponentScan[] value();
}
```

**@ComponentScan注解源码**

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Repeatable(ComponentScans.class)
public @interface ComponentScan {

	@AliasFor("basePackages")
	String[] value() default {};

	@AliasFor("value")
	String[] basePackages() default {};

	Class<?>[] basePackageClasses() default {};

	Class<? extends BeanNameGenerator> nameGenerator() default BeanNameGenerator.class;

	Class<? extends ScopeMetadataResolver> scopeResolver() default AnnotationScopeMetadataResolver.class;

	ScopedProxyMode scopedProxy() default ScopedProxyMode.DEFAULT;

	String resourcePattern() default ClassPathScanningCandidateComponentProvider.DEFAULT_RESOURCE_PATTERN;

	boolean useDefaultFilters() default true;

	Filter[] includeFilters() default {};

	Filter[] excludeFilters() default {};

	boolean lazyInit() default false;

	@Retention(RetentionPolicy.RUNTIME)
	@Target({})
	@interface Filter {

		FilterType type() default FilterType.ANNOTATION;

		@AliasFor("classes")
		Class<?>[] value() default {};

		@AliasFor("value")
		Class<?>[] classes() default {};

		String[] pattern() default {};

	}
}
```

@ComponentScan注解中的每个属性的含义如下所示。

* value：作用同basePackages属性，String[]数组类型，指定要扫描的包名。如果指定了要扫描的包名，则Spring会扫描指定的包及其子包下的所有类。
* basePackages：作用同value属性，String[]数组类型，指定要扫描的包名。如果指定了要扫描的包名，则Spring会扫描指定的包及其子包下的所有类。
* basePackageClasses：Class<?>[]数组类型，指定要扫描的类的Class对象。
* nameGenerator：Class<? extends BeanNameGenerator>类型，指定扫描类时，向IOC注入Bean对象时的命名规则。
* scopeResolver：Class<? extends ScopeMetadataResolver>类型，扫描类时，用于处理并转换符合条件的Bean的作用范围。
* scopedProxy：ScopedProxyMode类型，指定生成Bean对象时的代理方式，默认的代理方法是DEFAULT，也就是不使用代理。
* resourcePattern：String类型，用于指定扫描的文件类型，默认是扫描指定包下的`**/*.class`。
* useDefaultFilters：boolean类型，是否自动检测@Component @Repository @Service @Controller注解，默认是true。
* includeFilters：Filter[]数组类型，自定义组件扫描过滤规则，符合过滤规则的类的Bean定义信息会被注册到IOC容器中。includeFilters表示只包含对应的规则，当使用includeFilters()来指定只包含哪些注解标注的类时，需要禁用默认的过滤规则，也就是需要将useDefaultFilters属性设置为false。并且，除了符合过滤规则的类外，Spring内置的如下名称的类的Bean定义信息注册到IOC容器时不受过滤规则限制，如下所示。

```bash
org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
```

* excludeFilters：Filter[]数组类型，自定义组件扫描过滤规则，excludeFilters表示排除使用对应的规则，符合过滤规则的类的Bean定义信息不会被注册到IScopedProxyMode枚举类表示Spring指定生成Bean对象时的代理方式OC容器中。
* lazyInit：boolean类型，表示Spring扫描组件时是否采用懒加载 ，默认false，表示不开启懒加载。

@Filter注解中的每个属性的含义如下所示。

* type：FilterType类型，表示过滤规则的类型。
* value：Class<?>[]数组类型，过滤符合规则的类，作用同classes属性。
* classes：Class<?>[]数组类型，过滤符合规则的类，作用同value属性。
* pattern：如果FilterType取值为ASPECTJ，则此属性表示ASPECTJ表达式。

ScopedProxyMode枚举类表示Spring指定生成Bean对象时的代理方式：

```java
public enum ScopedProxyMode {
	DEFAULT,
	NO,
	INTERFACES,
	TARGET_CLASS
}
```

ScopedProxyMode类每个属性的含义：

* DEFAULT：默认的代理方式，也就是不使用代理，除非在component-scan级别使用了不同的配置。
* NO：不使用代理。
* INTERFACES：基于JDK动态代理实现接口代理对象。
* TARGET_CLASS：基于CGLib动态代理创建类代理对象。

FilterType枚举类表示Spring扫描类时的过滤类型：

```java
public enum FilterType {
	ANNOTATION,
	ASSIGNABLE_TYPE,
	ASPECTJ,
	REGEX,
	CUSTOM
}
```

FilterType类每个属性的含义：

* ANNOTATION：按照注解进行过滤。
* ASSIGNABLE_TYPE：按照给定的类型进行过滤。
* ASPECTJ：按照ASPECTJ表达式进行过滤。
* REGEX：按照正则表达式进行过滤。
* CUSTOM：按照自定义规则进行过滤，使用自定义过滤规则时，自定义的过滤器需要实现org.springframework.core.type.filter.TypeFilter接口。

### 源码时序图

![图2-1](https://upload.yolo912.icu/mdImage/spring-core-2022-12-16-002.png)

![图2-2](https://upload.yolo912.icu/mdImage/spring-core-2022-12-16-003.png)

![图2-3](https://upload.yolo912.icu/mdImage/spring-core-2022-12-16-004.png)

### 源码解析

（1）运行ComponentScanTest类的main()方法。

```java
public static void main(String[] args) {
AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ComponentScanConfig.class);
String[] names = context.getBeanDefinitionNames();
Arrays.stream(names).forEach(System.out::println);
}
```

（2）解析AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext(Class<?>... componentClasses)构造方法

```java
public AnnotationConfigApplicationContext(Class<?>... componentClasses) {
this();
register(componentClasses);
refresh();
}
```

（3）解析AbstractApplicationContext类的refresh()方法

```java
@Override
public void refresh() throws BeansException, IllegalStateException {
synchronized (this.startupShutdownMonitor) {
//############省略其他代码##############
try {
//############省略其他代码##############
invokeBeanFactoryPostProcessors(beanFactory);
   //############省略其他代码##############
}catch (BeansException ex) {
//############省略其他代码##############
}finally {
//############省略其他代码##############
}
}
}
```

（4）解析AbstractApplicationContext类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory)方法

```java
protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
if (!NativeDetector.inNativeImage() && beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
}
}
```

（5）解析PostProcessorRegistrationDelegate类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors)方法

```java
public static void invokeBeanFactoryPostProcessors(
ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {

//############省略其他代码##############
List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();

// 首先，调用实现PriorityOrdered接口的BeanDefinitionRegistryPostProcessor
String[] postProcessorNames =
beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
for (String ppName : postProcessorNames) {
if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
processedBeans.add(ppName);
}
}
sortPostProcessors(currentRegistryProcessors, beanFactory);
registryProcessors.addAll(currentRegistryProcessors);
invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());
currentRegistryProcessors.clear();

// 接着，调用实现Ordered接口的BeanDefinitionRegistryPostProcessor
postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
for (String ppName : postProcessorNames) {
if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {
currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
processedBeans.add(ppName);
}
}
sortPostProcessors(currentRegistryProcessors, beanFactory);
registryProcessors.addAll(currentRegistryProcessors);
invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());
currentRegistryProcessors.clear();

// 最后，循环调用其他BeanDefinitionRegistryPostProcessor，直到没有新的出现
boolean reiterate = true;
while (reiterate) {
reiterate = false;
postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
for (String ppName : postProcessorNames) {
if (!processedBeans.contains(ppName)) {
currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
processedBeans.add(ppName);
reiterate = true;
}
}
sortPostProcessors(currentRegistryProcessors, beanFactory);
registryProcessors.addAll(currentRegistryProcessors);
invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());
currentRegistryProcessors.clear();
}
//############省略其他代码##############
}
```

BeanDefinitionRegistryPostProcessor的实现类在执行逻辑上会有先后顺序，并且最终都会调用invokeBeanDefinitionRegistryPostProcessors()方法。

（6）解析PostProcessorRegistrationDelegate类的invokeBeanDefinitionRegistryPostProcessors(Collection<? extends BeanDefinitionRegistryPostProcessor> postProcessors, BeanDefinitionRegistry registry, ApplicationStartup applicationStartup)方法

```java
private static void invokeBeanDefinitionRegistryPostProcessors(
Collection<? extends BeanDefinitionRegistryPostProcessor> postProcessors, BeanDefinitionRegistry registry, ApplicationStartup applicationStartup) {

for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {
// 启动一个名为 "spring.context.beandef-registry.post-process" 的启动步骤，并为其添加一个标签 "postProcessor"，标签的值为 postProcessor 的字符串表示形式
StartupStep postProcessBeanDefRegistry = applicationStartup.start("spring.context.beandef-registry.post-process")
.tag("postProcessor", postProcessor::toString);
// 调用 postProcessor 的 postProcessBeanDefinitionRegistry 方法，对 BeanDefinitionRegistry 注册Bean的定义信息
postProcessor.postProcessBeanDefinitionRegistry(registry);
// 结束启动步骤
postProcessBeanDefRegistry.end();
}
}
```

在invokeBeanDefinitionRegistryPostProcessors()方法中，会循环遍历postProcessors集合中的每个元素，调用postProcessBeanDefinitionRegistry()方法注册Bean的定义信息。

（7）解析ConfigurationClassPostProcessor类的postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)方法

```java
@Override
public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
	//##########省略其他代码###################
processConfigBeanDefinitions(registry);
}
```

（8）解析ConfigurationClassPostProcessor类的processConfigBeanDefinitions(BeanDefinitionRegistry registry)方法

```java
public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
//############省略其他代码#################
// Parse each @Configuration class
ConfigurationClassParser parser = new ConfigurationClassParser(
this.metadataReaderFactory, this.problemReporter, this.environment,
this.resourceLoader, this.componentScanBeanNameGenerator, registry);

// 存储待解析的 Bean 定义持有者
Set<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);
// 存储已经解析过的配置类
Set<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());
do {
// 启动一个名为 "spring.context.config-classes.parse" 的启动步骤
StartupStep processConfig = this.applicationStartup.start("spring.context.config-classes.parse");
// 解析配置类
parser.parse(candidates);
// 验证配置类
parser.validate();
// 获取解析后的配置类集合
Set<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());
// 移除已经解析过的配置类
configClasses.removeAll(alreadyParsed);

// 根据模型内容读取并创建 Bean 定义
// Read the model and create bean definitions based on its content
if (this.reader == null) {
// 初始化 Bean 定义读取器
this.reader = new ConfigurationClassBeanDefinitionReader(
registry, this.sourceExtractor, this.resourceLoader, this.environment,
this.importBeanNameGenerator, parser.getImportRegistry());
}
// 加载 Bean 定义
this.reader.loadBeanDefinitions(configClasses);
// 将已解析的配置类添加到已解析集合中
alreadyParsed.addAll(configClasses);
// 结束启动步骤，并标记解析的配置类数量
processConfig.tag("classCount", () -> String.valueOf(configClasses.size())).end();

// 清空待解析的 Bean 定义持有者集合
candidates.clear();
// 如果当前注册的 Bean 定义数量大于候选名称的数量
if (registry.getBeanDefinitionCount() > candidateNames.length) {
// 获取当前所有注册的 Bean 名称
String[] newCandidateNames = registry.getBeanDefinitionNames();
// 将候选名称转换为集合
Set<String> oldCandidateNames = Set.of(candidateNames);
// 存储已经解析过的配置类名称
Set<String> alreadyParsedClasses = new HashSet<>();
// 遍历已解析的配置类
for (ConfigurationClass configurationClass : alreadyParsed) {
// 添加配置类名称到已解析集合中
alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
}
// 遍历新的候选名称
for (String candidateName : newCandidateNames) {
// 如果旧的候选名称集合中不包含当前候选名称
if (!oldCandidateNames.contains(candidateName)) {
// 获取 Bean 定义
BeanDefinition bd = registry.getBeanDefinition(candidateName);
// 判断 Bean 定义是否是配置类候选
if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &&
// 并且配置类名称不在已解析集合中
!alreadyParsedClasses.contains(bd.getBeanClassName())) {
// 将新的 Bean 定义持有者添加到待解析集合中
candidates.add(new BeanDefinitionHolder(bd, candidateName));
}
}
}
// 更新候选名称数组
candidateNames = newCandidateNames;
}
}
// 循环直到待解析集合为空
while (!candidates.isEmpty());
//############省略其他代码#################
}
```

在processConfigBeanDefinitions()方法中，创建了一个ConfigurationClassParser类型的对象parser，并且调用了parser的parse()方法来解析类的配置信息。

（9）解析ConfigurationClassParser类的parse(Set<BeanDefinitionHolder> configCandidates)方法

```java
public void parse(Set<BeanDefinitionHolder> configCandidates) {
for (BeanDefinitionHolder holder : configCandidates) {
BeanDefinition bd = holder.getBeanDefinition();
try {
if (bd instanceof AnnotatedBeanDefinition) {
// 如果 BeanDefinition 是 AnnotatedBeanDefinition 类型
parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
}
else if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {
// 如果 BeanDefinition 是 AbstractBeanDefinition 类型，并且存在 BeanClass
parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());
}
else {
// 其他情况
parse(bd.getBeanClassName(), holder.getBeanName());
}
}
catch (BeanDefinitionStoreException ex) {
// 如果发生 BeanDefinitionStoreException 异常，则直接抛出
throw ex;
}
catch (Throwable ex) {
// 如果发生其他异常，则包装为 BeanDefinitionStoreException 异常并抛出
throw new BeanDefinitionStoreException(
"Failed to parse configuration class [" + bd.getBeanClassName() + "]", ex);
}
}
this.deferredImportSelectorHandler.process();
}
```

（10）解析ConfigurationClassParser类的parse(AnnotationMetadata metadata, String beanName)方法

```java
protected final void parse(AnnotationMetadata metadata, String beanName) throws IOException {
processConfigurationClass(new ConfigurationClass(metadata, beanName), DEFAULT_EXCLUSION_FILTER);
}
```

（11）解析ConfigurationClassParser类的processConfigurationClass(ConfigurationClass configClass, Predicate<String> filter)方法

```java
protected void processConfigurationClass(ConfigurationClass configClass, Predicate<String> filter) throws IOException {
//###############省略其他代码####################
// 递归处理配置类及其超类层次结构
SourceClass sourceClass = asSourceClass(configClass, filter);
do {
// 处理配置类
sourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);
}
while (sourceClass != null);
// 将配置类放入配置类集合中
this.configurationClasses.put(configClass, configClass);
}
```

在processConfigurationClass()方法中，会通过do-while()循环获取配置类和其父类的注解信息，SourceClass类中会封装配置类上注解的详细信息。

（12）解析ConfigurationClassParser类的doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)方法

```java
protected final SourceClass doProcessConfigurationClass(
ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)
throws IOException {
//##############省略其他代码################
// 处理任何@ComponentScan注解
// Process any @ComponentScan annotations
Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(
sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
if (!componentScans.isEmpty() &&
!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
for (AnnotationAttributes componentScan : componentScans) {
// 如果配置类被注解为@ComponentScan -> 立即执行扫描
// The config class is annotated with @ComponentScan -> perform the scan immediately
Set<BeanDefinitionHolder> scannedBeanDefinitions =
this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
// 检查扫描到的定义集合中是否有其他配置类，如果需要则递归解析
// Check the set of scanned definitions for any further config classes and parse recursively if needed
for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
if (bdCand == null) {
bdCand = holder.getBeanDefinition();
}
if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
// 解析配置类
parse(bdCand.getBeanClassName(), holder.getBeanName());
}
}
}
}
  	//##############省略其他代码################
// No superclass -> processing is complete
return null;
}
```

在上述处理@ComponentScan注解的逻辑中，通过componentScanParser的parse()方法对@ComponentScan注解进行解析。

（13）解析ComponentScanAnnotationParser类的parse(AnnotationAttributes componentScan, String declaringClass)方法

```java
public Set<BeanDefinitionHolder> parse(AnnotationAttributes componentScan, String declaringClass) {
// 创建ClassPathBeanDefinitionScanner实例
ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry,
componentScan.getBoolean("useDefaultFilters"), this.environment, this.resourceLoader);
// 获取BeanNameGenerator类的Class对象
Class<? extends BeanNameGenerator> generatorClass = componentScan.getClass("nameGenerator");
// 判断是否使用继承的BeanNameGenerator
boolean useInheritedGenerator = (BeanNameGenerator.class == generatorClass);
// 设置BeanNameGenerator
scanner.setBeanNameGenerator(useInheritedGenerator ? this.beanNameGenerator :
 BeanUtils.instantiateClass(generatorClass));
// 获取ScopedProxyMode枚举值
ScopedProxyMode scopedProxyMode = componentScan.getEnum("scopedProxy");
if (scopedProxyMode != ScopedProxyMode.DEFAULT) {
// 设置ScopedProxyMode
scanner.setScopedProxyMode(scopedProxyMode);
}
else {
// 获取ScopeMetadataResolver类的Class对象
Class<? extends ScopeMetadataResolver> resolverClass = componentScan.getClass("scopeResolver");
// 设置ScopeMetadataResolver
scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));
}
// 设置资源匹配模式
scanner.setResourcePattern(componentScan.getString("resourcePattern"));
// 遍历includeFilters
for (AnnotationAttributes includeFilterAttributes : componentScan.getAnnotationArray("includeFilters")) 	{
// 创建TypeFilter列表
List<TypeFilter> typeFilters = TypeFilterUtils.createTypeFiltersFor(includeFilterAttributes, this.environment,
this.resourceLoader, this.registry);
// 遍历TypeFilter列表，并添加到scanner中
for (TypeFilter typeFilter : typeFilters) {
scanner.addIncludeFilter(typeFilter);
}
}
// 遍历excludeFilters
for (AnnotationAttributes excludeFilterAttributes : componentScan.getAnnotationArray("excludeFilters")) 	{
// 创建TypeFilter列表
List<TypeFilter> typeFilters = TypeFilterUtils.createTypeFiltersFor(excludeFilterAttributes, this.environment,
this.resourceLoader, this.registry);
// 遍历TypeFilter列表，并添加到scanner中
for (TypeFilter typeFilter : typeFilters) {
scanner.addExcludeFilter(typeFilter);
}
}

// 获取lazyInit的值
boolean lazyInit = componentScan.getBoolean("lazyInit");
if (lazyInit) {
// 设置Bean定义默认的懒加载属性
scanner.getBeanDefinitionDefaults().setLazyInit(true);
}

// 创建basePackages集合
Set<String> basePackages = new LinkedHashSet<>();
// 获取basePackages数组
String[] basePackagesArray = componentScan.getStringArray("basePackages");
// 遍历basePackages数组
for (String pkg : basePackagesArray) {
// 解析并添加包名到basePackages集合中
String[] tokenized = StringUtils.tokenizeToStringArray(this.environment.resolvePlaceholders(pkg),
   ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);
Collections.addAll(basePackages, tokenized);
}
// 遍历basePackageClasses数组
for (Class<?> clazz : componentScan.getClassArray("basePackageClasses")) {
// 获取包名并添加到basePackages集合中
basePackages.add(ClassUtils.getPackageName(clazz));
}
// 如果basePackages集合为空，则添加声明类的包名到集合中
if (basePackages.isEmpty()) {
basePackages.add(ClassUtils.getPackageName(declaringClass));
}

// 添加自定义的excludeFilter
scanner.addExcludeFilter(new AbstractTypeHierarchyTraversingFilter(false, false) {
@Override
protected boolean matchClassName(String className) {
// 判断是否为声明类的类名
return declaringClass.equals(className);
}
});
		// 执行扫描并返回结果
return scanner.doScan(StringUtils.toStringArray(basePackages));
}
```

在parse()方法中，会创建一个ClassPathBeanDefinitionScanner类型的扫描器scanner，将@ComponentScan注解上配置的信息都设置到扫描器scanner中，最后调用扫描器scanner的doScan()方法进行扫描。

（14）解析ClassPathBeanDefinitionScanner类的doScan(String... basePackages)方法

```java
protected Set<BeanDefinitionHolder> doScan(String... basePackages) {
// 断言basePackages不为空，至少指定一个基础包
Assert.notEmpty(basePackages, "At least one base package must be specified");
Set<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<>();
for (String basePackage : basePackages) {
// 在基础包中查找候选组件
Set<BeanDefinition> candidates = findCandidateComponents(basePackage);
for (BeanDefinition candidate : candidates) {
// 解析候选组件的作用域元数据
ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
// 设置候选组件的作用域
candidate.setScope(scopeMetadata.getScopeName());
// 生成候选组件的Bean名称
String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
// 如果候选组件是AbstractBeanDefinition类型
if (candidate instanceof AbstractBeanDefinition) {
// 对候选组件进行后处理
postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
}
// 如果候选组件是AnnotatedBeanDefinition类型
if (candidate instanceof AnnotatedBeanDefinition) {
// 处理候选组件的通用定义注解
AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
}
// 检查候选组件是否满足条件
if (checkCandidate(beanName, candidate)) {
// 创建BeanDefinitionHolder对象
BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
// 应用作用域代理模式
definitionHolder =
AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
// 将BeanDefinitionHolder添加到beanDefinitions集合中
beanDefinitions.add(definitionHolder);
// 注册BeanDefinitionHolder到注册中心
registerBeanDefinition(definitionHolder, this.registry);
}
}
}
// 返回beanDefinitions集合
return beanDefinitions;
}
```

在doScan()方法中，会遍历传入的每个包路径，调用findCandidateComponents()方法来扫描带有注解（例如@Component注解）的类。

（15）解析ClassPathScanningCandidateComponentProvider类的findCandidateComponents(String basePackage)方法

```java
public Set<BeanDefinition> findCandidateComponents(String basePackage) {
// 如果组件索引不为空，并且索引支持包含过滤器
if (this.componentsIndex != null && indexSupportsIncludeFilters()) {
// 从索引中添加候选组件
return addCandidateComponentsFromIndex(this.componentsIndex, basePackage);
}
else {
// 扫描候选组件
return scanCandidateComponents(basePackage);
}
}
```

（16）解析ClassPathScanningCandidateComponentProvider类的scanCandidateComponents(String basePackage)方法

```java
private Set<BeanDefinition> scanCandidateComponents(String basePackage) {
Set<BeanDefinition> candidates = new LinkedHashSet<>();
try {
String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +
resolveBasePackage(basePackage) + '/' + this.resourcePattern;
Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);
boolean traceEnabled = logger.isTraceEnabled();
boolean debugEnabled = logger.isDebugEnabled();
for (Resource resource : resources) {
String filename = resource.getFilename();
if (filename != null && filename.contains(ClassUtils.CGLIB_CLASS_SEPARATOR)) {
// 忽略classpath中CGLIB生成的类
// Ignore CGLIB-generated classes in the classpath
continue;
}
if (traceEnabled) {
// 跟踪日志，扫描资源
logger.trace("Scanning " + resource);
}
try {
// 获取资源的元数据读取器
MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);
// 判断是否为候选组件
if (isCandidateComponent(metadataReader)) {
// 创建扫描到的泛型Bean定义
ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
// 设置资源来源
sbd.setSource(resource);
// 再次判断是否为候选组件
if (isCandidateComponent(sbd)) {
if (debugEnabled) {
// 调试日志，识别候选组件类
logger.debug("Identified candidate component class: " + resource);
}
// 将候选组件添加到候选集合中
candidates.add(sbd);
}
else {
if (debugEnabled) {
// 调试日志，忽略非具体的顶层类
logger.debug("Ignored because not a concrete top-level class: " + resource);
}
}
}
else {
if (traceEnabled) {
// 跟踪日志，忽略不符合任何过滤器的资源
logger.trace("Ignored because not matching any filter: " + resource);
}
}
}
catch (FileNotFoundException ex) {
if (traceEnabled) {
// 跟踪日志，忽略不可读资源
logger.trace("Ignored non-readable " + resource + ": " + ex.getMessage());
}
}
catch (Throwable ex) {
throw new BeanDefinitionStoreException(
// 抛出Bean定义存储异常，读取候选组件类失败
"Failed to read candidate component class: " + resource, ex);
}
}
catch (IOException ex) {
throw new BeanDefinitionStoreException("I/O failure during classpath scanning", ex);
}
return candidates;
}
```

在scanCandidateComponents()方法中，会调用isCandidateComponent()方法来判断当前注解是不是要扫描的注解。

（17）解析ClassPathScanningCandidateComponentProvider类的isCandidateComponent(MetadataReader metadataReader)方法

```java
protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException {
// 遍历排除过滤器列表
for (TypeFilter tf : this.excludeFilters) {
// 如果当前过滤器匹配给定的元数据读取器
if (tf.match(metadataReader, getMetadataReaderFactory())) {
// 返回false，表示不是候选组件
return false;
}
}
// 遍历包含过滤器列表
for (TypeFilter tf : this.includeFilters) {
// 如果当前过滤器匹配给定的元数据读取器
if (tf.match(metadataReader, getMetadataReaderFactory())) {
// 调用isConditionMatch方法判断条件是否匹配
return isConditionMatch(metadataReader);
}
}
// 如果都不匹配，则返回false，表示不是候选组件
return false;
}
```

isCandidateComponent()方法的逻辑还是比较简单的，就是遍历匹配excludeFilters和includeFilters指定的规则。

优先匹配excludeFilters指定的规则，如果匹配excludeFilters指定的规则，直接返回false。接下来，匹配includeFilters指定的规则，匹配成功，则调用isConditionMatch()方法进行条件匹配。

其中，对于includeFilters而言，默认的过滤规则如下所示。

```java
protected void registerDefaultFilters() {
this.includeFilters.add(new AnnotationTypeFilter(Component.class));
ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();
try {
this.includeFilters.add(new AnnotationTypeFilter(
((Class<? extends Annotation>) ClassUtils.forName("jakarta.annotation.ManagedBean", cl)), false));
logger.trace("JSR-250 'jakarta.annotation.ManagedBean' found and supported for component scanning");
}
catch (ClassNotFoundException ex) {
// JSR-250 1.1 API (as included in Jakarta EE) not available - simply skip.
}
try {
this.includeFilters.add(new AnnotationTypeFilter(
((Class<? extends Annotation>) ClassUtils.forName("jakarta.inject.Named", cl)), false));
logger.trace("JSR-330 'jakarta.inject.Named' annotation found and supported for component scanning");
}
catch (ClassNotFoundException ex) {
// JSR-330 API not available - simply skip.
}
}
```

对于includeFilters而言，默认的过滤规则会匹配@Component注解，JSR-250中的注解和JSR-330中的注解。

（18）回到ClassPathScanningCandidateComponentProvider类的scanCandidateComponents(String basePackage)方法

在ClassPathScanningCandidateComponentProvider类的scanCandidateComponents(String basePackage)方法中，会将标注了@Component注解，JSR-250中的注解和JSR-330中的注解的类信息封装成ScannedGenericBeanDefinition类对象，也就是类的Bean定义信息。

ScannedGenericBeanDefinition类的构造方法如下所示。

```java
public ScannedGenericBeanDefinition(MetadataReader metadataReader) {
Assert.notNull(metadataReader, "MetadataReader must not be null");
this.metadata = metadataReader.getAnnotationMetadata();
setBeanClassName(this.metadata.getClassName());
setResource(metadataReader.getResource());
}
```

（19）回到ClassPathBeanDefinitionScanner类的doScan(String... basePackages)方法

在ClassPathBeanDefinitionScanner类的doScan(String... basePackages)方法中，会将扫描到的类的Bean定义信息注册到IOC容器中，如下代码片段所示。

```java
if (checkCandidate(beanName, candidate)) {
BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
definitionHolder =
AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
beanDefinitions.add(definitionHolder);
registerBeanDefinition(definitionHolder, this.registry);
}
```

在doScan()方法中，会调用registerBeanDefinition()注册Bean定义信息。

（20）解析ClassPathBeanDefinitionScanner类的registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)方法

```java
protected void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) {
BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry);
}
```

在方法中直接调用了BeanDefinitionReaderUtils类的registerBeanDefinition()方法。

（21）解析BeanDefinitionReaderUtils类的registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)方法。

```java
public static void registerBeanDefinition(
BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
throws BeanDefinitionStoreException {

// Register bean definition under primary name.
String beanName = definitionHolder.getBeanName();
registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
	//###########省略其他代码###################
}
```

在上述代码中，会继续调用BeanDefinitionRegistry类型的对象registry的registerBeanDefinition()方法，将类的Bean定义信息注册到IOC容器。

（22）解析DefaultListableBeanFactory类的registerBeanDefinition(String beanName, BeanDefinition beanDefinition)方法

```java
@Override
public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
throws BeanDefinitionStoreException {
	//##############省略其他代码#################
BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
if (existingDefinition != null) {
//##############省略其他代码#################
this.beanDefinitionMap.put(beanName, beanDefinition);
}
else {
//##############省略其他代码#################
if (hasBeanCreationStarted()) {
// Cannot modify startup-time collection elements anymore (for stable iteration)
synchronized (this.beanDefinitionMap) {
this.beanDefinitionMap.put(beanName, beanDefinition);
List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);
updatedDefinitions.addAll(this.beanDefinitionNames);
updatedDefinitions.add(beanName);
this.beanDefinitionNames = updatedDefinitions;
removeManualSingletonName(beanName);
}
}
else {
// Still in startup registration phase
this.beanDefinitionMap.put(beanName, beanDefinition);
this.beanDefinitionNames.add(beanName);
removeManualSingletonName(beanName);
}
this.frozenBeanDefinitionNames = null;
}
if (existingDefinition != null || containsSingleton(beanName)) {
resetBeanDefinition(beanName);
}
else if (isConfigurationFrozen()) {
clearByTypeCache();
}
}
```

Spring会将扫描到的标注了符合过滤规则的注解的类封装成对应的Bean定义信息，最终会将这些Bean定义信息注册到beanDefinitionMap中。

### 思考

#### 1.Spring扫描指定包的逻辑为何复杂？

Spring扫描指定包的逻辑之所以看起来复杂，主要是因为其设计需要兼顾灵活性、可扩展性和性能。Spring的组件扫描（Component Scanning）机制允许开发者通过注解（如`@Component`、`@Service`、`@Repository`等）自动注册bean到Spring的IoC容器中，而无需显式地在XML配置文件中声明每一个bean。为了实现这一功能，Spring需要：

1. **灵活性**：允许开发者自定义扫描的包路径、过滤规则等，以适应不同的项目结构和需求。
2. **可扩展性**：通过提供TypeFilter接口等机制，允许开发者自定义过滤逻辑，以排除或包含特定的类。
3. **性能**：在大型项目中，可能需要扫描成百上千个类，Spring的扫描机制需要优化以减少扫描时间和内存消耗。

为了实现这些目标，Spring的组件扫描逻辑需要处理多种情况，包括但不限于：处理类路径资源、解析注解、应用过滤规则、注册bean定义等。

#### 2.配置类上不标注@ComponentScans或@ComponentScan能扫描到哪些包下的类？

如果在Spring Boot的配置类（通常是带有`@Configuration`注解的类）上不标注`@ComponentScans`或`@ComponentScan`注解，Spring Boot会采用默认行为。具体来说，Spring Boot会从主应用类（带有`@SpringBootApplication`注解的类）所在的包开始，扫描这个包及其子包下的所有类。这意味着，只要你的`@Component`注解的类位于主应用类所在的包或其子包下，它们就会被自动扫描并注册到IoC容器中。

#### 3.@ComponentScan注解中的basePackages或value属性可以设置任意包名吗？

是的，`@ComponentScan`注解中的`basePackages`或`value`属性可以设置任意包名（前提是这些包在类路径上确实存在）。这些属性用于指定Spring应该扫描哪些包以查找带有`@Component`、`@Service`、`@Repository`等注解的类。如果指定的包不存在于应用的类路径中，Spring在启动时会抛出异常，提示找不到指定的包。

因此，当使用`@ComponentScan`注解时，务必确保指定的包是真实存在的，并且包含了你想要自动注册为Spring bean的类。如果希望从多个不同的包中扫描组件，可以使用`@ComponentScans`注解，并在其中指定多个`@ComponentScan`。



## 1.3 @Bean注解

@Bean注解可以标注到方法上，将当前方法的返回值注入到IOC容器中。@Bean注解也可以标注到注解上，作为元注解使用。

### 注解源码

```java
@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Bean {
	//Since: 4.3.3
	@AliasFor("name")
	String[] value() default {};

	@AliasFor("value")
	String[] name() default {};
	
//Since: 5.1
	boolean autowireCandidate() default true;

	String initMethod() default "";

	String destroyMethod() default AbstractBeanDefinition.INFER_METHOD;
}
```

注解中各个属性的含义如下所示。

* name：String[]数组类型，指定注入到IOC容器中的Bean的名称，可以指定多个名称。如果不指定name属性和value属性的值，则注入到IOC容器中的Bean的名称默认是方法的名称。
* value：String[]数组类型，作用与name属性相同。
* autowireCandidate：boolean类型，表示是否支持自动按照类型注入到其他的Bean中。此属性会影响@Autowired注解，不会响应@Resource注解，默认为true，表示支持自动按照类型注入到其他的Bean中。
* initMethod：指定初始化的方法。
* destroyMethod：指定销毁的方法。

### 源码时序图

#### 注册Bean的流程

![图3-1](https://upload.yolo912.icu/mdImage/spring-core-2022-12-21-001.png)

![图3-2](https://upload.yolo912.icu/mdImage/spring-core-2022-12-21-002.png)

#### 调用初始化方法

![图3-3](https://upload.yolo912.icu/mdImage/spring-core-2022-12-21-003.png)

![图3-4](https://upload.yolo912.icu/mdImage/spring-core-2022-12-21-004.png)

#### 调用销毁方法

![图3-5](https://upload.yolo912.icu/mdImage/spring-core-2022-12-21-005.png)

### 源码解析

#### 注册bean的流程

（1）运行BeanTest类的main()方法。

在BeanTest类的main()方法中调用了AnnotationConfigApplicationContext类的构造方法，并传入了ComponentScanConfig类的Class对象来创建IOC容器。接下来，会进入AnnotationConfigApplicationContext类的构造方法。

（2）解析AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext(Class<?>... componentClasses)构造方法

```java
public AnnotationConfigApplicationContext(Class<?>... componentClasses) {
this();
register(componentClasses);
refresh();
}
```

（3）解析AbstractApplicationContext类的refresh()方法

```java
@Override
public void refresh() throws BeansException, IllegalStateException {
synchronized (this.startupShutdownMonitor) {
//############省略其他代码##############
try {
//############省略其他代码##############
invokeBeanFactoryPostProcessors(beanFactory);
   //############省略其他代码##############
}catch (BeansException ex) {
//############省略其他代码##############
}finally {
//############省略其他代码##############
}
}
}
```

（4）解析AbstractApplicationContext类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory)方法

```java
protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
if (!NativeDetector.inNativeImage() && beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
}
}
```

（5）解析PostProcessorRegistrationDelegate类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors)方法

```java
public static void invokeBeanFactoryPostProcessors(
ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {

//############省略其他代码##############
List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();

// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
String[] postProcessorNames =
beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
for (String ppName : postProcessorNames) {
if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
processedBeans.add(ppName);
}
}
sortPostProcessors(currentRegistryProcessors, beanFactory);
registryProcessors.addAll(currentRegistryProcessors);
invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());
currentRegistryProcessors.clear();

// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
for (String ppName : postProcessorNames) {
if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {
currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
processedBeans.add(ppName);
}
}
sortPostProcessors(currentRegistryProcessors, beanFactory);
registryProcessors.addAll(currentRegistryProcessors);
invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());
currentRegistryProcessors.clear();

// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
boolean reiterate = true;
while (reiterate) {
reiterate = false;
postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
for (String ppName : postProcessorNames) {
if (!processedBeans.contains(ppName)) {
currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
processedBeans.add(ppName);
reiterate = true;
}
}
sortPostProcessors(currentRegistryProcessors, beanFactory);
registryProcessors.addAll(currentRegistryProcessors);
invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());
currentRegistryProcessors.clear();
}
//############省略其他代码##############
}
```

在PostProcessorRegistrationDelegate类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors)方法中，BeanDefinitionRegistryPostProcessor的实现类在执行逻辑上会有先后顺序，并且最终都会调用invokeBeanDefinitionRegistryPostProcessors()方法。

（6）解析PostProcessorRegistrationDelegate类的invokeBeanDefinitionRegistryPostProcessors(Collection<? extends BeanDefinitionRegistryPostProcessor> postProcessors, BeanDefinitionRegistry registry, ApplicationStartup applicationStartup)方法

```java
private static void invokeBeanDefinitionRegistryPostProcessors(
Collection<? extends BeanDefinitionRegistryPostProcessor> postProcessors, BeanDefinitionRegistry registry, ApplicationStartup applicationStartup) {

for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {
StartupStep postProcessBeanDefRegistry = applicationStartup.start("spring.context.beandef-registry.post-process")
.tag("postProcessor", postProcessor::toString);
postProcessor.postProcessBeanDefinitionRegistry(registry);
postProcessBeanDefRegistry.end();
}
}
```

在invokeBeanDefinitionRegistryPostProcessors()方法中，会循环遍历postProcessors集合中的每个元素，调用postProcessBeanDefinitionRegistry()方法注册Bean的定义信息。

（7）解析ConfigurationClassPostProcessor类的postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)方法

```java
@Override
public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
	//##########省略其他代码###################
processConfigBeanDefinitions(registry);
}
```

在postProcessBeanDefinitionRegistry()方法中，会调用processConfigBeanDefinitions()方法。

（8）解析ConfigurationClassPostProcessor类的processConfigBeanDefinitions(BeanDefinitionRegistry registry)方法

```java
public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
//############省略其他代码#################
// Parse each @Configuration class
ConfigurationClassParser parser = new ConfigurationClassParser(
this.metadataReaderFactory, this.problemReporter, this.environment,
this.resourceLoader, this.componentScanBeanNameGenerator, registry);

Set<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);
Set<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());
do {
StartupStep processConfig = this.applicationStartup.start("spring.context.config-classes.parse");
parser.parse(candidates);
parser.validate();
//############省略其他代码#################
this.reader.loadBeanDefinitions(configClasses);
alreadyParsed.addAll(configClasses);
processConfig.tag("classCount", () -> String.valueOf(configClasses.size())).end();
//############省略其他代码#################
}
while (!candidates.isEmpty());
//############省略其他代码#################
}
```

在processConfigBeanDefinitions()方法中，创建了一个ConfigurationClassParser类型的对象parser，并且调用了parser的parse()方法来解析类的配置信息。

（9）解析ConfigurationClassParser类的parse(Set<BeanDefinitionHolder> configCandidates)方法

```java
public void parse(Set<BeanDefinitionHolder> configCandidates) {
for (BeanDefinitionHolder holder : configCandidates) {
BeanDefinition bd = holder.getBeanDefinition();
try {
if (bd instanceof AnnotatedBeanDefinition) {
parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
}
else if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {
parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());
}
else {
parse(bd.getBeanClassName(), holder.getBeanName());
}
}
catch (BeanDefinitionStoreException ex) {
throw ex;
}
catch (Throwable ex) {
throw new BeanDefinitionStoreException(
"Failed to parse configuration class [" + bd.getBeanClassName() + "]", ex);
}
}
this.deferredImportSelectorHandler.process();
}
```

（10）解析ConfigurationClassParser类的parse(AnnotationMetadata metadata, String beanName)方法

```java
protected final void parse(AnnotationMetadata metadata, String beanName) throws IOException {
processConfigurationClass(new ConfigurationClass(metadata, beanName), DEFAULT_EXCLUSION_FILTER);
}
```

（11）解析ConfigurationClassParser类的processConfigurationClass(ConfigurationClass configClass, Predicate<String> filter)方法

```java
protected void processConfigurationClass(ConfigurationClass configClass, Predicate<String> filter) throws IOException {
//###############省略其他代码####################
SourceClass sourceClass = asSourceClass(configClass, filter);
do {
sourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);
}
while (sourceClass != null);
this.configurationClasses.put(configClass, configClass);
}
```

在processConfigurationClass()方法中，会通过do-while()循环获取配置类和其父类的注解信息，SourceClass类中会封装配置类上注解的详细信息。在在processConfigurationClass()方法中，调用了doProcessConfigurationClass()方法。

（12）解析ConfigurationClassParser类的doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)方法

```java
protected final SourceClass doProcessConfigurationClass(
ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)
throws IOException {
//##################省略其他代码##################
// Process individual @Bean methods
Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);
for (MethodMetadata methodMetadata : beanMethods) {
configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
}
//##################省略其他代码##################
// No superclass -> processing is complete
return null;
}
```

（13）解析ConfigurationClassParser类的retrieveBeanMethodMetadata(SourceClass sourceClass)方法

```java
private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {
AnnotationMetadata original = sourceClass.getMetadata();
Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName());
if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {
try {
AnnotationMetadata asm = this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata();
Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName());
if (asmMethods.size() >= beanMethods.size()) {
Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size());
for (MethodMetadata asmMethod : asmMethods) {
for (MethodMetadata beanMethod : beanMethods) {
if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {
selectedMethods.add(beanMethod);
break;
}
}
}
if (selectedMethods.size() == beanMethods.size()) {
beanMethods = selectedMethods;
}
}
}
catch (IOException ex) {
logger.debug("Failed to read class file via ASM for determining @Bean method order", ex);
}
}
return beanMethods;
}
```

在retrieveBeanMethodMetadata()方法中主要是解析@Bean注解，并且将解析到的方法元数据存入 Set<MethodMetadata>集合中并返回。

（14）回到ConfigurationClassParser类的doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)方法。

```java
Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);
for (MethodMetadata methodMetadata : beanMethods) {
configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
}
```

调用retrieveBeanMethodMetadata()方法获取到标注了@Bean注解的方法的元数据集合后，遍历方法的元数据集合，将方法的元数据methodMetadata和配置类configClass传入BeanMethod类的构造方法，创建BeanMethod对象，并调用configClass的addBeanMethod()方法传入创建的BeanMethod对象。

configClass的addBeanMethod()方法的源码

```java
void addBeanMethod(BeanMethod method) {
this.beanMethods.add(method);
}
```

在addBeanMethod()方法中，调用了beanMethods的add()方法添加BeanMethod对象。

beanMethods的源码详见：org.springframework.context.annotation.ConfigurationClass#beanMethods，如下所示。

```java
private final Set<BeanMethod> beanMethods = new LinkedHashSet<>();
```

beanMethods是一个LinkedHashSet类型的集合。也就是说，在ConfigurationClassParser类的doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)方法中，会将解析出的标注了@Bean注解的元数据封装成BeanMethod对象，添加到一个LinkedHashSet类型的beanMethods集合中。

（15）回到ConfigurationClassPostProcessor类的processConfigBeanDefinitions(BeanDefinitionRegistry registry)方法

```java
public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
//############省略其他代码#################
do {
//############省略其他代码#################
this.reader.loadBeanDefinitions(configClasses);
alreadyParsed.addAll(configClasses);
processConfig.tag("classCount", () -> String.valueOf(configClasses.size())).end();
//############省略其他代码#################
}
while (!candidates.isEmpty());
//############省略其他代码#################
}
```

在processConfigBeanDefinitions()方法的do-while()循环中，调用了reader的loadBeanDefinitions()方法来加载Bean的定义信息。

（16）解析ConfigurationClassBeanDefinitionReader类的loadBeanDefinitions(Set<ConfigurationClass> configurationModel)方法

```java
public void loadBeanDefinitions(Set<ConfigurationClass> configurationModel) {
TrackedConditionEvaluator trackedConditionEvaluator = new TrackedConditionEvaluator();
for (ConfigurationClass configClass : configurationModel) {
loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);
}
}
```

在loadBeanDefinitions()方法中，会循环遍历传入的configurationModel集合，并调用loadBeanDefinitionsForConfigurationClass()方法处理遍历的每个元素。

（17）解析ConfigurationClassBeanDefinitionReader类的loadBeanDefinitionsForConfigurationClass(ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator)方法

```java
private void loadBeanDefinitionsForConfigurationClass(
ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) {
//###############省略其他代码################
for (BeanMethod beanMethod : configClass.getBeanMethods()) {
loadBeanDefinitionsForBeanMethod(beanMethod);
}
	//###############省略其他代码################
}
```

在loadBeanDefinitionsForConfigurationClass()方法中，会循环遍历通过configClass获取到的BeanMethod集合，并调用loadBeanDefinitionsForBeanMethod()方法处理遍历的每个BeanMethod对象。

（18）解析ConfigurationClassBeanDefinitionReader类的loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod)方法

```java
private void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {
ConfigurationClass configClass = beanMethod.getConfigurationClass();
MethodMetadata metadata = beanMethod.getMetadata();
String methodName = metadata.getMethodName();
if (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {
configClass.skippedBeanMethods.add(methodName);
return;
}
if (configClass.skippedBeanMethods.contains(methodName)) {
return;
}
AnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);
Assert.state(bean != null, "No @Bean annotation attributes");
List<String> names = new ArrayList<>(Arrays.asList(bean.getStringArray("name")));
String beanName = (!names.isEmpty() ? names.remove(0) : methodName);
for (String alias : names) {
this.registry.registerAlias(beanName, alias);
}
if (isOverriddenByExistingDefinition(beanMethod, beanName)) {
if (beanName.equals(beanMethod.getConfigurationClass().getBeanName())) {
throw new BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource().getDescription(),
   beanName, "Bean name derived from @Bean method '" + beanMethod.getMetadata().getMethodName() +
   "' clashes with bean name for containing configuration class; please make those names unique!");
}
return;
}

ConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass, metadata, beanName);
beanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));

if (metadata.isStatic()) {
// static @Bean method
if (configClass.getMetadata() instanceof StandardAnnotationMetadata sam) {
beanDef.setBeanClass(sam.getIntrospectedClass());
}
else {
beanDef.setBeanClassName(configClass.getMetadata().getClassName());
}
beanDef.setUniqueFactoryMethodName(methodName);
}
else {
// instance @Bean method
beanDef.setFactoryBeanName(configClass.getBeanName());
beanDef.setUniqueFactoryMethodName(methodName);
}

if (metadata instanceof StandardMethodMetadata sam) {
beanDef.setResolvedFactoryMethod(sam.getIntrospectedMethod());
}

beanDef.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);
AnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);

boolean autowireCandidate = bean.getBoolean("autowireCandidate");
if (!autowireCandidate) {
beanDef.setAutowireCandidate(false);
}

String initMethodName = bean.getString("initMethod");
if (StringUtils.hasText(initMethodName)) {
beanDef.setInitMethodName(initMethodName);
}

String destroyMethodName = bean.getString("destroyMethod");
beanDef.setDestroyMethodName(destroyMethodName);
ScopedProxyMode proxyMode = ScopedProxyMode.NO;
AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(metadata, Scope.class);
if (attributes != null) {
beanDef.setScope(attributes.getString("value"));
proxyMode = attributes.getEnum("proxyMode");
if (proxyMode == ScopedProxyMode.DEFAULT) {
proxyMode = ScopedProxyMode.NO;
}
}
BeanDefinition beanDefToRegister = beanDef;
if (proxyMode != ScopedProxyMode.NO) {
BeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(
new BeanDefinitionHolder(beanDef, beanName), this.registry,
proxyMode == ScopedProxyMode.TARGET_CLASS);
beanDefToRegister = new ConfigurationClassBeanDefinition(
(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata, beanName);
}

if (logger.isTraceEnabled()) {
logger.trace(String.format("Registering bean definition for @Bean method %s.%s()",
   configClass.getMetadata().getClassName(), beanName));
}
this.registry.registerBeanDefinition(beanName, beanDefToRegister);
}
```

在loadBeanDefinitionsForBeanMethod()方法中解析了@Bean注解中的属性信息，并将解析出的信息封装到一个BeanDefinition对象中，最终会调用registry对象的registerBeanDefinition()方法将封装的BeanDefinition对象注册到IOC容器中。

（19）解析DefaultListableBeanFactory类的registerBeanDefinition(String beanName, BeanDefinition beanDefinition)方法

```java
@Override
public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
throws BeanDefinitionStoreException {
	//##############省略其他代码#################
BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
if (existingDefinition != null) {
//##############省略其他代码#################
this.beanDefinitionMap.put(beanName, beanDefinition);
}
else {
//##############省略其他代码#################
if (hasBeanCreationStarted()) {
// Cannot modify startup-time collection elements anymore (for stable iteration)
synchronized (this.beanDefinitionMap) {
this.beanDefinitionMap.put(beanName, beanDefinition);
List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);
updatedDefinitions.addAll(this.beanDefinitionNames);
updatedDefinitions.add(beanName);
this.beanDefinitionNames = updatedDefinitions;
removeManualSingletonName(beanName);
}
}
else {
// Still in startup registration phase
this.beanDefinitionMap.put(beanName, beanDefinition);
this.beanDefinitionNames.add(beanName);
removeManualSingletonName(beanName);
}
this.frozenBeanDefinitionNames = null;
}
if (existingDefinition != null || containsSingleton(beanName)) {
resetBeanDefinition(beanName);
}
else if (isConfigurationFrozen()) {
clearByTypeCache();
}
}
```

Spring会解析这些标注了@Bean注解的方法，将解析出的信息封装成BeanDefinition对象注册到beanDefinitionMap中。

#### 调用初始化方法

（1）在BeanTest类的main()方法中，会调用AnnotationConfigApplicationContext类的构造方法创建IOC容器。

（2）解析AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext(Class<?>... componentClasses)方法

```java
public AnnotationConfigApplicationContext(Class<?>... componentClasses) {
this();
register(componentClasses);
refresh();
}
```

（3）解析AbstractApplicationContext类的refresh()方法

```java
@Override
public void refresh() throws BeansException, IllegalStateException {
synchronized (this.startupShutdownMonitor) {
 /*************省略其他代码**************/
try {
/*************省略其他代码**************/
// Instantiate all remaining (non-lazy-init) singletons.
finishBeanFactoryInitialization(beanFactory);
 			/*************省略其他代码**************/
}
catch (BeansException ex) {
/*************省略其他代码**************/
}
finally {
/*************省略其他代码**************/
}
}
}
```

在AbstractApplicationContext类的refresh()方法中，会调用finishBeanFactoryInitialization()方法实例化未延迟创建的单例Bean。

（4）解析AbstractApplicationContext类的finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory)方法

```java
protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
/*************省略其他代码**************/
// Instantiate all remaining (non-lazy-init) singletons.
beanFactory.preInstantiateSingletons();
}
```

在AbstractApplicationContext类的finishBeanFactoryInitialization()方法中，会调用beanFactory的preInstantiateSingletons()方法来创建非懒加载的Bean。

（5）解析DefaultListableBeanFactory类的preInstantiateSingletons()方法

```java
@Override
public void preInstantiateSingletons() throws BeansException {
   /*************省略其他代码**************/
List<String> beanNames = new ArrayList<>(this.beanDefinitionNames);
// Trigger initialization of all non-lazy singleton beans...
for (String beanName : beanNames) {
RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
/*************省略其他代码**************/
}
else {
getBean(beanName);
}
}
}
	/*************省略其他代码**************/
}
```

在DefaultListableBeanFactory类的preInstantiateSingletons()方法中，会循环遍历所有非懒加载的单例Bean的名称，调用getBean()方法创建单例Bean对象。

（6）解析AbstractBeanFactory类的getBean(String name)方法

```java
@Override
public Object getBean(String name) throws BeansException {
return doGetBean(name, null, null, false);
}
```

在AbstractBeanFactory类的getBean()方法中，会调用doGetBean()方法创建Bean对象。

（7）解析AbstractBeanFactory类的doGetBean(String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly)方法

```java
protected <T> T doGetBean(String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException {
String beanName = transformedBeanName(name);
Object beanInstance;
// Eagerly check singleton cache for manually registered singletons.
Object sharedInstance = getSingleton(beanName);
if (sharedInstance != null && args == null) {
/***********省略其他代码*************/
}
else {
/***********省略其他代码*************/
try {
/***********省略其他代码*************/
// Create bean instance.
if (mbd.isSingleton()) {
sharedInstance = getSingleton(beanName, () -> {
try {
return createBean(beanName, mbd, args);
}
catch (BeansException ex) {
/***********省略其他代码*************/
}
});
beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
}
			/***********省略其他代码*************/
}
catch (BeansException ex) {
   /***********省略其他代码*************/
}
finally {
   /***********省略其他代码*************/
}
}
return adaptBeanInstance(name, beanInstance, requiredType);
}
```

在AbstractBeanFactory类的doGetBean()方法中，会调用createBean()方法创建Bean对象。

（8）解析AbstractAutowireCapableBeanFactory类的createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)方法

```java
@Override
protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {
	/***********省略其他代码*************/
try {
Object beanInstance = doCreateBean(beanName, mbdToUse, args);
if (logger.isTraceEnabled()) {
logger.trace("Finished creating instance of bean '" + beanName + "'");
}
return beanInstance;
}
catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {
/***********省略其他代码*************/
}
catch (Throwable ex) {
/***********省略其他代码*************/
}
}
```

在AbstractAutowireCapableBeanFactory类的createBean()方法中，会调用doCreateBean()方法创建Bean对象。

（9）解析AbstractAutowireCapableBeanFactory类的doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)方法

```java
protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {
	/***********省略其他代码*************/
Object exposedObject = bean;
try {
populateBean(beanName, mbd, instanceWrapper);
exposedObject = initializeBean(beanName, exposedObject, mbd);
}
catch (Throwable ex) {
   /***********省略其他代码*************/
}
	/***********省略其他代码*************/
return exposedObject;
}
```

在AbstractAutowireCapableBeanFactory类的doCreateBean()方法中，会调用initializeBean()方法初始化Bean对象。

（10）解析AbstractAutowireCapableBeanFactory类的initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd)方法

```java
protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) {
/***********省略其他代码*************/
try {
invokeInitMethods(beanName, wrappedBean, mbd);
}
catch (Throwable ex) {
   /***********省略其他代码*************/
}
/***********省略其他代码*************/
return wrappedBean;
}
```

在AbstractAutowireCapableBeanFactory类的initializeBean()方法中，会调用invokeInitMethods()方法来调用初始化方法。

（11）解析AbstractAutowireCapableBeanFactory类的invokeInitMethods(String beanName, Object bean, @Nullable RootBeanDefinition mbd)方法

```java
protected void invokeInitMethods(String beanName, Object bean, @Nullable RootBeanDefinition mbd) throws Throwable {
	/***********省略其他代码*************/
if (mbd != null && bean.getClass() != NullBean.class) {
String[] initMethodNames = mbd.getInitMethodNames();
if (initMethodNames != null) {
for (String initMethodName : initMethodNames) {
if (StringUtils.hasLength(initMethodName) &&
!(isInitializingBean && "afterPropertiesSet".equals(initMethodName)) &&
!mbd.hasAnyExternallyManagedInitMethod(initMethodName)) {
invokeCustomInitMethod(beanName, bean, mbd, initMethodName);
}
}
}
}
}
```

在AbstractAutowireCapableBeanFactory类的invokeInitMethods()方法中，会调用invokeCustomInitMethod()方法来执行自定义的初始化方法。

（12）解析AbstractAutowireCapableBeanFactory类的invokeCustomInitMethod(String beanName, Object bean, RootBeanDefinition mbd, String initMethodName)方法

```java
protected void invokeCustomInitMethod(String beanName, Object bean, RootBeanDefinition mbd, String initMethodName)  throws Throwable {
Method initMethod = (mbd.isNonPublicAccessAllowed() ? BeanUtils.findMethod(bean.getClass(), initMethodName) : ClassUtils.getMethodIfAvailable(bean.getClass(), initMethodName));
	/***********省略其他代码*************/
Method methodToInvoke = ClassUtils.getInterfaceMethodIfPossible(initMethod, bean.getClass());
try {
ReflectionUtils.makeAccessible(methodToInvoke);
methodToInvoke.invoke(bean);
}
catch (InvocationTargetException ex) {
throw ex.getTargetException();
}
}
```

在AbstractAutowireCapableBeanFactory类的invokeCustomInitMethod()方法中，会通过Java的反射机制调用自定义的初始化方法。

#### 调用销毁方法

（1）在BeanTest类的main()方法中，会调用context对象的close()方法来关闭IOC容器

```java
public static void main(String[] args) {
AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(BeanConfig.class);
/*********省略其他代码***********/
context.close();
}
```

（2）解析AbstractApplicationContext类的close()方法

```java
@Override
public void close() {
synchronized (this.startupShutdownMonitor) {
doClose();
/*********省略其他代码***********/
}
}
```

在AbstractApplicationContext类的close()方法中，调用了doClose()方法来关闭IOC容器。

（3）解析AbstractApplicationContext类的doClose()方法

```java
protected void doClose() {
// Check whether an actual close attempt is necessary...
if (this.active.get() && this.closed.compareAndSet(false, true)) {
 /*********省略其他代码***********/
// Destroy all cached singletons in the context's BeanFactory.
destroyBeans();
 		/*********省略其他代码***********/
}
}
```

在AbstractApplicationContext类的doClose()方法中，会调用destroyBeans()方法销毁所有的单例Bean。

（4）解析AbstractApplicationContext类的destroyBeans()方法

```java
protected void destroyBeans() {
getBeanFactory().destroySingletons();
}
```

在AbstractApplicationContext类的destroyBeans()方法中，调用了beanFactory的destroySingletons()方法来销毁单例Bean。

（5）解析DefaultListableBeanFactory类的destroySingletons()方法

```java
@Override
public void destroySingletons() {
super.destroySingletons();
/*********省略其他代码***********/
}
```

在DefaultListableBeanFactory类的destroySingletons()方法中，会调用父类的destroySingletons()方法。

（6）解析DefaultSingletonBeanRegistry类的destroySingletons()方法

```java
public void destroySingletons() {
/*********省略其他代码***********/
for (int i = disposableBeanNames.length - 1; i >= 0; i--) {
destroySingleton(disposableBeanNames[i]);
}
	/*********省略其他代码***********/
}
```

在DefaultSingletonBeanRegistry类的destroySingletons()方法中，会调用destroySingleton()方法销毁指定的单例Bean对象。

（7）解析DefaultListableBeanFactory类的destroySingleton(String beanName)方法

```java
@Override
public void destroySingleton(String beanName) {
super.destroySingleton(beanName);
/*********省略其他代码***********/
}
```

在DefaultListableBeanFactory类的destroySingleton()方法中，会调用父类的destroySingleton()方法销毁指定的单例Bean。

（8）解析DefaultSingletonBeanRegistry类的destroySingleton(String beanName)方法

```java
public void destroySingleton(String beanName) {
removeSingleton(beanName);
DisposableBean disposableBean;
synchronized (this.disposableBeans) {
disposableBean = (DisposableBean) this.disposableBeans.remove(beanName);
}
destroyBean(beanName, disposableBean);
}
```

在DefaultSingletonBeanRegistry类的destroySingleton(方法中，会调用destroyBean()方法来销毁指定的单例Bean对象。

（9）解析DefaultSingletonBeanRegistry类的destroyBean(String beanName, @Nullable DisposableBean bean)方法。

```java
protected void destroyBean(String beanName, @Nullable DisposableBean bean) {
/***********省略其他代码***********/
if (bean != null) {
try {
bean.destroy();
}
catch (Throwable ex) {
/***********省略其他代码***********/
}
}
/***********省略其他代码***********/
}
```

在DefaultSingletonBeanRegistry类的destroyBean()方法中，会调用bean对象的destroy()方法销毁Bean对象。

（10）解析DisposableBeanAdapter类的destroy()方法

```java
@Override
public void destroy() {
/***********省略其他代码***********/
else if (this.destroyMethods != null) {
for (Method destroyMethod : this.destroyMethods) {
invokeCustomDestroyMethod(destroyMethod);
}
}
/***********省略其他代码***********/
}
```

在DisposableBeanAdapter类的destroy()方法中，会调用invokeCustomDestroyMethod()方法执行自定义的销毁方法。

（11）解析DisposableBeanAdapter类的invokeCustomDestroyMethod(Method destroyMethod)方法

```java
private void invokeCustomDestroyMethod(Method destroyMethod) {
/***********省略其他代码***********/
try {
ReflectionUtils.makeAccessible(destroyMethod);
destroyMethod.invoke(this.bean, args);
} catch (InvocationTargetException ex) {
/***********省略其他代码***********/
} catch (Throwable ex) {
/***********省略其他代码***********/
}
}
```

在DisposableBeanAdapter类的invokeCustomDestroyMethod()中，最终会通过Java的反射技术调用自定义的销毁方法。在本章的案例程序中，最终会调用User类的destroy()方法。

### 思考

#### 1. @Bean注解为何也是先将Bean定义信息注册到IOC容器中呢？这样做的好处是什么？

**为什么注册到IOC容器**：

`@Bean` 注解用于在配置类中声明一个Bean，并将其注册到Spring的IOC容器中。这样做的目的是为了管理Bean的生命周期，包括创建、配置、装配和销毁。将Bean定义信息（如Bean的类型、依赖、作用域等）先注册到IOC容器中，而不是立即实例化，是为了实现依赖注入（DI）和控制反转（IoC）的核心理念。

**好处**：

1. **延迟实例化**：只有当Bean真正被需要时，Spring容器才会去实例化它。这有助于减少启动时间，因为不是所有的Bean在应用程序启动时都需要被创建。
2. **依赖注入**：Spring容器能够管理Bean之间的依赖关系，并在需要时注入依赖。通过将Bean定义注册到容器中，Spring可以自动解决这些依赖关系。
3. **生命周期管理**：Spring容器可以管理Bean的整个生命周期，包括初始化（通过`initMethod`）、使用和销毁（通过`destroyMethod`）。
4. **灵活性**：将Bean定义与Bean的实例化分离，增加了配置的灵活性。例如，可以通过配置更改Bean的作用域、生命周期回调等，而无需修改Bean的实现代码。

#### 2. @Bean注解标注的方法被Spring解析后将Bean定义信息注册到IOC容器中后，何时会对注册的信息进行实例化呢？实例化的流程是怎样的？

**实例化时机**：

Bean的实例化发生在它被请求时，通常是在依赖注入时。具体来说，当一个Bean被另一个Bean依赖并请求时，Spring容器会检查该Bean是否已实例化；如果没有，则进行实例化。

**实例化流程**：

1. **Bean的查找**：当一个Bean被请求时，Spring容器首先会在容器中查找该Bean的定义。
2. **Bean的实例化**：如果找到了Bean的定义但Bean尚未实例化，Spring容器会根据Bean的定义（如通过构造函数、工厂方法或静态工厂方法等）来实例化Bean。
3. **依赖注入**：在Bean实例化后，Spring容器会检查Bean的依赖关系，并将依赖的Bean注入到当前Bean中。
4. **Bean的初始化**：在依赖注入完成后，Spring容器会调用Bean的初始化方法（如果有的话），这通常是通过Bean定义中的`initMethod`属性指定的。
5. **Bean的可用**：完成上述步骤后，Bean就准备好被应用程序使用了。

#### 3. Spring是如何调用@Bean注解中使用initMethod和destroyMethod属性指定的方法的？调用的流程是怎样的呢？

**initMethod和destroyMethod的调用**：

**initMethod的调用流程**：

1. 在Bean实例化并完成依赖注入后，Spring容器会检查Bean定义中是否指定了`initMethod`。
2. 如果指定了，Spring容器会调用该Bean的`initMethod`指定的方法，进行初始化操作。

**destroyMethod的调用流程**：

1. 当Spring容器关闭时（例如，应用程序停止时），它会开始销毁容器中的Bean。
2. 对于需要销毁的Bean，Spring容器会检查Bean定义中是否指定了`destroyMethod`。
3. 如果指定了，Spring容器会在Bean销毁前调用`destroyMethod`指定的方法，进行清理操作。

**注意**：`destroyMethod`的调用通常发生在Spring容器关闭时，而不是Bean的实例化过程中。此外，对于单例（Singleton）Bean，它们的`destroyMethod`通常只会在容器关闭时被调用一次。而对于其他作用域的Bean（如请求作用域、会话作用域等），它们的生命周期管理可能更加复杂，但基本的`initMethod`和`destroyMethod`调用流程是相似的。



## 1.4 从IOC容器中获取Bean的过程

如果是单实例Bean，则IOC容器启动时，就会创建Bean对象，IOC容器关闭时，销毁Bean对象。如果是多实例Bean，IOC容器在启动时，不会创建Bean对象，在每次从IOC容器中获取Bean对象时，都会创建新的Bean对象返回，IOC容器关闭时，也不会销毁对象。也就是说，如果是多实例Bean，IOC容器不会管理Bean对象。

### 源码时序图

![图4-1](https://upload.yolo912.icu/mdImage/spring-core-2022-12-22-001.png)

![图4-2](https://upload.yolo912.icu/mdImage/spring-core-2022-12-22-002.png)

### 源码解析

从IOC容器中获取Bean的过程的源码执行流程，结合源码执行的时序图，会理解的更加深刻。

（1）在BeanTest类的main()方法中调用了AnnotationConfigApplicationContext类的构造方法，并传入了ComponentScanConfig类的Class对象来创建IOC容器。接下来进入AnnotationConfigApplicationContext类的构造方法。

（2）解析AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext(Class<?>... componentClasses)构造方法

```java
public AnnotationConfigApplicationContext(Class<?>... componentClasses) {
this();
register(componentClasses);
refresh();
}
```

（3）解析AbstractApplicationContext类的refresh()方法

```java
@Override
public void refresh() throws BeansException, IllegalStateException {
synchronized (this.startupShutdownMonitor) {
//############省略其他代码##############
try {
//############省略其他代码##############
invokeBeanFactoryPostProcessors(beanFactory);
   //############省略其他代码##############
}catch (BeansException ex) {
//############省略其他代码##############
}finally {
//############省略其他代码##############
}
}
}
```

（4）解析AbstractApplicationContext类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory)方法

```java
protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
if (!NativeDetector.inNativeImage() && beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
}
}
```

（5）解析PostProcessorRegistrationDelegate类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors)方法

```java
public static void invokeBeanFactoryPostProcessors(
ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {

//############省略其他代码##############
List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();

// 首先，调用实现了PriorityOrdered接口的BeanDefinitionRegistryPostProcessor
// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
String[] postProcessorNames =
beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
for (String ppName : postProcessorNames) {
// 如果bean的名称匹配PriorityOrdered类型
if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
// 将该bean添加到当前注册的处理器列表中
currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
// 将已处理的bean的名称添加到已处理bean列表中
processedBeans.add(ppName);
}
}
// 对当前注册的处理器列表进行排序
sortPostProcessors(currentRegistryProcessors, beanFactory);
// 将当前注册的处理器列表添加到最终的处理器列表中
registryProcessors.addAll(currentRegistryProcessors);
// 调用当前注册的处理器列表中的BeanDefinitionRegistryPostProcessor
invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());
// 清空当前注册的处理器列表
currentRegistryProcessors.clear();

// 接下来，调用实现了Ordered接口的BeanDefinitionRegistryPostProcessor
// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
for (String ppName : postProcessorNames) {
// 如果bean的名称不在已处理bean列表中，并且匹配Ordered类型
if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {
// 将该bean添加到当前注册的处理器列表中
currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
// 将已处理的bean的名称添加到已处理bean列表中
processedBeans.add(ppName);
}
}
sortPostProcessors(currentRegistryProcessors, beanFactory);
registryProcessors.addAll(currentRegistryProcessors);
invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());
currentRegistryProcessors.clear();

// 最后，循环调用所有其他未处理的BeanDefinitionRegistryPostProcessors，直到没有新的出现
// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
boolean reiterate = true;
while (reiterate) {
reiterate = false;
// 获取所有BeanDefinitionRegistryPostProcessor类型的bean名称
postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
for (String ppName : postProcessorNames) {
// 如果该bean名称不在已处理bean列表中
if (!processedBeans.contains(ppName)) {
// 将该bean添加到当前注册的处理器列表中
currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
// 将该bean名称添加到已处理bean列表中
processedBeans.add(ppName);
// 设置需要再次循环的标志为true
reiterate = true;
}
}
// 对当前注册的处理器列表进行排序
sortPostProcessors(currentRegistryProcessors, beanFactory);
// 将当前注册的处理器列表添加到最终的处理器列表中
registryProcessors.addAll(currentRegistryProcessors);
// 调用当前注册的处理器列表中的BeanDefinitionRegistryPostProcessor
invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());
// 清空当前注册的处理器列表
currentRegistryProcessors.clear();
}
//############省略其他代码##############
}
```

（6）解析AbstractBeanFactory类的getBean(String name, Class<T> requiredType)方法

```java
@Override
public <T> T getBean(String name, Class<T> requiredType) throws BeansException {
return doGetBean(name, requiredType, null, false);
}
```

（7）解析AbstractBeanFactory类的doGetBean(String name, Class<T> requiredType, Object[] args, boolean typeCheckOnly)方法

```java
protected <T> T doGetBean(
String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly)
throws BeansException {

String beanName = transformedBeanName(name);
Object beanInstance;

// 立即检查单例缓存中是否存在手动注册的单例对象。
// Eagerly check singleton cache for manually registered singletons.
Object sharedInstance = getSingleton(beanName);
if (sharedInstance != null && args == null) {
if (logger.isTraceEnabled()) {
if (isSingletonCurrentlyInCreation(beanName)) {
// 如果bean正在创建中，记录日志信息，表示返回的是一个还未完全初始化的单例对象，是循环引用的结果。
logger.trace("Returning eagerly cached instance of singleton bean '" + beanName +
 "' that is not fully initialized yet - a consequence of a circular reference");
}
else {
// 如果bean已经创建完成，记录日志信息，表示返回的是一个已缓存的单例对象。
logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
}
}
// 获取缓存的单例对象实例，并将其转换为合适的Bean实例。
beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, null);
}
else {
// 如果已经在创建这个bean实例，则抛出异常：
// 假设我们在一个循环引用中。
// Fail if we're already creating this bean instance:
// We're assumably within a circular reference.
if (isPrototypeCurrentlyInCreation(beanName)) {
throw new BeanCurrentlyInCreationException(beanName);
}

// 检查该工厂中是否存在bean定义。
// Check if bean definition exists in this factory.
BeanFactory parentBeanFactory = getParentBeanFactory();
if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {
// 未找到 -> 检查父工厂。
// Not found -> check parent.
String nameToLookup = originalBeanName(name);
if (parentBeanFactory instanceof AbstractBeanFactory abf) {
// 委托给父工厂，并调用doGetBean方法获取bean。
// Delegation to parent with explicit doGetBean call.
return abf.doGetBean(nameToLookup, requiredType, args, typeCheckOnly);
}
else if (args != null) {
// 委托给父工厂，并传入明确的参数获取bean。
// Delegation to parent with explicit args.
return (T) parentBeanFactory.getBean(nameToLookup, args);
}
else if (requiredType != null) {
// 没有参数 -> 委托给父工厂的标准getBean方法获取bean。
// No args -> delegate to standard getBean method.
return parentBeanFactory.getBean(nameToLookup, requiredType);
}
else {
// 直接委托给父工厂获取bean。
return (T) parentBeanFactory.getBean(nameToLookup);
}
}

if (!typeCheckOnly) {
// 如果不是仅进行类型检查
markBeanAsCreated(beanName);
// 标记bean为已创建
}
// 开始记录bean创建过程
StartupStep beanCreation = this.applicationStartup.start("spring.beans.instantiate")
.tag("beanName", name);
try {
if (requiredType != null) {
// 如果requiredType不为空，则记录bean的类型信息
beanCreation.tag("beanType", requiredType::toString);
}

// 获取合并后的本地Bean定义
RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
// 检查合并后的Bean定义
checkMergedBeanDefinition(mbd, beanName, args);

// 保证当前Bean所依赖的Bean已经初始化完成
// Guarantee initialization of beans that the current bean depends on.
String[] dependsOn = mbd.getDependsOn();
if (dependsOn != null) {
for (String dep : dependsOn) {
// 如果存在循环依赖关系，则抛出异常
if (isDependent(beanName, dep)) {
throw new BeanCreationException(mbd.getResourceDescription(), beanName,
"Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
}
// 注册依赖关系
registerDependentBean(dep, beanName);
try {
// 获取依赖的Bean
getBean(dep);
}
catch (NoSuchBeanDefinitionException ex) {
// 如果找不到依赖的Bean，则抛出异常
throw new BeanCreationException(mbd.getResourceDescription(), beanName,
"'" + beanName + "' depends on missing bean '" + dep + "'", ex);
}
}
}

// 创建bean实例
// Create bean instance.
if (mbd.isSingleton()) {
// 获取单例缓存中的bean实例，如果不存在则调用lambda表达式创建
sharedInstance = getSingleton(beanName, () -> {
try {
// 调用createBean方法创建bean实例
return createBean(beanName, mbd, args);
}
catch (BeansException ex) {
// 如果创建过程中发生异常，则从单例缓存中显式移除实例
// 它可能在创建过程中被急切地放入单例缓存中，以允许解决循环引用
// 同时移除任何接收到对该bean的临时引用的bean
// Explicitly remove instance from singleton cache: It might have been put there
// eagerly by the creation process, to allow for circular reference resolution.
// Also remove any beans that received a temporary reference to the bean.
destroySingleton(beanName);
throw ex;
}
});
// 将共享的bean实例转换为适当的Bean实例对象
beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
}
else if (mbd.isPrototype()) {
// 如果Bean是单例模式，则创建一个新的实例
// It's a prototype -> create a new instance.
Object prototypeInstance = null;
try {
// 在创建原型实例之前进行预处理
beforePrototypeCreation(beanName);
// 创建原型实例
prototypeInstance = createBean(beanName, mbd, args);
}
finally {
// 在创建原型实例之后进行后处理
afterPrototypeCreation(beanName);
}
// 将原型实例转换为合适的Bean实例对象
beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
}
else {
// 获取Bean的作用域名称
String scopeName = mbd.getScope();
// 如果作用域名称为空
if (!StringUtils.hasLength(scopeName)) {
// 抛出异常，提示未定义Bean的作用域名称
throw new IllegalStateException("No scope name defined for bean '" + beanName + "'");
}
// 根据作用域名称获取对应的作用域对象
Scope scope = this.scopes.get(scopeName);
// 如果作用域对象为null
if (scope == null) {
// 抛出异常，提示未注册对应的作用域
throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
}
try {
// 调用作用域对象的get方法获取Bean的实例，并传入Lambda表达式作为参数
Object scopedInstance = scope.get(beanName, () -> {
// 在创建原型Bean之前执行的逻辑
beforePrototypeCreation(beanName);
try {
// 调用createBean方法创建Bean实例
return createBean(beanName, mbd, args);
}
finally {
// 在创建原型Bean之后执行的逻辑
afterPrototypeCreation(beanName);
}
});
// 将作用域Bean实例转换为合适的Bean实例对象
beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
}
catch (IllegalStateException ex) {
// 捕获异常，并转换为ScopeNotActiveException异常抛出
throw new ScopeNotActiveException(beanName, scopeName, ex);
}
}
}
catch (BeansException ex) {
// 添加异常类型标签
beanCreation.tag("exception", ex.getClass().toString());
// 添加异常信息标签
beanCreation.tag("message", String.valueOf(ex.getMessage()));
// 清理Bean创建失败后的资源
cleanupAfterBeanCreationFailure(beanName);
// 抛出异常
throw ex;
}
finally {
beanCreation.end();
}
}
// 调用adaptBeanInstance方法，将beanInstance适配为所需类型并返回
return adaptBeanInstance(name, beanInstance, requiredType);
}
```

doGetBean()方法的源码大体流程：

* 先通过transformedBeanName()方法转换bean的名称，可能是FactoryBean的名称（&开头），需要转成不带&开头的名称，如果有别名，再获取别名。
* 从缓存中获取bean，这里的缓存分为一二三级缓存，也就是spring的三级缓存。
* 根据获取到的对象再去获取想要的Bean，因为这里获取到的对象可能是需要的Bean，也可能是FactoryBean（工厂Bean）。
* 如果缓存中没有，就去创建Bean对象。
* 查看有没有父类的BeanFactory，如果有，那么就使用父类去创建Bean对象。
* 获取要创建的Bean对象的@DependsOn注解上的名称，先去创建DependsOn的Bean，并且校验是否存在循环引用。
* 创建Bean，根据类型创建不同的Bean，比如singleton，prototype，request，session等。
* 如果需要转换类型，则进行类型转换。如果不需要转换类型，就不转换类型。

（8）解析DefaultSingletonBeanRegistry类的getSingleton(String beanName)方法

```java
@Override
@Nullable
public Object getSingleton(String beanName) {
return getSingleton(beanName, true);
}
```

（9）解析DefaultSingletonBeanRegistry类的getSingleton(String beanName, boolean allowEarlyReference)方法

```java
@Nullable
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
// 快速检查是否存在实例，无需获取完整的单例锁
// Quick check for existing instance without full singleton lock
Object singletonObject = this.singletonObjects.get(beanName);
if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
// 尝试从早期单例对象中获取实例
singletonObject = this.earlySingletonObjects.get(beanName);
if (singletonObject == null && allowEarlyReference) {
synchronized (this.singletonObjects) {
// 在完整的单例锁下，一致地创建早期引用
// Consistent creation of early reference within full singleton lock
singletonObject = this.singletonObjects.get(beanName);
if (singletonObject == null) {
singletonObject = this.earlySingletonObjects.get(beanName);
if (singletonObject == null) {
// 尝试从单例工厂中获取实例
ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
if (singletonFactory != null) {
singletonObject = singletonFactory.getObject();
// 将实例放入早期单例对象中
this.earlySingletonObjects.put(beanName, singletonObject);
// 从单例工厂中移除对应的工厂
this.singletonFactories.remove(beanName);
}
}
}
}
}
}
return singletonObject;
}
```

Spring的三级缓存。

* singletonObjects：一级缓存，实例化的Bean都会存储在这个Map集合中。
* earlySingletonObjects：二级缓存，存放未完成的bean的缓存，如果有代理的话，存放的是代理对象。
* singletonFactories：三级缓存，存放的是一个ObjectFactory，数据通过getObject方法获得。

（10）解析AbstractBeanFactory类的getObjectForBeanInstance(Object beanInstance, String name, String beanName, RootBeanDefinition mbd)方法。

```java
protected Object getObjectForBeanInstance(
Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) {
//name是否是以&开头
if (BeanFactoryUtils.isFactoryDereference(name)) {
if (beanInstance instanceof NullBean) {
return beanInstance;
}
if (!(beanInstance instanceof FactoryBean)) {
throw new BeanIsNotAFactoryException(beanName, beanInstance.getClass());
}
if (mbd != null) {
mbd.isFactoryBean = true;
}
return beanInstance;
}
	//如果bean不是FactoryBean，直接返回beanInstance
if (!(beanInstance instanceof FactoryBean<?> factoryBean)) {
return beanInstance;
}

Object object = null;
if (mbd != null) {
mbd.isFactoryBean = true;
}
else {
// 尝试从缓存中获取FactoryBean创建的bean实例//从缓存中获取对象
object = getCachedObjectForFactoryBean(beanName);
}
if (object == null) {
// 从工厂返回bean实例
// 如果bean是单例的，则将FactoryBean创建的bean实例缓存起来
if (mbd == null && containsBeanDefinition(beanName)) {
mbd = getMergedLocalBeanDefinition(beanName);
}
boolean synthetic = (mbd != null && mbd.isSynthetic());
//通过FactoryBean获取需要的beanInstance
object = getObjectFromFactoryBean(factoryBean, beanName, !synthetic);
}
return object;
}
```

整个getObjectForBeanInstance()方法大体的流程：

* 首先判断name是不是FactoryBean的name，也就是&开头的name，如果beanInstance不是FactoryBean则抛异常。
* 如果name是FactoryBeanName，那么需要获取的就是FactoryBean，直接返回对象。

* 如果都没有返回，那么已经可以确定此时已经可以确定beanInstance是FactoryBean了，因为如果不是FactoryBean在(beanInstance instanceof FactoryBean)就已经返回了。

* 通过FactoryBean的getObject方法获取需要的Bean实例。

（11）解析DefaultSingletonBeanRegistry类的getSingleton(String beanName, ObjectFactory<?> singletonFactory)方法。

```java
public Object getSingleton(String beanName, ObjectFactory<?> singletonFactory) {
Assert.notNull(beanName, "Bean name must not be null");
synchronized (this.singletonObjects) {
// 从单例缓存中获取指定beanName的单例对象
Object singletonObject = this.singletonObjects.get(beanName);
// 如果单例对象为空
if (singletonObject == null) {
// 如果当前有单例对象正在销毁
if (this.singletonsCurrentlyInDestruction) {
//#########省略异常代码################
}
if (logger.isDebugEnabled()) {
logger.debug("Creating shared instance of singleton bean '" + beanName + "'");
}
beforeSingletonCreation(beanName);
boolean newSingleton = false;
// 记录是否需要记录被抑制的异常
boolean recordSuppressedExceptions = (this.suppressedExceptions == null);
if (recordSuppressedExceptions) {
this.suppressedExceptions = new LinkedHashSet<>();
}
try {
// 通过工厂对象获取单例对象
singletonObject = singletonFactory.getObject();
// 设置标志位，表示创建了新的单例对象
newSingleton = true;
}
catch (IllegalStateException ex) {
// 如果在获取单例对象的过程中出现了IllegalStateException异常，
// 则尝试从已存在的单例对象集合中获取单例对象
// Has the singleton object implicitly appeared in the meantime ->
// if yes, proceed with it since the exception indicates that state.
singletonObject = this.singletonObjects.get(beanName);
if (singletonObject == null) {
throw ex;
}
}
catch (BeanCreationException ex) {
if (recordSuppressedExceptions) {
// 如果需要记录被抑制的异常，则将已记录的异常添加到BeanCreationException中
for (Exception suppressedException : this.suppressedExceptions) {
ex.addRelatedCause(suppressedException);
}
}
throw ex;
}
finally {
if (recordSuppressedExceptions) {
// 清空已记录的异常集合
this.suppressedExceptions = null;
}
// 调用afterSingletonCreation方法，执行单例对象创建后的操作
afterSingletonCreation(beanName);
}
if (newSingleton) {
// 如果创建了新的单例对象，则将其添加到单例对象集合中
addSingleton(beanName, singletonObject);
}
}
return singletonObject;
}
}
```

在上述getSingleton()方法中，创建Bean对象之前调用了 beforeSingletonCreation()方法，在创建对象之后调用了afterSingletonCreation()方法。源码如下：

```java
protected void beforeSingletonCreation(String beanName) {
if (!this.inCreationCheckExclusions.contains(beanName) && !this.singletonsCurrentlyInCreation.add(beanName)) {
throw new BeanCurrentlyInCreationException(beanName);
}
}

protected void afterSingletonCreation(String beanName) {
if (!this.inCreationCheckExclusions.contains(beanName) && !this.singletonsCurrentlyInCreation.remove(beanName)) {
throw new IllegalStateException("Singleton '" + beanName + "' isn't currently in creation");
}
}
```

（12）回到AbstractBeanFactory类的doGetBean(String name, Class<T> requiredType, Object[] args, boolean typeCheckOnly)方法

```java
if (mbd.isSingleton()) {
sharedInstance = getSingleton(beanName, () -> {
try {
return createBean(beanName, mbd, args);
}
catch (BeansException ex) {
destroySingleton(beanName);
throw ex;
}
});
beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
}
```

（13）解析AbstractAutowireCapableBeanFactory类的createBean(String beanName, RootBeanDefinition mbd, Object[] args)方法

```java
@Override
protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
throws BeanCreationException {
	//##############省略其他代码############
		try {
			// 创建bean实例
			Object beanInstance = doCreateBean(beanName, mbdToUse, args);
			// 如果开启了trace级别的日志
			if (logger.isTraceEnabled()) {
				// 输出创建bean实例完成的日志
				logger.trace("Finished creating instance of bean '" + beanName + "'");
			}
			// 返回bean实例
			return beanInstance;
		}
   //##############省略其他代码############
}
```

在createBean()方法中，只是做了一些准备工作，并没有真正的创建Bean对象，真正创建Bean对象是在doCreateBean()方法中完成的。

（14）解析AbstractAutowireCapableBeanFactory类的doCreateBean(String beanName, RootBeanDefinition mbd, Object[] args)方法

```java
protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
throws BeanCreationException {

// 实例化bean
// Instantiate the bean.
BeanWrapper instanceWrapper = null;
// 如果bean是单例的
if (mbd.isSingleton()) {
// 从factoryBeanInstanceCache中移除bean的实例包装器
instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
}
// 如果实例包装器为空
if (instanceWrapper == null) {
// 创建bean的实例包装器
instanceWrapper = createBeanInstance(beanName, mbd, args);
}
// 获取bean的实例
Object bean = instanceWrapper.getWrappedInstance();
// 获取bean的类型
Class<?> beanType = instanceWrapper.getWrappedClass();
// 如果bean的类型不是NullBean类
if (beanType != NullBean.class) {
// 设置解析后的目标类型
mbd.resolvedTargetType = beanType;
}

// 允许后处理器修改合并后的bean定义
// Allow post-processors to modify the merged bean definition.
synchronized (mbd.postProcessingLock) {
if (!mbd.postProcessed) {
try {
// 应用合并后的bean定义后处理器
applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
}
catch (Throwable ex) {
throw new BeanCreationException(mbd.getResourceDescription(), beanName,
// 合并后的bean定义后处理失败
"Post-processing of merged bean definition failed", ex);
}
// 标记为已后处理
mbd.markAsPostProcessed();
}
}

// 提前缓存单例对象，以便能够解决由生命周期接口（如BeanFactoryAware）触发的循环引用问题
// Eagerly cache singletons to be able to resolve circular references
// even when triggered by lifecycle interfaces like BeanFactoryAware.
boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
  isSingletonCurrentlyInCreation(beanName));
if (earlySingletonExposure) {
// 如果允许提前暴露单例对象
if (logger.isTraceEnabled()) {
// 输出日志，表示正在提前缓存bean对象以解析潜在的循环引用问题
logger.trace("Eagerly caching bean '" + beanName +
 "' to allow for resolving potential circular references");
}
// 将beanName和获取早期bean引用的lambda表达式添加到单例工厂中
addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
}

// 初始化bean实例
// Initialize the bean instance.
Object exposedObject = bean;
try {
// 为bean填充属性
populateBean(beanName, mbd, instanceWrapper);
// 初始化bean
exposedObject = initializeBean(beanName, exposedObject, mbd);
}
catch (Throwable ex) {
// 如果异常是BeanCreationException且异常中的beanName与当前beanName相同
if (ex instanceof BeanCreationException bce && beanName.equals(bce.getBeanName())) {
// 抛出该异常
throw bce;
}
else {
// 否则，将异常封装为BeanCreationException并抛出
throw new BeanCreationException(mbd.getResourceDescription(), beanName, ex.getMessage(), ex);
}
}

if (earlySingletonExposure) {
// 获取早期单例对象的引用
Object earlySingletonReference = getSingleton(beanName, false);
if (earlySingletonReference != null) {
if (exposedObject == bean) {
// 如果当前暴露的对象和原始的bean相同，则更新暴露对象为早期单例对象引用
exposedObject = earlySingletonReference;
} else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {
// 获取依赖当前bean的其他bean的名称
String[] dependentBeans = getDependentBeans(beanName);
Set<String> actualDependentBeans = new LinkedHashSet<>(dependentBeans.length);
for (String dependentBean : dependentBeans) {
// 如果依赖的bean不是仅用于类型检查的，则添加到实际依赖的bean集合中
if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
actualDependentBeans.add(dependentBean);
}
}
if (!actualDependentBeans.isEmpty()) {
// 如果存在实际依赖的bean，则抛出异常，表示循环依赖的问题
// 省略异常信息
}
}
}
}


// 注册bean为可销毁的bean
// Register bean as disposable.
try {
// 如果需要，将bean注册为可销毁的bean
registerDisposableBeanIfNecessary(beanName, bean, mbd);
}
catch (BeanDefinitionValidationException ex) {
// 抛出BeanCreationException异常，包含资源描述、bean名称、错误信息以及原始异常
throw new BeanCreationException(
mbd.getResourceDescription(), beanName, "Invalid destruction signature", ex);
}
// 返回暴露的对象
return exposedObject;
}
```

doCreateBean()方法的逻辑大体的流程如下：

* 调用createBeanInstance()方法创建bean。

* 调用属于applyMergedBeanDefinitionPostProcessors()方法。对Bean进行一些处理。
* 将bean加入到三级缓存中。
* 填充Bean需要注入的其他Bean对象。
* 调用初始化方法，先去调用@PostConstruct注解方法，然后调用InitializingBean的afterPropertiesSet，以及自定义的init-method方法。在Bean调用初始化方法之后，再去调用后置处理器接口检测是否需要生成Aop代理。
* 接着进行校验。如果从二级缓存能取到，那就说明之前已经从三级缓存获取过。可能是因为循环依赖，也可能是因为别的地方调用了getBean方法。从三级缓存获取时有个getEarlyBeanReference()的方法，就是查看是否要生成代理的bean。如果已经生成代理的Bean，那么在调用初始化方法时，就不会在生成代理Bean了。这样满足exposedObject ==bean，直接只用代理返回。

* 如果exposedObject和bean不相等：这里的情况就是：如果是spring的@Async注解，在从二级缓存生成代理之后，再去调用初始化方法时，一样会生成代理。所以此时exposedObject不等于bean，再往下发现有循环调用，并且Bean还在创建时，就会抛出异常。

### 思考

#### 1.**Spring为何会有循环依赖的问题？**

Spring的循环依赖问题指的是两个或多个Bean在创建过程中互相引用对方，形成了一个闭环，导致无法完成创建。这种情况通常发生在属性注入的情况下。例如，A类依赖B类，B类又依赖A类。在Spring容器初始化时，如果按顺序创建这两个Bean，当创建A时需要注入B，而B还未创建完成，因为B又需要A，这就形成了一个循环依赖。

#### 2.**Spring如何解决循环依赖问题？**

Spring通过使用三级缓存来解决循环依赖问题：

1. **一级缓存（singletonObjects）**：存放已经初始化完成的Bean。
2. **二级缓存（earlySingletonObjects）**：存放早期的Bean引用，即已经实例化但未初始化的Bean。
3. **三级缓存（singletonFactories）**：存放能够生成Bean的工厂对象。

当A类创建时，首先将其工厂对象放入三级缓存，在实例化A后，将A的早期引用放入二级缓存，并从三级缓存中移除其工厂对象。当A需要注入B时，发现B还未创建，就去创建B。B在创建过程中需要A，这时就可以从二级缓存中获取A的早期引用注入B，从而打破了循环依赖。

#### 3.**Spring为何使用三级缓存解决循环依赖问题？使用二级缓存不行吗？为什么？**

使用二级缓存在某些情况下可能无法解决循环依赖问题，特别是涉及到AOP时。三级缓存中存放的是Bean工厂对象，这个工厂能够生成代理对象。如果只有二级缓存，那么当A类需要被代理时（比如使用了@Transactional注解），在注入B类时就直接注入了A的原始对象，而不是代理对象，这会导致AOP功能失效。三级缓存确保了即使在循环依赖的情况下，也能返回正确的代理对象。当B类尝试获取A类时，可以从三级缓存中得到一个工厂对象，这个工厂在必要时能够生成A的代理，保证了AOP能够正常工作。



## 1.5 @Import注解

@Import注解可以将第三方包中的类对象注入到IOC容器中。Spring底层大量使用了@Import注解来向IOC容器中注入Bean对象。

@Import注解只能标注到类或其他注解上，通常与配置类一起使用的，使用此注解引入的类上可以不再使用@Configuration，@Component等注解标注。

### 注解源码

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Import {
	Class<?>[] value();
}
```

* value：Class数组类型，用于指定其他配置类的字节码，支持指定多个配置类。另外value属性指定的必须是普通类、实现了ImportSelector接口的类和实现了ImportBeanDefinitionRegistrar接口的类。

**注意：@Import注解只能标注到类上。**



### 源码时序图

![图5-1](https://upload.yolo912.icu/mdImage/spring-core-2023-02-24-001.png)

![图5-2](https://upload.yolo912.icu/mdImage/spring-core-2023-02-24-002.png)

![图5-3](https://upload.yolo912.icu/mdImage/spring-core-2023-02-24-003.png)

### 源码解析

（1）运行ImportTest类的main()方法中，调用了AnnotationConfigApplicationContext类的构造方法，并传入了ImportConfig类的Class对象来创建IOC容器。接下来，会进入AnnotationConfigApplicationContext类的构造方法。

（2）解析AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext(Class<?>... componentClasses)构造方法

```java
public AnnotationConfigApplicationContext(Class<?>... componentClasses) {
this();
register(componentClasses);
refresh();
}
```

（3）解析AbstractApplicationContext类的refresh()方法

```java
@Override
public void refresh() throws BeansException, IllegalStateException {
synchronized (this.startupShutdownMonitor) {
//############省略其他代码##############
try {
//############省略其他代码##############
invokeBeanFactoryPostProcessors(beanFactory);
   //############省略其他代码##############
}catch (BeansException ex) {
//############省略其他代码##############
}finally {
//############省略其他代码##############
}
}
}
```

（4）解析AbstractApplicationContext类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory)方法

```java
protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
if (!NativeDetector.inNativeImage() && beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
}
}
```

（5）解析PostProcessorRegistrationDelegate类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors)方法

核心的逻辑如下：

```java
public static void invokeBeanFactoryPostProcessors(
ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {

//############省略其他代码##############
List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();

// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
String[] postProcessorNames =
beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
for (String ppName : postProcessorNames) {
if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
processedBeans.add(ppName);
}
}
sortPostProcessors(currentRegistryProcessors, beanFactory);
registryProcessors.addAll(currentRegistryProcessors);
invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());
currentRegistryProcessors.clear();

// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
for (String ppName : postProcessorNames) {
if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {
currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
processedBeans.add(ppName);
}
}
sortPostProcessors(currentRegistryProcessors, beanFactory);
registryProcessors.addAll(currentRegistryProcessors);
invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());
currentRegistryProcessors.clear();

// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
boolean reiterate = true;
while (reiterate) {
reiterate = false;
postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
for (String ppName : postProcessorNames) {
if (!processedBeans.contains(ppName)) {
currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
processedBeans.add(ppName);
reiterate = true;
}
}
sortPostProcessors(currentRegistryProcessors, beanFactory);
registryProcessors.addAll(currentRegistryProcessors);
invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());
currentRegistryProcessors.clear();
}
//############省略其他代码##############
}
```

（6）解析PostProcessorRegistrationDelegate类的invokeBeanDefinitionRegistryPostProcessors(Collection<? extends BeanDefinitionRegistryPostProcessor> postProcessors, BeanDefinitionRegistry registry, ApplicationStartup applicationStartup)方法

```java
private static void invokeBeanDefinitionRegistryPostProcessors(
Collection<? extends BeanDefinitionRegistryPostProcessor> postProcessors, BeanDefinitionRegistry registry, ApplicationStartup applicationStartup) {

for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {
StartupStep postProcessBeanDefRegistry = applicationStartup.start("spring.context.beandef-registry.post-process")
.tag("postProcessor", postProcessor::toString);
postProcessor.postProcessBeanDefinitionRegistry(registry);
postProcessBeanDefRegistry.end();
}
}
```

（7）解析ConfigurationClassPostProcessor类的postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)方法

```java
@Override
public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
	//##########省略其他代码###################
processConfigBeanDefinitions(registry);
}
```

（8）解析ConfigurationClassPostProcessor类的processConfigBeanDefinitions(BeanDefinitionRegistry registry)方法

重点逻辑如下：

```java
public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
//############省略其他代码#################
// Parse each @Configuration class
ConfigurationClassParser parser = new ConfigurationClassParser(
this.metadataReaderFactory, this.problemReporter, this.environment,
this.resourceLoader, this.componentScanBeanNameGenerator, registry);

Set<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);
Set<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());
do {
StartupStep processConfig = this.applicationStartup.start("spring.context.config-classes.parse");
parser.parse(candidates);
parser.validate();
//############省略其他代码#################
this.reader.loadBeanDefinitions(configClasses);
alreadyParsed.addAll(configClasses);
processConfig.tag("classCount", () -> String.valueOf(configClasses.size())).end();
//############省略其他代码#################
}
while (!candidates.isEmpty());
//############省略其他代码#################
}
```

在processConfigBeanDefinitions()方法中，创建了一个ConfigurationClassParser类型的对象parser，并且调用了parser的parse()方法来解析类的配置信息。

（9）解析ConfigurationClassParser类的parse(Set<BeanDefinitionHolder> configCandidates)方法

```java
public void parse(Set<BeanDefinitionHolder> configCandidates) {
for (BeanDefinitionHolder holder : configCandidates) {
BeanDefinition bd = holder.getBeanDefinition();
try {
if (bd instanceof AnnotatedBeanDefinition) {
parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
}
//###############省略其他代码###############
}
catch (BeanDefinitionStoreException ex) {
throw ex;
}
catch (Throwable ex) {
throw new BeanDefinitionStoreException(
"Failed to parse configuration class [" + bd.getBeanClassName() + "]", ex);
}
}
this.deferredImportSelectorHandler.process();
}
```

（10）解析ConfigurationClassParser类的parse(AnnotationMetadata metadata, String beanName)方法

```java
protected final void parse(AnnotationMetadata metadata, String beanName) throws IOException {
processConfigurationClass(new ConfigurationClass(metadata, beanName), DEFAULT_EXCLUSION_FILTER);
}
```

（11）解析ConfigurationClassParser类的processConfigurationClass(ConfigurationClass configClass, Predicate<String> filter)方法

```java
protected void processConfigurationClass(ConfigurationClass configClass, Predicate<String> filter) throws IOException {
//###############省略其他代码####################
SourceClass sourceClass = asSourceClass(configClass, filter);
do {
sourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);
}
while (sourceClass != null);
this.configurationClasses.put(configClass, configClass);
}
```

在processConfigurationClass()方法中，会通过do-while()循环获取配置类和其父类的注解信息，SourceClass类中会封装配置类上注解的详细信息。

（12）解析ConfigurationClassParser类的doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)方法

重点代码片段如下：

```java
protected final SourceClass doProcessConfigurationClass(
ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)
throws IOException {
	 //#############省略其他代码#############
// Process any @Import annotations
processImports(configClass, sourceClass, getImports(sourceClass), filter, true);
//#############省略其他代码#############
// No superclass -> processing is complete
return null;
}
```

在doProcessConfigurationClass()方法中，会调用processImports()方法来解析@Import注解。

（13）解析ConfigurationClassParser类的processImports(ConfigurationClass configClass, SourceClass currentSourceClass, Collection<SourceClass> importCandidates, Predicate<String> exclusionFilter, boolean checkForCircularImports)方法。

```java
private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass,
Collection<SourceClass> importCandidates, Predicate<String> exclusionFilter,
boolean checkForCircularImports) {
	//################省略其他代码#################
this.importStack.push(configClass);
try {
for (SourceClass candidate : importCandidates) {
// 引入的是实现了ImportSelector接口的类
if (candidate.isAssignable(ImportSelector.class)) {
// Candidate class is an ImportSelector -> delegate to it to determine imports
Class<?> candidateClass = candidate.loadClass();
ImportSelector selector = ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class, this.environment, this.resourceLoader, this.registry);
Predicate<String> selectorFilter = selector.getExclusionFilter();
if (selectorFilter != null) {
exclusionFilter = exclusionFilter.or(selectorFilter);
}
if (selector instanceof DeferredImportSelector) {
this.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector);
}
else {
// 调用ImportSelector接口的selectImports()方法获取要注入到IOC容器中的Bean名称数组
String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
Collection<SourceClass> importSourceClasses = asSourceClasses(importClassNames, exclusionFilter);
processImports(configClass, currentSourceClass, importSourceClasses, exclusionFilter, false);
}
}
// 引入的是实现了ImportBeanDefinitionRegistrar接口的类
else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
// Candidate class is an ImportBeanDefinitionRegistrar ->
// delegate to it to register additional bean definitions
Class<?> candidateClass = candidate.loadClass();
ImportBeanDefinitionRegistrar registrar =
ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class,
 this.environment, this.resourceLoader, this.registry);
configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
}
else {
// Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar ->
// process it as an @Configuration class
this.importStack.registerImport(
currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter);
}
}
}
catch (BeanDefinitionStoreException ex) {
throw ex;
}
catch (Throwable ex) {
throw new BeanDefinitionStoreException(
"Failed to process import candidates for configuration class [" +
configClass.getMetadata().getClassName() + "]: " + ex.getMessage(), ex);
}
finally {
this.importStack.pop();
}
}
```

在processImports()方法中，如果使用@Import注解引入的是实现了ImportSelector接口的类，则执行的是` if (candidate.isAssignable(ImportSelector.class)) `条件的逻辑。如果@Import注解引入的是实现了ImportBeanDefinitionRegistrar接口的类，则执行的是` else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class))`条件的逻辑，否则执行的是`else`条件的逻辑。

其中，执行`  if (selector instanceof DeferredImportSelector) { `条件的逻辑时，会调用ImportSelector接口的selectImports()方法获取要注入到IOC容器中的Bean名称数组，如下所示。

```java
String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
```

调用ImportSelector接口的selectImports()方法时，就会调用案例程序中的MyImportSelector类的selectImports()方法。

（14）解析MyImportSelector类的selectImports(AnnotationMetadata importingClassMetadata)方法

```java
@Override
public String[] selectImports(AnnotationMetadata importingClassMetadata) {
return new String[]{ImportSelectorBean.class.getName()};
}
```

在MyImportSelector类的selectImports()方法中，会返回包含ImportSelectorBean类的全类名的String数组，后续会将ImportSelectorBean类的Bean对象注入IOC容器。

（15）回到ConfigurationClassParser类的processImports(ConfigurationClass configClass, SourceClass currentSourceClass, Collection<SourceClass> importCandidates, Predicate<String> exclusionFilter, boolean checkForCircularImports)方法。

如果@Import注解引入的是实现了ImportBeanDefinitionRegistrar接口的类，则执行的是` else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class))`条件的逻辑，如下所示。

```java
else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
Class<?> candidateClass = candidate.loadClass();
ImportBeanDefinitionRegistrar registrar =
ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class, this.environment, this.resourceLoader, this.registry);
configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
}
```

在上述代码逻辑中会调用configClass的addImportBeanDefinitionRegistrar()方法来添加ImportBeanDefinitionRegistrar对象。

（16）解析ConfigurationClass类的addImportBeanDefinitionRegistrar(ImportBeanDefinitionRegistrar registrar, AnnotationMetadata importingClassMetadata)方法

```java
void addImportBeanDefinitionRegistrar(ImportBeanDefinitionRegistrar registrar, AnnotationMetadata importingClassMetadata) {
this.importBeanDefinitionRegistrars.put(registrar, importingClassMetadata);
}
```

在addImportBeanDefinitionRegistrar()方法中，会将传入的registrar参数作为Key，importingClassMetadata参数作为Value存储importBeanDefinitionRegistrars结构中。

importBeanDefinitionRegistrars结构的定义如下所示。

```java
private final Map<ImportBeanDefinitionRegistrar, AnnotationMetadata> importBeanDefinitionRegistrars = new LinkedHashMap<>();
```

importBeanDefinitionRegistrars是一个LinkedHashMap对象，也就是会将ImportBeanDefinitionRegistrar对象和AnnotationMetadata对象的映射关系存入一个LinkedHashMap对象中。

（17）再次回到ConfigurationClassParser类的processImports(ConfigurationClass configClass, SourceClass currentSourceClass, Collection<SourceClass> importCandidates, Predicate<String> exclusionFilter, boolean checkForCircularImports)方法。

如果@Import注解引入的类既没有实现ImportSelector接口，又没有实现ImportBeanDefinitionRegistrar接口，则执行`else`逻辑

```java
else {
this.importStack.registerImport(
currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter);
}
```

在`else`逻辑中，会按照解析@Configuration注解的逻辑执行

其实，在processImports()方法中，如果@Import注解引入的类实现了ImportSelector接口，并且没有实现DeferredImportSelector接口的话，最终还是会执行processImports()方法的`else`逻辑。

（18）回到ConfigurationClassPostProcessor类的processConfigBeanDefinitions(BeanDefinitionRegistry registry)方法。

在ConfigurationClassPostProcessor类的processConfigBeanDefinitions()方法中，执行完ConfigurationClassParser类的parse()方法后，会执行ConfigurationClassBeanDefinitionReader类的loadBeanDefinitions()方法，如下所示。

```java
this.reader.loadBeanDefinitions(configClasses);
```

（19）解析ConfigurationClassBeanDefinitionReader类的loadBeanDefinitions(Set<ConfigurationClass> configurationModel)方法

```java
public void loadBeanDefinitions(Set<ConfigurationClass> configurationModel) {
TrackedConditionEvaluator trackedConditionEvaluator = new TrackedConditionEvaluator();
for (ConfigurationClass configClass : configurationModel) {
loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);
}
}
```

在loadBeanDefinitions()方法中，会循环遍历传入的configurationModel集合，并调用loadBeanDefinitionsForConfigurationClass()方法处理遍历的每个元素。

（20）解析ConfigurationClassBeanDefinitionReader类的loadBeanDefinitionsForConfigurationClass(ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator)方法

```java
private void loadBeanDefinitionsForConfigurationClass(ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) {
//################省略其他代码######################
if (configClass.isImported()) {
registerBeanDefinitionForImportedConfigurationClass(configClass);
}
for (BeanMethod beanMethod : configClass.getBeanMethods()) {
loadBeanDefinitionsForBeanMethod(beanMethod);
}

loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());
loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());
}
```

在loadBeanDefinitionsForConfigurationClass()方法中，如果@Import注解引入的是普通的类，或者是实现了ImportSelector接口的类，则会执行`if (configClass.isImported())`条件的逻辑，此时会调用registerBeanDefinitionForImportedConfigurationClass()方法向IOC容器中注入配置类的BeanDefinition信息。

（21）解析ConfigurationClassBeanDefinitionReader类的registerBeanDefinitionForImportedConfigurationClass(ConfigurationClass configClass)方法

```java
private void registerBeanDefinitionForImportedConfigurationClass(ConfigurationClass configClass) {
//###############省略其他代码#################
BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(configBeanDef, configBeanName);
definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
  this.registry.registerBeanDefinition(definitionHolder.getBeanName(),definitionHolder.getBeanDefinition());
configClass.setBeanName(configBeanName);
	//###############省略其他代码#################
}
```

在registerBeanDefinitionForImportedConfigurationClass()方法中会调用DefaultListableBeanFactory类的registerBeanDefinition()方法向IOC容器中注入BeanDefinition信息。最终，会将BeanDefinition信息保存到DefaultListableBeanFactory类的beanDefinitionMap中。

（22）回到ConfigurationClassBeanDefinitionReader类的loadBeanDefinitionsForConfigurationClass(ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator)方法

如果@Import注解引入的是实现了ImportBeanDefinitionRegistrar接口的类，则在loadBeanDefinitionsForConfigurationClass()方法中调用loadBeanDefinitionsFromRegistrars()方法时，会通过configClass的getImportBeanDefinitionRegistrars()方法获取第（16）步保存信息的LinkedHashMap对象。

（23）解析ConfigurationClass类的getImportBeanDefinitionRegistrars()方法

```java
Map<ImportBeanDefinitionRegistrar, AnnotationMetadata> getImportBeanDefinitionRegistrars() {
return this.importBeanDefinitionRegistrars;
}
```

（24）再次ConfigurationClassBeanDefinitionReader类的loadBeanDefinitionsForConfigurationClass(ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator)方法。

在loadBeanDefinitionsForConfigurationClass()会调用loadBeanDefinitionsFromRegistrars()方法从实现了ImportBeanDefinitionRegistrar接口的类中加载Bean定义信息。

（25）解析ConfigurationClassBeanDefinitionReader类的loadBeanDefinitionsFromRegistrars(Map<ImportBeanDefinitionRegistrar, AnnotationMetadata> registrars)方法

```java
private void loadBeanDefinitionsFromRegistrars(Map<ImportBeanDefinitionRegistrar, AnnotationMetadata> registrars) {
registrars.forEach((registrar, metadata) -> registrar.registerBeanDefinitions(metadata, this.registry, this.importBeanNameGenerator));
}
```

在loadBeanDefinitionsFromRegistrars()方法中，会遍历传入的registrars，并调用每个registrar的registerBeanDefinitions()方法注册BeanDefinition信息。

（26）解析ImportBeanDefinitionRegistrar接口的registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry,BeanNameGenerator importBeanNameGenerator)方法

```java
default void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry,BeanNameGenerator importBeanNameGenerator) {
registerBeanDefinitions(importingClassMetadata, registry);
}
```

registerBeanDefinitions()方法是ImportBeanDefinitionRegistrar接口的一个默认方法，并在方法中调用了另一个registerBeanDefinitions()方法。其中调用的这个registerBeanDefinitions()方法就是我们自己实现了ImportBeanDefinitionRegistrar接口的类中具体实现的registerBeanDefinitions()方法。

（27）解析MyImportBeanDefinitionRegistrar类的registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)方法

```java
@Override
public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
String beanName = ImportBeanDefinitionRegistrarBean.class.getName();
BeanDefinition beanDefinition = new RootBeanDefinition(ImportBeanDefinitionRegistrarBean.class);
registry.registerBeanDefinition(beanName, beanDefinition);
}
```

在registerBeanDefinitions()方法中，最终会调用DefaultListableBeanFactory类的registerBeanDefinition()方法向IOC容器中注入BeanDefinition信息。最终会将BeanDefinition信息保存到DefaultListableBeanFactory类的beanDefinitionMap中。

### 思考

#### 1. 在ConfigurationClassParser类的processImports()中，如果@Import注解引入的是普通类或者引入的是实现了ImportSelector接口，并且没有实现DeferredImportSelector接口的类，最终还是会执行processImports()方法的`else`逻辑。那么最终是如何执行`else`逻辑的？

当`@Import`注解引入的是普通类或者引入的是实现了`ImportSelector`接口且没有实现`DeferredImportSelector`接口的类时，以下是一般会发生的过程：

1. `processImports()`方法会检查通过`@Import`注解引入的类。
2. 如果引入的类不是`ImportSelector`或者`ImportBeanDefinitionRegistrar`，那么它将被视为一个普通的配置类。
3. 对于实现了`ImportSelector`接口的类，如果它没有实现`DeferredImportSelector`接口，那么它的`selectImports()`方法会被调用以返回一个字符串数组，这些字符串代表了需要被导入的配置类的名称。
4. 对于每个通过`selectImports()`返回的配置类名称，Spring会尝试加载这些类，并递归地调用`processImports()`方法处理这些新加载的配置类。



#### 2. @Import注解的三种案例在Spring底层的源码执行流程分别是什么？

1. **直接导入配置类**：
   - Spring直接解析导入的类，将其视为配置类，并处理其上的注解（如@Bean、@Import等）。
2. **导入实现了ImportSelector接口的类**：
   - 实例化ImportSelector实现类。
   - 调用其`selectImports()`方法获取要导入的类名或配置类。
   - 对这些类进行解析和处理。
3. **导入实现了DeferredImportSelector接口的类**：
   - 与ImportSelector类似，但DeferredImportSelector允许导入操作被延迟到所有常规的ImportSelector和@Configuration类都被处理之后。
   - 这在需要基于其他Bean的存在性条件导入Bean时特别有用

#### 3. 使用@Import注解向IOC容器中注入Bean与使用@Bean注解有什么区别？

- **@Import**：用于导入配置类，可以导入一个或多个类，这些类可以包含@Bean注解定义的Bean，或者它们自身是ImportSelector/DeferredImportSelector的实现，用于动态选择Bean的导入。它主要用于模块化和重用配置。
- **@Bean**：在配置类中声明一个Bean，并指定其创建逻辑（通过方法）。它允许更细粒度地控制Bean的创建过程，包括依赖注入、初始化等。



## 1.6 @PropertySource注解

@PropertySource注解是Spring中提供的一个通过指定配置文件位置来加载配置文件的注解，并且可以将配置文件中的内容存放到Spring的环境变量中。除了可以通过Spring的环境变量读取配置项之外，还可以通过@Value注解获取配置项的值。另外，Spring中还提供了一个@PropertySources注解，在@PropertySources注解注解中，可以引入多个@PropertySource注解。

### 注解源码

**1.@PropertySource注解**

@PropertySource注解只能标注到类上，能够通过指定配置文件的位置来加载配置文件，@PropertySource注解除了可以加载properties配置文件外，也可以加载xml配置文件和yml配置文件。如果加载yml配置文件时，可以自定义PropertySourceFactory实现yml配置文件的解析操作。

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Repeatable(PropertySources.class)
public @interface PropertySource {
	String name() default "";
	String[] value();
	/**
	 * @since 4.0
	 */
	boolean ignoreResourceNotFound() default false;
	/**
	 * @since 4.3
	 */
	String encoding() default "";
	/**
	 * @since 4.3
	 */
	Class<? extends PropertySourceFactory> factory() default PropertySourceFactory.class;
}
```

注解中各个属性的含义如下所示。

* name：表示加载的资源的名称，如果为空，则会根据加载的配置文件自动生成一个名称。
* value：表示加载的资源的路径，这个路径可以是类路径，也可以是文件路径。
* ignoreResourceNotFound：表示当配置文件未找到时，是否忽略文件未找到的错误。默认值为false，也就是说当未找到配置文件时，Spring启动就会报错。
* encoding：表示解析配置文件使用的字符集编码。
* factory：表示读取对应配置文件的工厂类，默认的工厂类是PropertySourceFactory。

**2.@PropertySources注解**

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface PropertySources {
	PropertySource[] value();
}
```

提供了一个PropertySource数组类型的value属性。@PropertySources注解可引入多个@PropertySource注解。

### 源码时序图

![图6-1](https://upload.yolo912.icu/mdImage/spring-core-2023-02-25-001.png)

![图6-2](https://upload.yolo912.icu/mdImage/spring-core-2023-02-25-002.png)

### 源码解析

（1）运行PropertySourceTest类的main()方法，调用了AnnotationConfigApplicationContext类的构造方法并传入了PropertySourceConfig类的Class对象来创建IOC容器。

**@PropertySource注解在Spring源码中的执行流程的（2）~（11）步与@Import注解相同，这里直接跳到ConfigurationClassParser类的doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)方法。**

（2）解析ConfigurationClassParser类的doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)方法

```java
protected final SourceClass doProcessConfigurationClass(
ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)
throws IOException {
//#############省略其他代码################
for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
sourceClass.getMetadata(), PropertySources.class,
org.springframework.context.annotation.PropertySource.class)) {
if (this.propertySourceRegistry != null) {
this.propertySourceRegistry.processPropertySource(propertySource);
}
}
	//#############省略其他代码################
}
```

在ConfigurationClassParser类的doProcessConfigurationClass()方法中，遍历获取到的@PropertySources注解和@PropertySource注解的属性，并且调用propertySourceRegistry对象的processPropertySource()方法解析注解属性的值。

（3）解析PropertySourceRegistry类的processPropertySource(AnnotationAttributes propertySource)方法

```java
void processPropertySource(AnnotationAttributes propertySource) throws IOException {
String name = propertySource.getString("name");
if (!StringUtils.hasLength(name)) {
name = null;
}
String encoding = propertySource.getString("encoding");
if (!StringUtils.hasLength(encoding)) {
encoding = null;
}
String[] locations = propertySource.getStringArray("value");
Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required");
boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound");
Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory");
Class<? extends PropertySourceFactory> factorClassToUse = (factoryClass != PropertySourceFactory.class ? factoryClass : null);
PropertySourceDescriptor descriptor = new PropertySourceDescriptor(Arrays.asList(locations), ignoreResourceNotFound, name, factorClassToUse, encoding);
this.propertySourceProcessor.processPropertySource(descriptor);
this.descriptors.add(descriptor);
}
```

在PropertySourceRegistry类的processPropertySource()方法中，解析@PropertySource注解中的属性后，将解析出的属性值封装到PropertySourceDescriptor对象中，调用propertySourceProcessor对象的processPropertySource()方法，并传入PropertySourceDescriptor对象进行进一步处理。

（4）解析PropertySourceProcessor类的processPropertySource(PropertySourceDescriptor descriptor)方法

```java
public void processPropertySource(PropertySourceDescriptor descriptor) throws IOException {
String name = descriptor.name();
String encoding = descriptor.encoding();
List<String> locations = descriptor.locations();
Assert.isTrue(locations.size() > 0, "At least one @PropertySource(value) location is required");
boolean ignoreResourceNotFound = descriptor.ignoreResourceNotFound();
PropertySourceFactory factory = (descriptor.propertySourceFactory() != null ? instantiateClass(descriptor.propertySourceFactory()) : DEFAULT_PROPERTY_SOURCE_FACTORY);
for (String location : locations) {
try {
String resolvedLocation = this.environment.resolveRequiredPlaceholders(location);
Resource resource = this.resourceLoader.getResource(resolvedLocation);
addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)));
}
catch (IllegalArgumentException | FileNotFoundException | UnknownHostException | SocketException ex) {
			//#########省略其他代码################
}
}
}
```

在processPropertySource()方法中，会通过@PropertySource注解的属性值解析出配置文件的内容，并且通过factory对象的createPropertySource()方法来创建PropertySource对象。

（5）解析DefaultPropertySourceFactory类的createPropertySource(String name, EncodedResource resource)方法

```java
@Override
public PropertySource<?> createPropertySource(String name, EncodedResource resource) throws IOException {
return (name != null ? new ResourcePropertySource(name, resource) : new ResourcePropertySource(resource));
}
```

（6）回到PropertySourceProcessor类的processPropertySource(PropertySourceDescriptor descriptor)方法

在PropertySourceProcessor类的processPropertySource()方法中，创建完PropertySource对象后，会调用addPropertySource()方法将获取到的属性值添加到Spring的环境变量中。

（7）解析PropertySourceProcessor类的addPropertySource(PropertySource<?> propertySource)方法

```java
private void addPropertySource(org.springframework.core.env.PropertySource<?> propertySource) {
String name = propertySource.getName();
MutablePropertySources propertySources = this.environment.getPropertySources();
if (this.propertySourceNames.contains(name)) {
org.springframework.core.env.PropertySource<?> existing = propertySources.get(name);
if (existing != null) {
PropertySource<?> newSource = (propertySource instanceof ResourcePropertySource ?((ResourcePropertySource) propertySource).withResourceName() : propertySource);
if (existing instanceof CompositePropertySource) {
((CompositePropertySource) existing).addFirstPropertySource(newSource);
}
else {
if (existing instanceof ResourcePropertySource) {
existing = ((ResourcePropertySource) existing).withResourceName();
}
CompositePropertySource composite = new CompositePropertySource(name);
composite.addPropertySource(newSource);
composite.addPropertySource(existing);
propertySources.replace(name, composite);
}
return;
        }
    }
    if (this.propertySourceNames.isEmpty()) {
        propertySources.addLast(propertySource);
    }
    else {
        String firstProcessed = this.propertySourceNames.get(this.propertySourceNames.size() - 1);
        propertySources.addBefore(firstProcessed, propertySource);
    }
    this.propertySourceNames.add(name);
}
```

在PropertySourceProcessor类的addPropertySource()方法中，会将解析出的配置文件的内容添加到Spring的环境变量中。具体就是在PropertySourceProcessor类的addPropertySource()方法中，获取到ConfigurableEnvironment中的MutablePropertySources对象，用来存储解析出的配置文件中的配置项内容。如果有相同的配置项内容，将existing对象强转为CompositePropertySource类型，把新旧相同的配置项进行合并，再放到MutablePropertySources对象中。后续就可以通过Spring的环境变量，来获取到配置文件中的配置项内容。

### 思考

#### 1. @PropertySource注解的执行流程

@PropertySource注解的执行流程主要涉及Spring框架在启动时如何处理和加载配置文件。执行流程：

1. **配置类扫描**：Spring容器在启动时，会扫描所有带有@Configuration、@Component等注解的类，以发现配置信息。
2. **注解识别**：在扫描到的配置类中，Spring会识别@PropertySource注解。该注解用于指定一个或多个属性文件的位置。
3. **加载配置文件**：根据@PropertySource注解中指定的路径（如classpath:config.properties），Spring会尝试加载这些配置文件。如果指定了多个文件，Spring会按照声明的顺序加载它们。
4. **解析配置文件**：加载配置文件后，Spring会解析文件中的配置项，将它们作为键值对存储在内存中。
5. **添加到环境变量**：解析出的配置项会被添加到Spring的环境变量（Environment）中，这样它们就可以在应用程序的任何地方通过占位符（如${app.name}）来访问了。
6. **属性注入**：在配置类或其他组件中，可以通过@Value注解将环境变量中的配置项注入到字段、方法参数或构造函数参数中。

#### 2. @PropertySource注解是如何将配置文件加载到环境变量的？

@PropertySource注解通过以下步骤将配置文件加载到Spring的环境变量中：

1. **注解声明**：在配置类上使用@PropertySource注解，并指定配置文件的位置。
2. **配置加载**：Spring容器在启动时，会识别并使用PropertySourceLoader（默认是DefaultPropertySourceLoader）来加载@PropertySource注解指定的配置文件。
3. **解析与存储**：加载的配置文件会被解析成一系列的键值对，并作为PropertySource对象存储在Spring的环境变量（ConfigurableEnvironment）中。每个PropertySource对象都有一个唯一的名称，用于区分不同的配置源。
4. **环境变量集成**：最终，这些PropertySource对象会被集成到Spring的环境变量中，使得应用程序可以通过环境变量接口（如Environment接口）来访问这些配置项。

#### 3. @PropertySource注解的使用场景

@PropertySource注解的使用场景主要包括以下几个方面：

1. **配置文件分离**：在大型项目中，可能需要将不同的配置项分散到不同的配置文件中，以便于管理和维护。@PropertySource注解允许开发者指定多个配置文件的位置，从而实现配置文件的分离。
2. **动态配置**：在某些情况下，应用程序可能需要根据不同的环境（如开发环境、测试环境、生产环境）来加载不同的配置文件。通过使用@PropertySource注解和Spring的profiles功能，可以轻松实现动态配置。
3. **外部化配置**：将配置项从代码中分离出来，放到外部的配置文件中，可以提高代码的可维护性和可配置性。@PropertySource注解是实现外部化配置的一种有效方式。
4. **加密配置**：对于敏感信息（如数据库密码、API密钥等），可能需要将其加密后存储在配置文件中。通过使用自定义的PropertySourceLoader和加密/解密机制，可以安全地加载和使用这些加密的配置项。



## 1.7 @DependsOn注解

@DependsOn注解是Spring中提供的一个指定Spring创建Bean的依赖顺序的注解。例如，在Spring中需要创建A对象和B对象，可以使用@DependsOn注解指定创建A对象时依赖B对象，此时，在Spring中就会先创建B对象，然后再创建A对象。

### 注解源码

@DependsOn注解可以标注到类或方法上，可以控制bean的创建、初始化和销毁方法的执行顺序。

```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface DependsOn {
	String[] value() default {};
}
```

* value：表示指定的Bean的唯一标识，被指定的Bean会在Spring创建当前Bean之前被创建。

### 注解使用场景

@DependsOn注解主要用于指定当前Bean对象所依赖的其他Bean对象。Spring在创建当前Bean之前，会先创建由@DependsOn注解指定的依赖Bean，使用@DependsOn注解的场景通常会有以下几种场景：

（1）在某些情况下，Bean不是通过`属性`或`构造函数参数`显式依赖于另一个Bean的，但是却需要在创建一个Bean对象之前，需要先创建另一个Bean对象，此时就可以使用@DependsOn注解。

（2）在单例Bean的情况下`@DependsOn`既可以指定**初始化依赖顺序**，也可以指定Bean相应的**销毁执行顺序**。

（3）@DependsOn注解可标注到任何直接或间接带有@Component注解的Bean或标注到@Bean注解的方法上，可以控制Bean的创建、初始化和销毁方法执行顺序。

（4）观察者模式可以分为事件，事件源和监听器三个组件，如果在Spring中需要实现观察者模式时，就可以使用@DependsOn注解实现监听器的Bean对象在事件源的Bean对象之前被创建。

### 源码时序图

#### 注册Bean的源码时序图

![图7-1](https://upload.yolo912.icu/mdImage/spring-core-2023-02-27-001.png)

#### 调用Bean工厂后置处理器的源码时序图

![图7-2](https://upload.yolo912.icu/mdImage/spring-core-2023-02-27-002.png)

![图7-3](https://upload.yolo912.icu/mdImage/spring-core-2023-02-27-003.png)

####  创建Bean的源码时序图

![图7-5](https://upload.yolo912.icu/mdImage/spring-core-2023-02-27-005.png)

### 源码解析

#### 注册Bean的源码流程

（1）运行DependsOnTest类的main()方法，调用了AnnotationConfigApplicationContext类的构造方法并传入了DependsOnConfig类的Class对象来创建IOC容器。

（2）解析AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext(Class<?>... componentClasses)构造方法

```java
public AnnotationConfigApplicationContext(Class<?>... componentClasses) {
    this();
    register(componentClasses);
    refresh();
}
```

（3）解析AnnotationConfigApplicationContext类的register(Class<?>... componentClasses) 方法

```java
@Override
public void register(Class<?>... componentClasses) {
    /************省略其他代码***************/
    this.reader.register(componentClasses);
    registerComponentClass.end();
}
```

（4）解析AnnotatedBeanDefinitionReader类的register(Class<?>... componentClasses)方法

```java
public void register(Class<?>... componentClasses) {
    for (Class<?> componentClass : componentClasses) {
        registerBean(componentClass);
    }
}
```

在AnnotatedBeanDefinitionReader类的register()方法中，会循环遍历传入的componentClasses数组，并将遍历出的每个componentClass元素作为参数调用registerBean()方法注册Bean。

（5）解析AnnotatedBeanDefinitionReader类的registerBean(Class<?> beanClass)方法

```java
public void registerBean(Class<?> beanClass) {
    doRegisterBean(beanClass, null, null, null, null);
}
```

（6）解析AnnotatedBeanDefinitionReader类的doRegisterBean(Class<T> beanClass, String name, Class<? extends Annotation>[] qualifiers, Supplier<T> supplier, BeanDefinitionCustomizer[] customizers)方法

```java
private <T> void doRegisterBean(Class<T> beanClass, @Nullable String name, @Nullable Class<? extends Annotation>[] qualifiers, @Nullable Supplier<T> supplier, @Nullable BeanDefinitionCustomizer[] customizers) {
    /******************省略其他代码**********************/
    AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);
    /******************省略其他代码**********************/
    BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);
    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
    BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
}
```

（7）解析AnnotationConfigUtils类的processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd)方法

```java
public static void processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd) {
    processCommonDefinitionAnnotations(abd, abd.getMetadata());
}
```

（8）解析AnnotationConfigUtils类的processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata)方法

```java
static void processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata) {
    AnnotationAttributes lazy = attributesFor(metadata, Lazy.class);
    if (lazy != null) {
        abd.setLazyInit(lazy.getBoolean("value"));
    }
    else if (abd.getMetadata() != metadata) {
        lazy = attributesFor(abd.getMetadata(), Lazy.class);
        if (lazy != null) {
            abd.setLazyInit(lazy.getBoolean("value"));
        }
    }

    if (metadata.isAnnotated(Primary.class.getName())) {
        abd.setPrimary(true);
    }
    AnnotationAttributes dependsOn = attributesFor(metadata, DependsOn.class);
    if (dependsOn != null) {
        abd.setDependsOn(dependsOn.getStringArray("value"));
    }

    AnnotationAttributes role = attributesFor(metadata, Role.class);
    if (role != null) {
        abd.setRole(role.getNumber("value").intValue());
    }
    AnnotationAttributes description = attributesFor(metadata, Description.class);
    if (description != null) {
        abd.setDescription(description.getString("value"));
    }
}
```

在processCommonDefinitionAnnotations()方法中解析了@DependsOn注解，并将解析出的@DependsOn注解中的value属性的值设置到AnnotatedBeanDefinition对象的dependsOn属性中。

（9）回到AnnotatedBeanDefinitionReader类的doRegisterBean(Class<T> beanClass, String name, Class<? extends Annotation>[] qualifiers, Supplier<T> supplier, BeanDefinitionCustomizer[] customizers)方法。

在AnnotatedBeanDefinitionReader类的doRegisterBean()方法中，会调用BeanDefinitionReaderUtils类的registerBeanDefinition()方法，并将封装了@DependsOn注解属性的abd对象和beanName封装成BeanDefinitionHolder对象，并且与registry一起作为参数传递给BeanDefinitionReaderUtils类的registerBeanDefinition()方法。

（10）解析BeanDefinitionReaderUtils类的registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)方法

```java
public static void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException {
    String beanName = definitionHolder.getBeanName();
    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
    String[] aliases = definitionHolder.getAliases();
    if (aliases != null) {
        for (String alias : aliases) {
            registry.registerAlias(beanName, alias);
        }
    }
}
```

（11）解析DefaultListableBeanFactory类的registerBeanDefinition(String beanName, BeanDefinition beanDefinition)方法

```java
@Override
public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException {
	/*********省略其他代码**********/
	BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
	if (existingDefinition != null) {
		/*********省略其他代码**********/
	}
	else {
		/*********省略其他代码**********/
		else {
			// Still in startup registration phase
			this.beanDefinitionMap.put(beanName, beanDefinition);
			this.beanDefinitionNames.add(beanName);
			removeManualSingletonName(beanName);
		}
		this.frozenBeanDefinitionNames = null;
	}
    /*********省略其他代码**********/
}
```

在DefaultListableBeanFactory类的registerBeanDefinition()方法中，会将beanName为Key，beanDefinition对象作为Value保存到beanDefinitionMap中。

#### 调用Bean工厂后置处理器的源码流程

**@DependsOn注解在Spring源码层面调用Bean工厂后置处理器的执行流程，执行到ConfigurationClassParser类的doProcessConfigurationClass()方法之前的逻辑与解析@Import注解的代码流程相同，直接从ConfigurationClassParser类的doProcessConfigurationClass()方法开始解析。**

（1）解析ConfigurationClassParser类的doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)方法

```java
protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter) throws IOException {
    /****************省略其他代码****************/
    Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(
        sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
    if (!componentScans.isEmpty() &&
        !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
        for (AnnotationAttributes componentScan : componentScans) {
            Set<BeanDefinitionHolder> scannedBeanDefinitions =
                this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
                BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
                if (bdCand == null) {
                    bdCand = holder.getBeanDefinition();
                }
                if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
                    parse(bdCand.getBeanClassName(), holder.getBeanName());
                }
            }
        }
    }
    /****************省略其他代码****************/
    return null;
}
```

在ConfigurationClassParser类的doProcessConfigurationClass()方法中，会调用componentScanParser的parse()方法来解析配置类上的注解。

（2）解析ComponentScanAnnotationParser类的parse(AnnotationAttributes componentScan, String declaringClass)方法

```java
public Set<BeanDefinitionHolder> parse(AnnotationAttributes componentScan, String declaringClass) {
    /***********省略其他代码*************/
    return scanner.doScan(StringUtils.toStringArray(basePackages));
}
```

在ComponentScanAnnotationParser类的parse()方法中，会调用scanner对象的doScan()方法扫描@ComponentScan注解中basePackages属性设置的包名。

（3）解析ClassPathBeanDefinitionScanner类中的doScan(String... basePackages)方法

```java
protected Set<BeanDefinitionHolder> doScan(String... basePackages) {
    Assert.notEmpty(basePackages, "At least one base package must be specified");
    Set<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<>();
    for (String basePackage : basePackages) {
        Set<BeanDefinition> candidates = findCandidateComponents(basePackage);
        for (BeanDefinition candidate : candidates) {
            /************省略其他代码************/
            if (candidate instanceof AnnotatedBeanDefinition) {
                AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
            }
            if (checkCandidate(beanName, candidate)) {
                BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
                definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
                beanDefinitions.add(definitionHolder);
                registerBeanDefinition(definitionHolder, this.registry);
            }
        }
    }
    return beanDefinitions;
}
```

在ClassPathBeanDefinitionScanner类中的doScan()方法中，会调用AnnotationConfigUtils类的processCommonDefinitionAnnotations()方法来解析注解的信息。

另外，在ClassPathBeanDefinitionScanner类中的doScan()方法中，会调用registerBeanDefinition()方法来注册BeanDefinition信息。

（4）解析ClassPathBeanDefinitionScanner类的registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)方法

```java
protected void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) {
    BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry);
}
```

可以看到，在ClassPathBeanDefinitionScanner类的registerBeanDefinition()方法中，直接调用了BeanDefinitionReaderUtils类的registerBeanDefinition()方法来注册BeanDefinition信息。

（5）解析BeanDefinitionReaderUtils类的registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)方法

```java
public static void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)throws BeanDefinitionStoreException {
    String beanName = definitionHolder.getBeanName();
    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
    /*********省略其他代码************/
}
```

在BeanDefinitionReaderUtils类的registerBeanDefinition()方法中，最终就会调用DefaultListableBeanFactory类的registerBeanDefinition()方法来注册BeanDefinition信息。

#### 创建Bean的源码流程

**@DependsOn注解在Spring源码层面创建Bean的执行流程，执行到AbstractApplicationContext类的refresh()方法的逻辑，与解析@Import注解执行到AbstractApplicationContext类的refresh()方法的逻辑相同**

（1）解析AbstractApplicationContext类的refresh()方法

```java
@Override
public void refresh() throws BeansException, IllegalStateException {
    synchronized (this.startupShutdownMonitor) {
       /*********省略其他代码************/
        try {
            /*********省略其他代码************/
            finishBeanFactoryInitialization(beanFactory);
			/*********省略其他代码************/
        }
        catch (BeansException ex) {
            /*********省略其他代码************/
        }
        finally {
            /*********省略其他代码************/
        }
    }
}
```

在refresh()中会调用finishBeanFactoryInitialization()方法来完成非懒加载的单实例Bean的初始化工作。

（2）解析finishBeanFactoryInitialization类的finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory)方法

```java
protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
    /*******省略其他代码*******/
    beanFactory.preInstantiateSingletons();
}
```

在finishBeanFactoryInitialization类的finishBeanFactoryInitialization()方法中，会调用beanFactory对象的preInstantiateSingletons()方法来初始化所有的非懒加载的单实例Bean。

（3）解析DefaultListableBeanFactory类的preInstantiateSingletons()方法

```java
@Override
public void preInstantiateSingletons() throws BeansException {
    /*********省略其他代码*********/
    for (String beanName : beanNames) {
        RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
        if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
            if (isFactoryBean(beanName)) {
                Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
                if (bean instanceof SmartFactoryBean<?> smartFactoryBean && smartFactoryBean.isEagerInit()) {
                    getBean(beanName);
                }
            }
            else {
                getBean(beanName);
            }
        }
    }
	/*********省略其他代码*********/
}
```

在DefaultListableBeanFactory类的preInstantiateSingletons()方法中，会遍历beanDefinitionNames集合中所有的beanName，并调用getBean()方法初始化所有非懒加载的单实例Bean。

（4）解析AbstractBeanFactory类的getBean(String name)方法

```java
@Override
public Object getBean(String name) throws BeansException {
    return doGetBean(name, null, null, false);
}
```

在AbstractBeanFactory类的getBean()方法中，直接调用了doGetBean()方法来初始化非懒加载的单实例Bean。

（5）解析AbstractBeanFactory类的doGetBean(String name, Class<T> requiredType, Object[] args, boolean typeCheckOnly)方法

源码详见：org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean(String name, Class<T> requiredType, Object[] args, boolean typeCheckOnly)。重点关注如下代码片段。

```java
protected <T> T doGetBean(String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException {
	/*************省略其他代码**************/
	else {
		/*************省略其他代码**************/
		try {
			/*************省略其他代码**************/
			String[] dependsOn = mbd.getDependsOn();
			if (dependsOn != null) {
				for (String dep : dependsOn) {
					if (isDependent(beanName, dep)) {
						throw new BeanCreationException(mbd.getResourceDescription(), beanName,
								"Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
					}
					registerDependentBean(dep, beanName);
					try {
						getBean(dep);
					}
					catch (NoSuchBeanDefinitionException ex) {
						throw new BeanCreationException(mbd.getResourceDescription(), beanName,
								"'" + beanName + "' depends on missing bean '" + dep + "'", ex);
					}
				}
			}
			/*************省略其他代码**************/
		}
		catch (BeansException ex) {
			beanCreation.tag("exception", ex.getClass().toString());
			beanCreation.tag("message", String.valueOf(ex.getMessage()));
			cleanupAfterBeanCreationFailure(beanName);
			throw ex;
		}
		finally {
			beanCreation.end();
		}
	}
	return adaptBeanInstance(name, beanInstance, requiredType);
}
```

在AbstractBeanFactory类的doGetBean()方法中，会获取这些被依赖的beanName，按照数组顺序，再调用AbstractBeanFactory类的getBean()方法来优先创建被依赖的Bean，从而达到控制依赖顺序的目的。



### 思考

#### 1. @DependsOn注解的作用

@DependsOn注解的作用是用于指定一个bean的依赖关系，确保该bean在Spring容器中的初始化顺序。当一个bean依赖于其他bean的初始化完成时，可以使用@DependsOn注解来声明这种依赖关系。这样，Spring容器在初始化bean时，会先确保所有被@DependsOn注解声明的依赖bean都已经完成初始化，然后再进行当前bean的初始化。

#### 2. Bean的循环依赖与@DependsOn注解的关系

Bean的循环依赖指的是两个或多个bean互相依赖，形成一个闭环，导致Spring在实例化这些bean时遇到的问题。具体来说，当尝试初始化一个bean A时，发现它依赖于另一个bean B，而在尝试初始化bean B时，又发现它反过来依赖于bean A，这就构成了一个循环依赖。

**@DependsOn注解与Bean循环依赖的关系**是：**@DependsOn注解并不直接解决循环依赖问题**。它主要用于控制bean的初始化顺序，而不是解决循环依赖。实际上，Spring框架通过一种称为“三级缓存”的机制来解决bean的循环依赖问题。这种机制确保了即使在存在循环依赖的情况下，Spring也能够正确地创建和初始化bean。

需要注意的是，虽然@DependsOn注解可以用于显式地声明bean之间的依赖关系，但如果错误地用于解决循环依赖（例如，两个bean互相使用@DependsOn注解声明对方为依赖），这将会导致Spring无法正确地初始化这些bean，因为它们会陷入一个无限循环的依赖关系中。因此，在实际应用中，应该避免创建循环依赖关系，并考虑通过重新设计类和接口来解决这个问题。



## 1.8 @Conditional注解

@Conditional注解支持按照条件向IOC容器中注册Bean，满足条件的Bean就会被注册到IOC容器中，不满足条件的Bean就不会被注册到IOC容器中。

### 注解源码

```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Conditional {
	Class<? extends Condition>[] value();
}
```

* value：指定Condition接口的实现类，Condition接口的实现类中需要编写具体代码实现向Spring中注入Bean的条件。

使用场景：

- 可以作为类级别的注解直接或者间接的与@Component相关联，包括@Configuration类。
- 可以作为元注解，用于自动编写构造性注解。
- 作为方法级别的注解，作用在任何@Bean的方法上。

### 源码时序图

![图8-1](https://upload.yolo912.icu/mdImage/spring-core-2023-02-28-001.png)

![图8-2](https://upload.yolo912.icu/mdImage/spring-core-2023-02-28-002.png)

### 源码解读

（1）解析AnnotatedBeanDefinitionReader类的doRegisterBean(Class<T> beanClass, String name, Class<? extends Annotation>[] qualifiers, Supplier<T> supplier, BeanDefinitionCustomizer[] customizers)方法

```java
private <T> void doRegisterBean(Class<T> beanClass, @Nullable String name, @Nullable Class<? extends Annotation>[] qualifiers, @Nullable Supplier<T> supplier, @Nullable BeanDefinitionCustomizer[] customizers) {
    AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(beanClass);
    if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) {
        return;
    }
    abd.setInstanceSupplier(supplier);
    ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);
    abd.setScope(scopeMetadata.getScopeName());
    String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));
    AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);
    if (qualifiers != null) {
        for (Class<? extends Annotation> qualifier : qualifiers) {
            if (Primary.class == qualifier) {
                abd.setPrimary(true);
            }
            else if (Lazy.class == qualifier) {
                abd.setLazyInit(true);
            }
            else {
                abd.addQualifier(new AutowireCandidateQualifier(qualifier));
            }
        }
    }
    if (customizers != null) {
        for (BeanDefinitionCustomizer customizer : customizers) {
            customizer.customize(abd);
        }
    }
    BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);
    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
    BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
}
```

在AnnotatedBeanDefinitionReader类的doRegisterBean()方法中，调用了conditionEvaluator对象的shouldSkip()方法判断是否要忽略当前Bean的注册。

（2）解析ConditionEvaluator类的shouldSkip(AnnotatedTypeMetadata metadata)方法

```java
public boolean shouldSkip(AnnotatedTypeMetadata metadata) {
    return shouldSkip(metadata, null);
}
```

在ConditionEvaluator类的shouldSkip()方法中，直接调用了另一个重载的shouldSkip()方法。

（3）解析ConditionEvaluator类的shouldSkip(AnnotatedTypeMetadata metadata, ConfigurationPhase phase)方法

```java
public boolean shouldSkip(@Nullable AnnotatedTypeMetadata metadata, @Nullable ConfigurationPhase phase) {
    if (metadata == null || !metadata.isAnnotated(Conditional.class.getName())) {
        return false;
    }

    if (phase == null) {
        if (metadata instanceof AnnotationMetadata &&
            ConfigurationClassUtils.isConfigurationCandidate((AnnotationMetadata) metadata)) {
            return shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION);
        }
        return shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN);
    }

    List<Condition> conditions = new ArrayList<>();
    for (String[] conditionClasses : getConditionClasses(metadata)) {
        for (String conditionClass : conditionClasses) {
            Condition condition = getCondition(conditionClass, this.context.getClassLoader());
            conditions.add(condition);
        }
    }

    AnnotationAwareOrderComparator.sort(conditions);

    for (Condition condition : conditions) {
        ConfigurationPhase requiredPhase = null;
        if (condition instanceof ConfigurationCondition) {
            requiredPhase = ((ConfigurationCondition) condition).getConfigurationPhase();
        }
        if ((requiredPhase == null || requiredPhase == phase) && !condition.matches(this.context, metadata)) {
            return true;
        }
    }

    return false;
}
```

在shouldSkip()方法中，首先会判断类或方法上是否标注了@Conditional注解，如果没有标注@Conditional注解，则直接返回false，此时对应的Bean会被创建并注入到IOC容器中。否则，会解析@Conditional注解中的value属性设置的Class对象，将Class对象的全类名解析到conditionClasses数组中，遍历conditionClasses数组中的每个元素生成Condition对象，将Condition对象存入conditions集合中。后续会遍历conditions集合中的每个Condition对象，调用matches()方法，此处的逻辑与matches()方法的返回值正好相反。

* matches()方法返回false，则此处返回true，表示对应的Bean不会被创建，也不会注入到IOC容器中。
* matches()方法返回true，则此处返回false，表示对应的Bean会被创建并且会注入到IOC容器中。

后面代码会回到AnnotatedBeanDefinitionReader类的doRegisterBean()方法继续执行后续流程

### 扩展注解

**@ConditionalOnBean**：仅仅在当前上下文中存在某个对象时，才会实例化一个Bean。

**@ConditionalOnClass**：某个class位于类路径上，才会实例化一个Bean。

**@ConditionalOnExpression**：当表达式为true的时候，才会实例化一个Bean。

**@ConditionalOnMissingBean**：仅仅在当前上下文中不存在某个对象时，才会实例化一个Bean。

**@ConditionalOnMissingClass**：某个class类路径上不存在的时候，才会实例化一个Bean。

**@ConditionalOnNotWebApplication**：不是web应用，才会实例化一个Bean。

**@ConditionalOnBean**：当容器中有指定Bean的条件下进行实例化。

**@ConditionalOnMissingBean**：当容器里没有指定Bean的条件下进行实例化。

**@ConditionalOnClass**：当classpath类路径下有指定类的条件下进行实例化。

**@ConditionalOnMissingClass**：当类路径下没有指定类的条件下进行实例化。

**@ConditionalOnWebApplication**：当项目是一个Web项目时进行实例化。

**@ConditionalOnNotWebApplication**：当项目不是一个Web项目时进行实例化。

**@ConditionalOnProperty**：当指定的属性有指定的值时进行实例化。

**@ConditionalOnExpression**：基于SpEL表达式的条件判断。

**@ConditionalOnJava**：当JVM版本为指定的版本范围时触发实例化。

**@ConditionalOnResource**：当类路径下有指定的资源时触发实例化。

**@ConditionalOnJndi**：在JNDI存在的条件下触发实例化。

**@ConditionalOnSingleCandidate**：当指定的Bean在容器中只有一个，或者有多个但是指定了首选的Bean时触发实例化。

### 思考

#### 1. @Conditional注解的作用是什么？

`@Conditional` 注解在Spring框架中用于条件化地创建bean。它允许基于满足特定条件来决定是否创建（或注册）一个bean。这个条件可以是任何形式的逻辑，比如某个类是否存在、某个属性是否被设置等。

#### 2. @Conditional注解有哪些使用场景？

1. **环境特定的配置**：根据不同的运行环境（开发、测试、生产）来激活不同的配置bean。
2. **条件性的依赖注入**：只有在某些条件满足时，才注入特定的bean。
3. **可选的依赖**：当某个库或模块可用时，才启用相关的功能或组件。
4. **功能切换**：基于外部配置或环境变量来启用或禁用特定的功能。

#### 3. @Conditional注解与@Profile注解有什么区别？

- **目的不同**：`@Profile` 注解主要用于按环境激活不同的配置，如开发、测试和生产环境。而`@Conditional` 更通用，可以基于任何条件来决定bean的创建。
- **灵活性**：`@Conditional` 提供了更高的灵活性，因为它允许你定义自己的条件类，而`@Profile` 仅基于预定义的环境名称。
- **使用场景**：`@Profile` 通常用于环境配置，而`@Conditional` 可以用在任何需要基于条件进行bean注册的场景。

#### 4. @Conditional注解在Spring内层的执行流程？

1. **解析Bean定义**：Spring容器在启动时，会解析配置文件或注解中的bean定义。
2. **检查@Conditional注解**：对于带有`@Conditional`注解的bean定义，Spring会检查这个注解指定的条件类。
3. **条件评估**：Spring会实例化条件类，并调用其`matches`方法，传入当前的环境（如`Environment`）和其他相关的bean定义信息。
4. **注册Bean**：如果`matches`方法返回`true`，表示条件满足，Spring将会注册这个bean；否则，bean将被忽略。
5. **依赖注入和Bean初始化**：对于满足条件的bean，Spring将进行依赖注入和初始化，使其可供应用程序使用。



## 1.9 @Lazy注解

@Lazy注解可以标注到类、方法、构造方法、参数和属性字段上，能够实现在启动IOC容器时，不创建单例Bean，而是在第一次使用时创建单例Bean对象。

### 注解源码

```java
@Target({ElementType.TYPE, ElementType.METHOD, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Lazy {
	boolean value() default true;
}
```

value：boolean类型的属性，表示是否延迟创建单例Bean，默认值为true。

* true：表示延迟创建单例Bean，此时在IOC启动时不会创建Bean对象，而是在第一次使用时创建单例Bean对象。
* false：表示不延迟创建单例Bean对象，IOC容器启动时，就会创建单例Bean对象。

**@Lazy注解只对单例Bean对象起作用，如果使用@Scope注解指定为多例Bean对象，则@Lazy注解将不起作用。**

### 源码时序图

#### 注册Bean的源码时序图

![图9-1](https://upload.yolo912.icu/mdImage/spring-core-2023-03-01-001.png)

#### 调用Bean后置处理器的源码时序图

![图9-2](https://upload.yolo912.icu/mdImage/spring-core-2023-03-01-002.png)

![图9-3](https://upload.yolo912.icu/mdImage/spring-core-2023-03-01-003.png)

![图9-4](https://upload.yolo912.icu/mdImage/spring-core-2023-03-01-004.png)

#### 创建单例Bean的源码时序图

![图9-5](https://upload.yolo912.icu/mdImage/spring-core-2023-03-01-005.png)

### 源码解析

#### 注册Bean的源码流程

（1）解析AnnotatedBeanDefinitionReader类的doRegisterBean(Class<T> beanClass, String name, Class<? extends Annotation>[] qualifiers, Supplier<T> supplier, BeanDefinitionCustomizer[] customizers)方法

```java
private <T> void doRegisterBean(Class<T> beanClass, @Nullable String name, @Nullable Class<? extends Annotation>[] qualifiers, @Nullable Supplier<T> supplier, @Nullable BeanDefinitionCustomizer[] customizers) {
	/***********省略其他代码************/
    AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);
    if (qualifiers != null) {
        for (Class<? extends Annotation> qualifier : qualifiers) {
            if (Primary.class == qualifier) {
                abd.setPrimary(true);
            }
            else if (Lazy.class == qualifier) {
                abd.setLazyInit(true);
            }
            else {
                abd.addQualifier(new AutowireCandidateQualifier(qualifier));
            }
        }
    }
    /**********省略其他代码************/
    BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);
    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
    BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
}
```

在AnnotatedBeanDefinitionReader类的doRegisterBean()方法中，调用了AnnotationConfigUtils类的processCommonDefinitionAnnotations()方法。

（2）解析AnnotationConfigUtils类的processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd)方法

```java
public static void processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd) {
    processCommonDefinitionAnnotations(abd, abd.getMetadata());
}
```

在AnnotationConfigUtils类的processCommonDefinitionAnnotations()方法中，直接调用了另一个重载的processCommonDefinitionAnnotations()方法。

（3）解析AnnotationConfigUtils类的processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata)方法

```java
static void processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata) {
    AnnotationAttributes lazy = attributesFor(metadata, Lazy.class);
    if (lazy != null) {
        abd.setLazyInit(lazy.getBoolean("value"));
    }
    else if (abd.getMetadata() != metadata) {
        lazy = attributesFor(abd.getMetadata(), Lazy.class);
        if (lazy != null) {
            abd.setLazyInit(lazy.getBoolean("value"));
        }
    }
	/**********省略其他代码***********/
}
```

在AnnotationConfigUtils类的processCommonDefinitionAnnotations()方法中，会解析@Lazy注解中的value属性，并将属性值存入abd对象的lazyInit字段中。

（4）回到AnnotatedBeanDefinitionReader类的doRegisterBean(Class<T> beanClass, String name, Class<? extends Annotation>[] qualifiers, Supplier<T> supplier, BeanDefinitionCustomizer[] customizers)方法。

在方法中遍历qualifiers数组，如果Lazy.class的值与遍历出的qualifier对象相等，就会将abd对象的lazyInit字段设置为true。如果abd对象的lazyInit字段为true，则后续在启动IOC容器的过程中，就不会创建单例Bean对象。

#### 调用Bean后置处理器的源码流程

（1）解析ComponentScanAnnotationParser类的parse(AnnotationAttributes componentScan, String declaringClass)方法

```java
public Set<BeanDefinitionHolder> parse(AnnotationAttributes componentScan, String declaringClass) {
    /**********省略其他代码**********/
    boolean lazyInit = componentScan.getBoolean("lazyInit");
    if (lazyInit) {
        scanner.getBeanDefinitionDefaults().setLazyInit(true);
    }
	/**********省略其他代码**********/
    return scanner.doScan(StringUtils.toStringArray(basePackages));
}
```

在ComponentScanAnnotationParser类的parse()方法中，会获取componentScan中的lazyInit属性，如果属性的值为true，会将scanner对象中beanDefinitionDefaults对象的lazyInit属性设置为true。

（2）解析AnnotationConfigUtils类的processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata)方法

#### 创建单例Bean的源码流程

重点关注如下代码片段。

```java
@Override
public void preInstantiateSingletons() throws BeansException {
    /************省略其他代码**************/
    for (String beanName : beanNames) {
        RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
        if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
            if (isFactoryBean(beanName)) {
                Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
                if (bean instanceof SmartFactoryBean<?> smartFactoryBean && smartFactoryBean.isEagerInit()) {
                    getBean(beanName);
                }
            }
            else {
                getBean(beanName);
            }
        }
    }
	/************省略其他代码**************/
}
```

可以看到，在preInstantiateSingletons()方法中，会循环遍历解析出的Bean名称，在循环中，会根据遍历出的Bean名称获取RootBeanDefinition对象。接下来会进行如下判断。

```java
if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
    /*************省略其他代码*************/
}
```

可以看到，在preInstantiateSingletons()方法中，会判断每次遍历获取出的RootBeanDefinition对象中如果标记的不是抽象类，并且是单实例对象，并且没有设置延迟创建Bean。同时满足这些条件后，参会调用getbean()方法创建对应的Bean对象，并注入到IOC容器中。

### 思考

#### 1. @Lazy注解的作用是什么？

@Lazy注解在Spring框架中用于延迟加载Bean，即在Bean首次被请求时才进行实例化，而不是在Spring容器启动时立即创建。这样做的好处是可以提高应用程序的启动速度，减少不必要的资源消耗，特别是对于那些初始化过程复杂或占用资源较多的Bean。

#### 2. @Lazy注解有哪些使用场景？

1. **优化启动时间**：当Spring应用中存在大量Bean，并且不是所有Bean都在应用启动时立即需要时，可以使用@Lazy注解来延迟加载那些不是立即需要的Bean，从而加快应用启动速度。
2. **解决循环依赖**：在Spring中，如果两个Bean之间存在循环依赖，且默认情况下Spring容器在启动时会尝试实例化所有Bean，这可能会导致BeanCurrentlyInCreationException异常。通过使用@Lazy注解，可以延迟其中一个Bean的实例化，从而避免循环依赖问题。
3. **大对象初始化**：对于初始化过程复杂或占用大量资源的Bean，使用@Lazy注解可以延迟其加载，以减少启动时间和资源占用。

#### 3. @Lazy注解延迟创建Bean是如何实现的？

@Lazy注解通过修改Bean的生命周期管理来实现延迟加载。当Bean被标记为@Lazy时，Spring容器在启动时不会立即创建该Bean的实例，而是会将其标记为延迟加载。当第一次通过Spring容器请求该Bean时，Spring容器才会创建其实例并返回。

具体实现上，Spring框架会在解析Bean定义时检查是否存在@Lazy注解。如果存在，则会在Bean的定义中设置相应的延迟加载标志。当Bean被请求时，Spring容器会检查该Bean是否被标记为延迟加载。如果是，则执行Bean的创建过程；如果不是，则直接从容器中获取已存在的Bean实例。

#### 4. @Lazy注解在Spring内部的执行流程？

1. **解析Bean定义**：Spring容器在启动时解析配置文件或注解中的Bean定义，包括检查是否存在@Lazy注解。
2. **设置延迟加载标志**：对于被@Lazy注解标记的Bean，Spring会在其定义中设置延迟加载标志。
3. **容器启动完成**：Spring容器完成所有必要的初始化工作，但不会立即创建被@Lazy注解标记的Bean实例。
4. **Bean请求**：当应用程序首次通过Spring容器请求被@Lazy注解标记的Bean时，Spring容器会检查该Bean是否被标记为延迟加载。
5. **Bean创建与返回**：如果Bean被标记为延迟加载，Spring容器将创建该Bean的实例，并将其返回给请求者。此后，该Bean的实例将被缓存在Spring容器中，以便后续请求直接获取。

## 1.10 @Component注解

IOC容器在启动时，如果扫描到被标注了@Component注解的类，则会将这些类的类定义信息自动注入IOC容器，并创建这些类的对象。并且@Component注解还有三个衍生注解：@Repository、@Service和@Controller注解

### 注解源码

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Indexed
public @interface Component {
	String value() default "";
}
```

* value：用于指定注入容器时Bean的id。如果没有指定Bean的id，默认值为当前类的名称。

@Component注解的三个衍生注解

（1）@Repository注解

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Repository {
	@AliasFor(annotation = Component.class)
	String value() default "";
}
```

（2）@Service注解

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Service {
	@AliasFor(annotation = Component.class)
	String value() default "";

}
```

（3）@Controller注解

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Controller {
	@AliasFor(annotation = Component.class)
	String value() default "";
}
```

### 源码时序图

![1](https://upload.yolo912.icu/mdImage/1.png)

![2](https://upload.yolo912.icu/mdImage/2.png)

![3](https://upload.yolo912.icu/mdImage/3.png)

### 源码解析

（1）解析ConfigurationClassParser类的doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)方法

```java
protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass,
    Predicate<String> filter) throws IOException {
    if (configClass.getMetadata().isAnnotated(Component.class.getName())) {
        processMemberClasses(configClass, sourceClass, filter);
    }
    /**************省略其他代码****************/
    Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(
        sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
    if (!componentScans.isEmpty() &&
        !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
        for (AnnotationAttributes componentScan : componentScans) {
            Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan,
                sourceClass.getMetadata().getClassName());
            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
                BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
                if (bdCand == null) {
                    bdCand = holder.getBeanDefinition();
                }
                if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
                    parse(bdCand.getBeanClassName(), holder.getBeanName());
                }
            }
        }
    }
    /**************省略其他代码****************/
    return null;
}

```

在ConfigurationClassParser类的doProcessConfigurationClass()方法，判断如果是@Component注解（@Repository、@Service和@Controller注解），会调用processMemberClasses()方法处理内部类。

（2）解析ConfigurationClassParser类的processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass,Predicate<String> filter)方法

```java
private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)
    throws IOException {
    Collection<SourceClass> memberClasses = sourceClass.getMemberClasses();
    /*****************省略其他代码***************/
}
```

在processMemberClasses()方法中，会调用sourceClass的getMemberClasses()方法获取SourceClass的集合。

（3）解析SourceClass类的getMemberClasses()方法

```java
public Collection<SourceClass> getMemberClasses() throws IOException {
    Object sourceToProcess = this.source;
    if (sourceToProcess instanceof Class<?> sourceClass) {
        try {
            Class<?>[] declaredClasses = sourceClass.getDeclaredClasses();
            List<SourceClass> members = new ArrayList<>(declaredClasses.length);
            for (Class<?> declaredClass : declaredClasses) {
                members.add(asSourceClass(declaredClass, DEFAULT_EXCLUSION_FILTER));
            }
            return members;
        } catch (NoClassDefFoundError err) {
            sourceToProcess = metadataReaderFactory.getMetadataReader(sourceClass.getName());
        }
    }
    MetadataReader sourceReader = (MetadataReader) sourceToProcess;
    String[] memberClassNames = sourceReader.getClassMetadata().getMemberClassNames();
    List<SourceClass> members = new ArrayList<>(memberClassNames.length);
    for (String memberClassName : memberClassNames) {
        try {
            members.add(asSourceClass(memberClassName, DEFAULT_EXCLUSION_FILTER));
        } catch (IOException ex) {
            if (logger.isDebugEnabled()) {
                logger.debug("Failed to resolve member class [" + memberClassName
                    + "] - not considering it as a configuration class candidate");
            }
        }
    }
    return members;
}
```

getMemberClasses()方法的主要作用就是处理标注了@Component、@Repository、@Service和@Controller注解的类的内部类，因为内部类也有可能会标注这些注解。在getMemberClasses()方法中，利用反射拿到类的内部类，将内部类封装成SourceClass，存放到members集合中并返回。

（4）返回ConfigurationClassParser类的processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass,Predicate<String> filter)方法

重点关注如下代码：

```java
private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)
    throws IOException {
    /*******************省略其他代码*****************/
    if (!memberClasses.isEmpty()) {
        List<SourceClass> candidates = new ArrayList<>(memberClasses.size());
        for (SourceClass memberClass : memberClasses) {
            if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata())
                && !memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {
                candidates.add(memberClass);
            }
        }
        /*******************省略其他代码*****************/
    }
}
```

在ConfigurationClassParser类的processMemberClasses()方法中，如果获取到的内部类集合memberClasses不为空，则遍历获取到的memberClasses集合，使用ConfigurationClassUtils类的isConfigurationCandidate()方法判断内部类上是否有需要处理的注解，如果有需要处理的注解，则将类添加到candidates集合中。

（5）解析ConfigurationClassUtils类的isConfigurationCandidate(AnnotationMetadata metadata)方法

```java
static boolean isConfigurationCandidate(AnnotationMetadata metadata) {
    if (metadata.isInterface()) {
        return false;
    }
    for (String indicator : candidateIndicators) {
        if (metadata.isAnnotated(indicator)) {
            return true;
        }
    }
    return hasBeanMethods(metadata);
}
```



isConfigurationCandidate()方法的作用主要是判断内部类上面是否有需要处理的注解，具体的判断逻辑是：如果是接口，则直接返回false，如果是@Component（含@Repository、@Service和@Controller）、@ComponentScan、@Import、@ImportResource等注解，则返回true。最后判断方法上是否标注了@Bean注解，如果标注了@Bean注解，则返回true。否则，返回false。

（6）返回ConfigurationClassParser类的processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass,Predicate<String> filter)方法

重点关注如下代码：

```
private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)
    throws IOException {
    /**********省略其他代码**************/
    if (!memberClasses.isEmpty()) {
        /**********省略其他代码**************/
        OrderComparator.sort(candidates);
        for (SourceClass candidate : candidates) {
            if (this.importStack.contains(configClass)) {
                this.problemReporter.error(new CircularImportProblem(configClass, this.importStack));
            } else {
                this.importStack.push(configClass);
                try {
                    processConfigurationClass(candidate.asConfigClass(configClass), filter);
                } finally {
                    this.importStack.pop();
                }
            }
        }
    }
}
  
```

在processMemberClasses()方法中，首先对获取到的内部类进行排序，随后遍历内部类集合，调用candidate的asConfigClass()方法将内部类封装成ConfigurationClass对象。并传入processConfigurationClass()方法中解析内部类的注解信息。

（7）返回ConfigurationClassParser类的doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)方法。

```java
Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
```

（8）解析ClassPathBeanDefinitionScanner类的doScan(String... basePackages)方法

```java
protected Set<BeanDefinitionHolder> doScan(String... basePackages) {
    Assert.notEmpty(basePackages, "At least one base package must be specified");
    Set<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<>();
    for (String basePackage : basePackages) {
        Set<BeanDefinition> candidates = findCandidateComponents(basePackage);
        /***************省略其他代码*****************/
    }
    return beanDefinitions;
}
```

在ClassPathBeanDefinitionScanner类的doScan()中，会遍历传入的扫描包路径数组，调用findCandidateComponents()方法加载符合一定条件的BeanDefinition。

（9）解析ClassPathScanningCandidateComponentProvider类的findCandidateComponents(String basePackage)方法

```java
public Set<BeanDefinition> findCandidateComponents(String basePackage) {
    if (this.componentsIndex != null && indexSupportsIncludeFilters()) {
        return addCandidateComponentsFromIndex(this.componentsIndex, basePackage);
    } else {
        return scanCandidateComponents(basePackage);
    }
}
```



在findCandidateComponents()方法中，会调用scanCandidateComponents()方法来扫描basePackage包下标注了注解的类。

（10）解析ClassPathScanningCandidateComponentProvider类的scanCandidateComponents(String basePackage)方法

```java
private Set<BeanDefinition> scanCandidateComponents(String basePackage) {
    Set<BeanDefinition> candidates = new LinkedHashSet<>();
    try {
        String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +
            resolveBasePackage(basePackage) + '/' + this.resourcePattern;
        Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);
        boolean traceEnabled = logger.isTraceEnabled();
        boolean debugEnabled = logger.isDebugEnabled();
        for (Resource resource : resources) {
            String filename = resource.getFilename();
            if (filename != null && filename.contains(ClassUtils.CGLIB_CLASS_SEPARATOR)) {
                continue;
            }
            if (traceEnabled) {
                logger.trace("Scanning " + resource);
            }
            try {
                MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);
                if (isCandidateComponent(metadataReader)) {
                    ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
                    sbd.setSource(resource);
                    if (isCandidateComponent(sbd)) {
                        if (debugEnabled) {
                            logger.debug("Identified candidate component class: " + resource);
                        }
                        candidates.add(sbd);
                    }
                    /***************省略其他代码*************/
                }
       catch(FileNotFoundException ex){
                    if (traceEnabled) {
                        logger.trace("Ignored non-readable " + resource + ": " + ex.getMessage());
                    }
                }
       catch(Throwable ex){
                    throw new BeanDefinitionStoreException(
                        "Failed to read candidate component class: " + resource, ex);
                }
            }
        }
   catch(IOException ex){
            throw new BeanDefinitionStoreException("I/O failure during classpath scanning", ex);
        }
        return candidates;
    }
}
```



在ClassPathScanningCandidateComponentProvider类的scanCandidateComponents()方法中，会加载basePackage包路径下的资源，将其封装成ScannedGenericBeanDefinition类的对象，并传入isCandidateComponent()方法中对类进行过滤。符合条件时，会将当前ScannedGenericBeanDefinition类的对象存入candidates集合中，最终返回candidates集合。

（11）解析ClassPathScanningCandidateComponentProvider类的isCandidateComponent(MetadataReader metadataReader)方法

```java
protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException {
    for (TypeFilter tf : this.excludeFilters) {
        if (tf.match(metadataReader, getMetadataReaderFactory())) {
            return false;
        }
    }
    for (TypeFilter tf : this.includeFilters) {
        if (tf.match(metadataReader, getMetadataReaderFactory())) {
            return isConditionMatch(metadataReader);
        }
    }
    return false;
}
```

在isCandidateComponent()方法中，首先遍历excludeFilters规则列表，如果匹配到excludeFilters规则，则直接返回false。否则，遍历includeFilters规则，如果匹配到includeFilters规则，则调用isConditionMatch()方法来匹配@Conditional注解的规则。

在IOC容器启动调用AnnotationConfigApplicationContext类的构造方法时，就会对includeFilters规则列表进行初始化。

```java
protected void registerDefaultFilters() {
    this.includeFilters.add(new AnnotationTypeFilter(Component.class));
    ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();
    try {
        this.includeFilters.add(new AnnotationTypeFilter(
            ((Class<? extends Annotation>) ClassUtils.forName("jakarta.annotation.ManagedBean", cl)), false));
        logger.trace("JSR-250 'jakarta.annotation.ManagedBean' found and supported for component scanning");
    } catch (ClassNotFoundException ex) {
        // JSR-250 1.1 API (as included in Jakarta EE) not available - simply skip.
    }
    try {
        this.includeFilters.add(new AnnotationTypeFilter(
            ((Class<? extends Annotation>) ClassUtils.forName("jakarta.inject.Named", cl)), false));
        logger.trace("JSR-330 'jakarta.inject.Named' annotation found and supported for component scanning");
    } catch (ClassNotFoundException ex) {
        // JSR-330 API not available - simply skip.
    }
}
```

在registerDefaultFilters()方法中，默认会将@Component注解封装成AnnotationTypeFilter对象并存入includeFilters规则列表中。

（12）返回ClassPathBeanDefinitionScanner类的doScan(String... basePackages)方法

```java
protected Set<BeanDefinitionHolder> doScan(String... basePackages) {
    Assert.notEmpty(basePackages, "At least one base package must be specified");
    Set<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<>();
    for (String basePackage : basePackages) {
        Set<BeanDefinition> candidates = findCandidateComponents(basePackage);
        for (BeanDefinition candidate : candidates) {
            /**********省略其他代码***********/
            if (candidate instanceof AnnotatedBeanDefinition) {
                AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
            }
            if (checkCandidate(beanName, candidate)) {
                BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
                definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder,
                    this.registry);
                beanDefinitions.add(definitionHolder);
                registerBeanDefinition(definitionHolder, this.registry);
            }
        }
    }
    return beanDefinitions;
}
```

### 思考

#### 1. @Component注解的作用

当一个类被@Component注解标记后，Spring容器会在启动时自动扫描并实例化这个类，将其注册为Spring上下文中的一个Bean，从而使其能够被Spring的依赖注入（DI）机制所管理。

#### 2. @Component注解的使用场景

@Component注解可以用于任何类，但通常用于那些需要被Spring容器管理的组件，如服务层（Service）、数据访问层（DAO）、控制器（Controller）等。这些组件在应用程序中扮演着重要的角色，通过@Component注解，它们可以被Spring容器自动扫描、实例化并注册为Bean，进而实现依赖注入和AOP（面向切面编程）等功能。

#### 3. @Component注解是如何将Bean注入到IOC容器的

@Component注解将Bean注入到IOC容器的过程大致可以分为以下几个步骤：

1. **自动扫描**：通过@ComponentScan注解或Spring配置文件中指定的扫描路径，Spring容器会自动扫描这些路径下的类文件。
2. **注解识别**：在扫描过程中，Spring容器会识别出带有@Component注解的类。
3. **Bean定义注册**：对于每个被@Component注解标记的类，Spring容器会创建一个BeanDefinition对象，并将其注册到Spring容器中。BeanDefinition对象包含了Bean的元数据信息，如类名、作用域、生命周期回调等。
4. **Bean实例化**：在应用程序启动时或Bean被首次请求时，Spring容器会根据BeanDefinition对象中的信息实例化Bean。
5. **依赖注入**：如果Bean之间存在依赖关系，Spring容器会利用依赖注入机制将这些依赖关系注入到Bean中。

#### 4. @Component注解在Spring内部的执行流程

@Component注解在Spring内部的执行流程可以概括为以下几个阶段：

1. **初始化阶段**：Spring容器在启动时，会进行一系列的初始化工作，包括设置注解过滤器、配置扫描路径等。
2. **扫描阶段**：根据配置的扫描路径，Spring容器会扫描这些路径下的类文件，并解析出类文件中的注解信息。
3. **注册阶段**：对于带有@Component注解的类，Spring容器会创建BeanDefinition对象，并将其注册到Spring容器中。
4. **实例化阶段**：在应用程序启动时或Bean被首次请求时，Spring容器会根据BeanDefinition对象中的信息实例化Bean。
5. **依赖注入阶段**：如果Bean之间存在依赖关系，Spring容器会利用依赖注入机制将这些依赖关系注入到Bean中。
6. **使用阶段**：完成上述步骤后，Bean就可以被应用程序中的其他部分所使用了。



## 1.11 @Value注解

@Value注解可以向Spring的Bean的属性中注入数据。并且支持Spring的EL表达式，可以通过${} 的方式获取配置文件中的数据。配置文件支持properties、XML、和YML文件。

### 注解源码

```java
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Value {
	String value();
}
```

* value：指定要向Bean的属性中注入的数据，数据可以是配置文件中的配置项，并且支持EL表达式。

### 源码时序图

#### **解析并获取@Value修饰的属性**

![11.1](https://upload.yolo912.icu/mdImage/11.1.png)

![11.2](https://upload.yolo912.icu/mdImage/11.2.png)

#### **为@Value修饰的属性赋值**

![11.3](https://upload.yolo912.icu/mdImage/11.3.png)

![11.4](https://upload.yolo912.icu/mdImage/11.4.png)

#### **使用@Value获取属性的值**

![11.5](https://upload.yolo912.icu/mdImage/11.5.png)

![11.6](https://upload.yolo912.icu/mdImage/11.6.png)

![11.7](https://upload.yolo912.icu/mdImage/11.7.png)

### 源码解析

#### **解析并获取@Value修饰的属性**

（1）解析AbstractBeanFactory类的doGetBean(String name, Class<T> requiredType, Object[] args, boolean typeCheckOnly)方法

```java
protected <T> T doGetBean(String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly)
    throws BeansException {
    /***********省略其他代码***********/
    if (mbd.isSingleton()) {
        sharedInstance = getSingleton(beanName, () -> {
            try {
                return createBean(beanName, mbd, args);
            } catch (BeansException ex) {
                destroySingleton(beanName);
                throw ex;
            }
        });
        beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
    }
    /***********省略其他代码***********/
    return adaptBeanInstance(name, beanInstance, requiredType);
}
```

在AbstractBeanFactory类的doGetBean()方法中，如果是单例Bean，会调用getSingleton()方法创建单例Bean，实际执行的是Lambda表达式中的createBean()方法来创建单例Bean。

（2）解析AbstractAutowireCapableBeanFactory类的createBean(String beanName, RootBeanDefinition mbd, Object[] args)。



```java
@Override
protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
    throws BeanCreationException {	
    /**************省略其他代码***************/
    try {
        Object beanInstance = doCreateBean(beanName, mbdToUse, args);
        if (logger.isTraceEnabled()) {
            logger.trace("Finished creating instance of bean '" + beanName + "'");
        }
        return beanInstance;
    }
    catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {
        throw ex;
    }
    catch (Throwable ex) {
        throw new BeanCreationException(
            mbdToUse.getResourceDescription(), beanName, "Unexpected exception during bean creation", ex);
    }
}
```



在AbstractAutowireCapableBeanFactory类的createBean()方法中，会调用doCreateBean()方法创建Bean对象。

（3）解析AbstractAutowireCapableBeanFactory类的doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)方法

```java
protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
    throws BeanCreationException {
    BeanWrapper instanceWrapper = null;
    if (mbd.isSingleton()) {
        instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
    }
    if (instanceWrapper == null) {
        instanceWrapper = createBeanInstance(beanName, mbd, args);
    }
    /***********省略其他代码**********/
    return exposedObject;
}
```

（4）解析AbstractAutowireCapableBeanFactory类的(String beanName, RootBeanDefinition mbd, Object[] args)方法



```java
protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {
    // Make sure bean class is actually resolved at this point.
    Class<?> beanClass = resolveBeanClass(mbd, beanName);
    if (beanClass != null && !Modifier.isPublic(beanClass.getModifiers()) && !mbd.isNonPublicAccessAllowed()) {
        throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Bean class isn't public, and non-public access not allowed: " + beanClass.getName());
    }
    Supplier<?> instanceSupplier = mbd.getInstanceSupplier();
    if (instanceSupplier != null) {
        return obtainFromSupplier(instanceSupplier, beanName);
    }
    if (mbd.getFactoryMethodName() != null) {
        return instantiateUsingFactoryMethod(beanName, mbd, args);
    }
    boolean resolved = false;
    boolean autowireNecessary = false;
    if (args == null) {
        synchronized (mbd.constructorArgumentLock) {
            if (mbd.resolvedConstructorOrFactoryMethod != null) {
                resolved = true;
                autowireNecessary = mbd.constructorArgumentsResolved;
            }
        }
    }
    if (resolved) {
        if (autowireNecessary) {
            return autowireConstructor(beanName, mbd, null, null);
        }
        else {
            return instantiateBean(beanName, mbd);
        }
    }
    Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
    if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||
        mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {
        return autowireConstructor(beanName, mbd, ctors, args);
    }
    ctors = mbd.getPreferredConstructors();
    if (ctors != null) {
        return autowireConstructor(beanName, mbd, ctors, null);
    }
    return instantiateBean(beanName, mbd);
}
```

createBeanInstance()方法会创建Bean的实例并返回BeanWrapper对象。

（5）返回AbstractAutowireCapableBeanFactory类的doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)方法，此时，重点关注如下代码片段。

```java
/*************省略其他代码***************/
protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {
    synchronized (mbd.postProcessingLock) {
        if (!mbd.postProcessed) {
            try {
                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
            }
            catch (Throwable ex) {
                throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Post-processing of merged bean definition failed", ex);
            }
            mbd.markAsPostProcessed();
        }
    }
    /*************省略其他代码***************/
}
```

在AbstractAutowireCapableBeanFactory类的doCreateBean()方法中会调用applyMergedBeanDefinitionPostProcessors()方法的主要作用就是：获取@Value、@Autowired、@PostConstruct、@PreDestroy等注解标注的字段和方法，然后封装到InjectionMetadata对象中，最后将所有的InjectionMetadata对象存入injectionMeatadataCache缓存中。

（6）解析AbstractAutowireCapableBeanFactory类的applyMergedBeanDefinitionPostProcessors(RootBeanDefinition mbd, Class<?> beanType, String beanName)方法

```java
protected void applyMergedBeanDefinitionPostProcessors(RootBeanDefinition mbd, Class<?> beanType, String beanName) {
    for (MergedBeanDefinitionPostProcessor processor : getBeanPostProcessorCache().mergedDefinition) {
        processor.postProcessMergedBeanDefinition(mbd, beanType, beanName);
    }
}
```

在AbstractAutowireCapableBeanFactory类的applyMergedBeanDefinitionPostProcessors()方法中，会调用processor的postProcessMergedBeanDefinition()方法处理BeanDefinition信息。

（7）解析AutowiredAnnotationBeanPostProcessor类postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName)。

```java
@Override
public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {
    findInjectionMetadata(beanName, beanType, beanDefinition);
}
```

在AutowiredAnnotationBeanPostProcessor类postProcessMergedBeanDefinition()方法中会调用findInjectionMetadata()方法来获取标注了注解的字段或者方法。

（8）解析AutowiredAnnotationBeanPostProcessor类的findInjectionMetadata(String beanName, Class<?> beanType, RootBeanDefinition beanDefinition)方法

```java
private InjectionMetadata findInjectionMetadata(String beanName, Class<?> beanType, RootBeanDefinition beanDefinition) {
    InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, null);
    metadata.checkConfigMembers(beanDefinition);
    return metadata;
}
```

在AutowiredAnnotationBeanPostProcessor类的findInjectionMetadata()方法中，调用了findAutowiringMetadata方法来解析并获取@Value、@Autowired、@Inject等注解修饰的属性或者方法。

（9）解析AutowiredAnnotationBeanPostProcessor类的findAutowiringMetadata(String beanName, Class<?> clazz, PropertyValues pvs)方法

```java
private InjectionMetadata findAutowiringMetadata(String beanName, Class<?> clazz, @Nullable PropertyValues pvs) {
    String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());
    InjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey);
    if (InjectionMetadata.needsRefresh(metadata, clazz)) {
        synchronized (this.injectionMetadataCache) {
            metadata = this.injectionMetadataCache.get(cacheKey);
            if (InjectionMetadata.needsRefresh(metadata, clazz)) {
                if (metadata != null) {
                    metadata.clear(pvs);
                }
                metadata = buildAutowiringMetadata(clazz);
                this.injectionMetadataCache.put(cacheKey, metadata);
            }
        }
    }
    return metadata;
}
```

AutowiredAnnotationBeanPostProcessor类的findAutowiringMetadata()方法最核心的功能就是对传递进来的每个类进行筛选判断是否被@Value、@Autowired、@Inject注解修饰的方法或者属性，如果是被 @Value、@Autowired、@Inject注解修饰的方法或者属性，就会将这个类记录下来，存入injectionMetadataCache缓存中，为后续的 DI 依赖注作准备。

首次调用findAutowiringMetadata()方法时，会调用buildAutowiringMetadata()方法来查找使用@Value、@Autowired、@Inject注解修饰的方法或者属性。

（10）解析AutowiredAnnotationBeanPostProcessor类的buildAutowiringMetadata(Class<?> clazz)方法。

```java
private InjectionMetadata buildAutowiringMetadata(Class<?> clazz) {
    if (!AnnotationUtils.isCandidateClass(clazz, this.autowiredAnnotationTypes)) {
        return InjectionMetadata.EMPTY;
    }
    List<InjectionMetadata.InjectedElement> elements = new ArrayList<>();
    Class<?> targetClass = clazz;
    do {
        final List<InjectionMetadata.InjectedElement> currElements = new ArrayList<>();
        ReflectionUtils.doWithLocalFields(targetClass, field -> {
            MergedAnnotation<?> ann = findAutowiredAnnotation(field);
            if (ann != null) {
                if (Modifier.isStatic(field.getModifiers())) {
                    if (logger.isInfoEnabled()) {
                        logger.info("Autowired annotation is not supported on static fields: " + field);
                    }
                    return;
                }
                boolean required = determineRequiredStatus(ann);
                currElements.add(new AutowiredFieldElement(field, required));
            }
        });
        /**************省略其他代码****************/
        elements.addAll(0, currElements);
        targetClass = targetClass.getSuperclass();
    }
    while (targetClass != null && targetClass != Object.class);
    return InjectionMetadata.forElements(elements, clazz);
}
```

在AutowiredAnnotationBeanPostProcessor类的buildAutowiringMetadata()方法中，获取到类上所有的字段，然后遍历每个字段，判断是否标注了 @Value、@Autowired和@Inject注解，如果标注了 @Value、@Autowired和@Inject注解，直接封装成 AutowiredFieldElement 对象，然后保存到一个名为 currElements集合中。

**如果解析到的字段是静态字段，则直接返回，这就是为什么Spring不会对类中的静态字段赋值的原因。如下代码片段所示。**

```java
if (Modifier.isStatic(field.getModifiers())) {
    if (logger.isInfoEnabled()) {

        logger.info("Autowired annotation is not supported on static fields: " + field);

    }

    return;
}
```

在AutowiredAnnotationBeanPostProcessor类的buildAutowiringMetadata()方法的最后，则将标注了@Value、@Autowired和@Inject注解的字段封装到 InjectionMetadata 对象中，如下所示。

```java
return InjectionMetadata.forElements(elements, clazz);
```

最终回到AutowiredAnnotationBeanPostProcessor类的findAutowiringMetadata()方法中，将InjectionMetadata 对象存入injectionMetadataCache缓存中。

```java
metadata = buildAutowiringMetadata(clazz);
this.injectionMetadataCache.put(cacheKey, metadata);
```

另外，在AutowiredAnnotationBeanPostProcessor类的buildAutowiringMetadata()方法中，调用了findAutowiredAnnotation()方法来获取注解信息。

```java
MergedAnnotation<?> ann = findAutowiredAnnotation(field);
```

（11）解析AutowiredAnnotationBeanPostProcessor类的findAutowiredAnnotation(AccessibleObject ao)方法



```java
private MergedAnnotation<?> findAutowiredAnnotation(AccessibleObject ao) {
    MergedAnnotations annotations = MergedAnnotations.from(ao);
    for (Class<? extends Annotation> type : this.autowiredAnnotationTypes) {
        MergedAnnotation<?> annotation = annotations.get(type);
        if (annotation.isPresent()) {
            return annotation;
        }
    }
    return null;
}
```

在AutowiredAnnotationBeanPostProcessor类的findAutowiredAnnotation()方法中，会遍历autowiredAnnotationTypes集合，通过遍历出的每个autowiredAnnotationTypes集合中的元素从annotations中获取MergedAnnotation对象annotation，如果annotation存在，则返回annotation。否则返回null。

需要关注下autowiredAnnotationTypes集合，在AutowiredAnnotationBeanPostProcessor类的构造方法中向autowiredAnnotationTypes集合中添加元素。





```java
public AutowiredAnnotationBeanPostProcessor() {
    this.autowiredAnnotationTypes.add(Autowired.class);
    this.autowiredAnnotationTypes.add(Value.class);
    try {
        this.autowiredAnnotationTypes.add((Class<? extends Annotation>) ClassUtils.forName("jakarta.inject.Inject", AutowiredAnnotationBeanPostProcessor.class.getClassLoader()));
        logger.trace("'jakarta.inject.Inject' annotation found and supported for autowiring");
    }
    catch (ClassNotFoundException ex) {
        // jakarta.inject API not available - simply skip.
    }
    try {
        this.autowiredAnnotationTypes.add((Class<? extends Annotation>) ClassUtils.forName("javax.inject.Inject", AutowiredAnnotationBeanPostProcessor.class.getClassLoader()));
        logger.trace("'javax.inject.Inject' annotation found and supported for autowiring");
    }
    catch (ClassNotFoundException ex) {
        // javax.inject API not available - simply skip.
    }
}
```

在AutowiredAnnotationBeanPostProcessor类的构造方法中，向autowiredAnnotationTypes集合中添加了@Autowired注解、@Value注解和@Inject注解。所以，@Autowired注解赋值的流程和@Value注解赋值的流程基本一致。

#### **为@Value修饰的属性赋值**

（1）解析AbstractAutowireCapableBeanFactory类的doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)方法

```java
protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
throws BeanCreationException {
    /************省略其他代码*************/
    Object exposedObject = bean;
    try {
        populateBean(beanName, mbd, instanceWrapper);
        exposedObject = initializeBean(beanName, exposedObject, mbd);
    }
    catch (Throwable ex) {
        if (ex instanceof BeanCreationException bce && beanName.equals(bce.getBeanName())) {
            throw bce;
        }
        else {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName, ex.getMessage(), ex);
        }
    }
    /************省略其他代码*************/
    return exposedObject;
}
```

在AbstractAutowireCapableBeanFactory类的doCreateBean()方法中，会调用populateBean方法为Bean的属性赋值。

（2）解析AbstractAutowireCapableBeanFactory类的populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)方法



```java
protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
    /**************省略其他代码*************/
    if (hasInstantiationAwareBeanPostProcessors()) {
        if (pvs == null) {
            pvs = mbd.getPropertyValues();
        }
        for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {
            PropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);
            if (pvsToUse == null) {
                return;
            }
            pvs = pvsToUse;
        }
    }
    /**************省略其他代码*************/
}
```

在populateBean()方法中，会调用InstantiationAwareBeanPostProcessor类的postProcessProperties()方法来处理属性或方法的值。实际上是调用的AutowiredAnnotationBeanPostProcessor类的postProcessProperties()方法。

（3）解析AutowiredAnnotationBeanPostProcessor类的postProcessProperties(PropertyValues pvs, Object bean, String beanName)方法

```java
@Override
public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {
    InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);
    try {
        metadata.inject(bean, beanName, pvs);
    }
    catch (BeanCreationException ex) {
        throw ex;
    }
    catch (Throwable ex) {
        throw new BeanCreationException(beanName, "Injection of autowired dependencies failed", ex);
    }
    return pvs;
}
```

在AutowiredAnnotationBeanPostProcessor类的postProcessProperties()方法中，会调用findAutowiringMetadata()方法获取注解的元数据信息。

（4）解析AutowiredAnnotationBeanPostProcessor类的findAutowiringMetadata(String beanName, Class<?> clazz, @Nullable PropertyValues pvs)方法

```java
private InjectionMetadata findAutowiringMetadata(String beanName, Class<?> clazz, @Nullable PropertyValues pvs) {
    String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());
    InjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey);
    if (InjectionMetadata.needsRefresh(metadata, clazz)) {
        synchronized (this.injectionMetadataCache) {
            metadata = this.injectionMetadataCache.get(cacheKey);
            if (InjectionMetadata.needsRefresh(metadata, clazz)) {
                if (metadata != null) {
                    metadata.clear(pvs);
                }
                metadata = buildAutowiringMetadata(clazz);
                this.injectionMetadataCache.put(cacheKey, metadata);
            }
        }
    }
    return metadata;
}
```

由于在之前解析并获取@Value修饰的属性的代码流程中，已经完成了对@Value 修饰的属性的获取工作。所以，程序执行到findAutowiringMetadata()方法内部时，injectionMetadataCache缓存中已经有数据了。

（5）返回AutowiredAnnotationBeanPostProcessor类的postProcessProperties(PropertyValues pvs, Object bean, String beanName)方法。在AutowiredAnnotationBeanPostProcessor类的postProcessProperties()方法中，调用了metadata对象的inject()方法为属性赋值。

（6）解析InjectionMetadata类的inject(Object target, @Nullable String beanName, @Nullable PropertyValues pvs)方法

```java
public void inject(Object target, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable {
    Collection<InjectedElement> checkedElements = this.checkedElements;
    Collection<InjectedElement> elementsToIterate = (checkedElements != null ? checkedElements : this.injectedElements);
    if (!elementsToIterate.isEmpty()) {
        for (InjectedElement element : elementsToIterate) {
            element.inject(target, beanName, pvs);
        }
    }
}
```

在InjectionMetadata类的inject()方法中，会循环遍历checkedElements集合，调用遍历出的每个InjectedElement对象的inject()方法为属性赋值。

**注意：调用InjectedElement对象的inject()方法时，实际上可能会调用AutowiredFieldElement类的inject()方法、AutowiredMethodElement类的inject()方法或者InjectedElement类的inject()方法。这里，以调用AutowiredFieldElement类的inject()方法为例进行说明。**

（7）解析AutowiredFieldElement类的inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs)方法

```java
@Override
protected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable {
    Field field = (Field) this.member;
    Object value;
    if (this.cached) {
        try {
            value = resolvedCachedArgument(beanName, this.cachedFieldValue);
        }
        catch (NoSuchBeanDefinitionException ex) {
            value = resolveFieldValue(field, bean, beanName);
        }
    }
    else {
        value = resolveFieldValue(field, bean, beanName);
    }
    if (value != null) {
        ReflectionUtils.makeAccessible(field);
        field.set(bean, value);
    }
}
```

在AutowiredFieldElement类的inject()方法中，会调用resolveFieldValue()方法来获取对应的属性值，如下所示。

```java
value = resolveFieldValue(field, bean, beanName);
```

并通过反射向使用@Value注解标注的字段赋值，如下所示。

```java
 field.set(bean, value);
```

（8）返回AbstractAutowireCapableBeanFactory类的doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)方法。再来看下源码：

```java
protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
   throws BeanCreationException {
    /************省略其他代码*************/
   Object exposedObject = bean;
   try {
     populateBean(beanName, mbd, instanceWrapper);
     exposedObject = initializeBean(beanName, exposedObject, mbd);
   }
   catch (Throwable ex) {
     if (ex instanceof BeanCreationException bce && beanName.equals(bce.getBeanName())) {
       throw bce;
     }
     else {
       throw new BeanCreationException(mbd.getResourceDescription(), beanName, ex.getMessage(), ex);
     }
   }
    /************省略其他代码*************/
   return exposedObject;
}
```

在AbstractAutowireCapableBeanFactory类的doCreateBean()方法中，为Bean的属性赋值后会调用initializeBean()方法对Bean进行初始化。

（9）解析AbstractAutowireCapableBeanFactory类的initializeBean(String beanName, Object bean, RootBeanDefinition mbd)方法

```java
protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) {
   invokeAwareMethods(beanName, bean);
   Object wrappedBean = bean;
   if (mbd == null || !mbd.isSynthetic()) {
     wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
   }
   try {
     invokeInitMethods(beanName, wrappedBean, mbd);
   }
   catch (Throwable ex) {
     throw new BeanCreationException(   
       (mbd != null ? mbd.getResourceDescription() : null), beanName, ex.getMessage(), ex);
   }
   if (mbd == null || !mbd.isSynthetic()) {
     wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
   }
   return wrappedBean;
}
```

在AbstractAutowireCapableBeanFactory类的initializeBean()方法中，会调用applyBeanPostProcessorsBeforeInitialization()方法在初始化之前执行一些逻辑，然后调用invokeInitMethods()执行真正的初始化操作，执行完Bean的初始化，会调用applyBeanPostProcessorsAfterInitialization()方法执行初始化之后的一些逻辑。

#### **使用@Value获取属性的值**

（1）解析AutowiredFieldElement类的inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs)方法

```java
@Override
protected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable {
    Field field = (Field) this.member;
    Object value;
    if (this.cached) {
        try {
            value = resolvedCachedArgument(beanName, this.cachedFieldValue);
        }
        catch (NoSuchBeanDefinitionException ex) {
            // Unexpected removal of target bean for cached argument -> re-resolve
            value = resolveFieldValue(field, bean, beanName);
        }
    } 
    else {
        value = resolveFieldValue(field, bean, beanName);
    } 
    if (value != null) { 
        ReflectionUtils.makeAccessible(field);
        field.set(bean, value);  
    }
}
```

在AutowiredFieldElement类的inject()方法中，会调用resolveFieldValue()方法处理获取属性的值。

（2）解析AutowiredFieldElement类的resolveFieldValue(Field field, Object bean, @Nullable String beanName)方法

```java
@Nullable
private Object resolveFieldValue(Field field, Object bean, @Nullable String beanName) {
    /*************省略其他代码************/
    Object value;
    try {
        value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);
    }
    catch (BeansException ex) {
        throw new UnsatisfiedDependencyException(null, beanName, new InjectionPoint(field), ex);
    } 
     /*************省略其他代码************/
 return value;
}
```

在AutowiredFieldElement类的resolveFieldValue()方法中，会调用beanFactory对象的resolveDependency()方法

（3）解析DefaultListableBeanFactory类的resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName, @Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter)

```java
@Override
@Nullable
public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName, @Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {

    /***************省略其他代码**************/
    
    else {
        Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(descriptor, requestingBeanName);    
        if (result == null) {  
            result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter); 
        }  
        return result;
    }
}
```

在DefaultListableBeanFactory类的resolveDependency()方法中，会调用doResolveDependency()方法进一步处理。

（4）解析DefaultListableBeanFactory类的doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName, @Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter)方法

```java
@Nullable
public Object doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName, @Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {
	/************省略其他代码*************/
	Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);	
	if (value != null) {
	    if (value instanceof String strValue) {
	        String resolvedValue = resolveEmbeddedValue(strValue);
	        BeanDefinition bd = (beanName != null && containsBean(beanName) ?
	                             getMergedBeanDefinition(beanName) : null);
	        value = evaluateBeanDefinitionString(resolvedValue, bd);
	    }
	    TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());
	    try {
	        return converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());
	    }
	    catch (UnsupportedOperationException ex) {
	        // A custom TypeConverter which does not support TypeDescriptor resolution...	
	        return (descriptor.getField() != null ?	
	                converter.convertIfNecessary(value, type, descriptor.getField()) :	
	                converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));	
	    }	
	}	
	/************省略其他代码*************/
}


```

在DefaultListableBeanFactory类的doResolveDependency()方法中，如果当前获取到的数据是String类型，则调用resolveEmbeddedValue()方法进行处理。

（5）解析AbstractBeanFactory类的resolveEmbeddedValue(@Nullable String value)方法

```java
@Override
@Nullable
public String resolveEmbeddedValue(@Nullable String value) {
    if (value == null) {  
        return null; 
    }  
    String result = value;  
    for (StringValueResolver resolver : this.embeddedValueResolvers) {   
        result = resolver.resolveStringValue(result); 
        if (result == null) {   
            return null;  
        }  
    }  
    return result;
}
```

在AbstractBeanFactory类的resolveEmbeddedValue()中，会调用遍历出来的StringValueResolver对象的resolveStringValue()方法进行处理。此时，会进入AbstractEnvironment类的resolvePlaceholders(String text)方法。

（6）解析AbstractEnvironment类的resolvePlaceholders(String text)方法

```java
@Override
public String resolvePlaceholders(String text) {
    return this.propertyResolver.resolvePlaceholders(text);
}
```

在AbstractEnvironment类的resolvePlaceholders()方法中，会调用propertyResolver对象的resolvePlaceholders()方法进行处理。

（7）解析AbstractPropertyResolver类的resolvePlaceholders(String text)方法

```java
@Override
public String resolvePlaceholders(String text) {
    if (this.nonStrictHelper == null) {
        this.nonStrictHelper = createPlaceholderHelper(true);  
    }  
    return doResolvePlaceholders(text, this.nonStrictHelper);
}
```

在AbstractPropertyResolver类的resolvePlaceholders()方法中，会调用doResolvePlaceholders()方法进一步处理。

（8）解析AbstractPropertyResolver类的doResolvePlaceholders(String text, PropertyPlaceholderHelper helper)方法

```java
private String doResolvePlaceholders(String text, PropertyPlaceholderHelper helper) {
    return helper.replacePlaceholders(text, this::getPropertyAsRawString);
}
```

在AbstractPropertyResolver类的doResolvePlaceholders()方法中，会解析 ${[xxx.xxx](http://xxx.xxx/)} 这种占位，最终获取到 key = [xxx.xxx](http://xxx.xxx/)，随后根据key去资源文件(xml、application.properties、Environment 等)中查找是否配置了这个key的值。其实是通过调用helper的replacePlaceholders()方法并以Lambda表达式的方式传入getPropertyAsRawString()方法实现的。

（9）解析PropertyPlaceholderHelper类的replacePlaceholders(String value, PlaceholderResolver placeholderResolver)方法

```java
public String replacePlaceholders(String value, PlaceholderResolver placeholderResolver) {
    Assert.notNull(value, "'value' must not be null");   
    return parseStringValue(value, placeholderResolver, null);
}
```

在PropertyPlaceholderHelper类的replacePlaceholders()方法中，会调用parseStringValue()方法解析String类型的数据。

（10）解析PropertyPlaceholderHelper类的parseStringValue(String value, PlaceholderResolver placeholderResolver, @Nullable Set<String> visitedPlaceholders)方法

```java
protected String parseStringValue(String value, PlaceholderResolver placeholderResolver, @Nullable Set<String> visitedPlaceholders) {
    /***************省略其他代码****************/ 
    // Now obtain the value for the fully resolved key...    
    String propVal = placeholderResolver.resolvePlaceholder(placeholder);   
    if (propVal == null && this.valueSeparator != null) {  
        int separatorIndex = placeholder.indexOf(this.valueSeparator);   
        if (separatorIndex != -1) {  
            String actualPlaceholder = placeholder.substring(0, separatorIndex); 
            String defaultValue = placeholder.substring(separatorIndex + this.valueSeparator.length()); 
            propVal = placeholderResolver.resolvePlaceholder(actualPlaceholder);  
            if (propVal == null) {
                propVal = defaultValue; 
            } 
        }   
    }  
    /**********省略其他代码***********/
}
```

重点关注如下代码片段。

```java
String propVal = placeholderResolver.resolvePlaceholder(placeholder);
```

会调用placeholderResolver对象的resolvePlaceholder()方法传入解析 ${[xxx.xxx](http://xxx.xxx/)} 占位符，获取到的key，其中key的形式为[xxx.xxx](http://xxx.xxx/)。调用placeholderResolver对象的resolvePlaceholder()方法会最终调用PropertySourcesPropertyResolver类的getPropertyAsRawString()方法。

（11）解析PropertySourcesPropertyResolver类的getPropertyAsRawString(String key)方法

```java
@Override
@Nullable
protected String getPropertyAsRawString(String key) {
    return getProperty(key, String.class, false);
}
```

在getPropertyAsRawString()方法中，会调用getProperty()方法获取属性的值。在调用getPropertyAsRawString()方法时，传入的Key的形式的规则就是：如果使用@Value标注的属性为 ${[xxx.xxx](http://xxx.xxx/)} 占位符，则此处传入的Key的形式为[xxx.xxx](http://xxx.xxx/)。

（12）解析PropertySourcesPropertyResolver类的getProperty(String key, Class<T> targetValueType, boolean resolveNestedPlaceholders)方法

```java
@Nullable
protected <T> T getProperty(String key, Class<T> targetValueType, boolean resolveNestedPlaceholders) {
    if (this.propertySources != null) {  
        for (PropertySource<?> propertySource : this.propertySources) {  
            if (logger.isTraceEnabled()) {   
                logger.trace("Searching for key '" + key + "' in PropertySource '" +  
                             propertySource.getName() + "'");   
            }   
            Object value = propertySource.getProperty(key);  
            if (value != null) {
              if (resolveNestedPlaceholders && value instanceof String string) {
                    value = resolveNestedPlaceholders(string);  
                }
              logKeyFound(key, propertySource, value);  
                return convertValueIfNecessary(value, targetValueType);   
            } 
        }    
    }   
    if (logger.isTraceEnabled()) {  
        logger.trace("Could not find key '" + key + "' in any property source");   
    }    
    return null;
}
```

在PropertySourcesPropertyResolver类的getProperty()方法中，会从 propertySources 资源中获取 key = [xxx.xxx](http://xxx.xxx/) 的值，如果获取到一个对应的值，就会直接返回。其中，在propertySources中会封装PropertiesPropertySource、SystemEnvironmentPropertySource和ResourcePropertySource类型的对象。每种类型的对象中封装的信息如下所示。

1. PropertiesPropertySource：封装 JVM 环境变量中的键值对。
2. SystemEnvironmentPropertySource：封装操作系统环境变量中的键值对。
3. ResourcePropertySource：封装项目中application.properties、yml和xml等文件中的键值对。

从ResourcePropertySource对象中获取到对应的值就可以设置到被@Value注解标注的字段上。

### 思考

#### 1. @Value注解的作用

@Value注解用于将配置信息或特定的值注入到Bean的字段、方法参数或返回值中。它可以将外部配置（如application.properties或application.yml文件中的属性）或字面量值（如字符串、数字等）注入到Bean中，从而避免了硬编码，提高了代码的可维护性和灵活性。

#### 2. @Value注解的使用场景

1. **注入外部配置**：将application.properties或application.yml等配置文件中的属性值注入到Bean的字段中，以便在应用程序中使用这些配置。
2. **注入字面量值**：直接注入简单的字面量值，如字符串、数字等，到Bean的字段中。
3. **注入系统属性**：通过SpEL（Spring Expression Language）表达式注入系统属性，如`@Value("#{systemProperties['java.home']}")`。
4. **注入表达式结果**：使用SpEL表达式计算结果并注入到Bean的字段中，如`@Value("#{ T(java.lang.Math).random() * 100.0 }")`。
5. **注入其他Bean的属性**：通过SpEL表达式注入其他Bean的属性值，如`@Value("#{otherBean.propertyName}")`。

#### 3. @Value向Bean的字段和方法注入值是如何实现的

@Value向Bean的字段和方法注入值主要通过Spring的依赖注入（DI）机制实现。具体来说，当Spring容器启动时，它会扫描带有@Component、@Service等注解的类，并识别出这些类中的@Value注解。对于字段上的@Value注解，Spring会在Bean实例化后，通过反射机制将配置值或字面量值注入到相应的字段中。对于方法参数上的@Value注解，通常用于构造器注入或Setter方法注入，Spring会在调用构造器或Setter方法时，将值作为参数传递给这些方法。

#### 4. @Value注解在Spring内部的执行流程

@Value注解在Spring内部的执行流程大致如下：

1. **扫描与解析**：Spring容器在启动时，会扫描带有@Component等注解的类，并解析这些类中的@Value注解。
2. **值解析**：对于@Value注解中的值，Spring会进行解析。如果值是简单的字面量，则直接解析为相应的类型；如果值是占位符（如`${key}`），则会从配置文件中查找对应的值；如果值是SpEL表达式，则会计算表达式的结果。
3. **依赖注入**：将解析后的值注入到Bean的字段中或通过方法参数传递给Bean的构造器或Setter方法。

#### 5. @Value注解在Spring源码中的执行流程与@Autowired注解的区别

1. **用途区别**：
   - @Value注解主要用于注入配置信息或字面量值，它更侧重于将外部配置或静态值注入到Bean中。
   - @Autowired注解则主要用于自动装配Bean，它可以根据类型或名称自动将Bean注入到其他Bean的字段、构造器或Setter方法中，实现Bean之间的依赖关系。
2. **注入方式区别**：
   - @Value注解的注入方式比较灵活，可以注入简单的字面量值、配置文件中的值、系统属性、表达式结果等。
   - @Autowired注解的注入方式相对固定，它主要根据类型或名称进行注入，且主要用于Bean之间的依赖注入。
3. **执行流程区别**：
   - 在执行流程上，@Value注解和@Autowired注解都会经历扫描、解析和依赖注入等阶段，但具体的解析逻辑和注入方式有所不同。@Value注解需要解析占位符和SpEL表达式，而@Autowired注解则需要根据类型或名称查找并注入Bean。



## 1.12
