---
title: Spring6源码
date: 2024-08-05 17:23:12
permalink: /pages/aade1
---





# 一. IOC容器

## 1.1 @Configuration注解

@Configuration注解是从Spring 3.0版本开始加入的一个使Spring能够支持注解驱动开发的标注型注解，主要用于标注在类上。当某个类标注了@Configuration注解时，表示这个类是Spring的一个配置类。@Configuration注解能够替代Spring的applicationContext.xml文件，并且被@Configuration注解标注的类，能够自动注册到IOC容器并进行实例化。

### 注解源码

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Configuration {
	@AliasFor(annotation = Component.class)
	String value() default "";
    //Since: 5.2
	boolean proxyBeanMethods() default true;
    //Since: 6.0
	boolean enforceUniqueMethods() default true;
}
```

@Configuration注解中每个属性的含义如下所示。

* value：存入到Spring IOC容器中的Bean的id。
* proxyBeanMethods：表示被@Configuration注解标注的配置类是否会被代理，并且在配置类中使用@Bean注解生成的Bean对象在IOC容器中是否是单例对象，取值为true或者false。当取值为true时，表示full（全局）模式，此模式下被@Configuration注解标注的配置类会被代理，在配置类中使用@Bean注解注入到IOC容器中的Bean对象是单例模式，无论调用多少次被@Bean注解标注的方法，返回的都是同一个Bean对象。当取值为false时，表示lite（轻量级）模式，此模式下被@Configuration注解标注的配置类不会被代理，在配置类中使用@Bean注解注入到IOC容器中的Bean对象不是单例模式，每次调用被@Bean注解标注的方法时，都会返回一个新的Bean对象。默认的取值为true。
* enforceUniqueMethods：指定使用@Bean注解标注的方法是否需要具有唯一的方法名称，取值为true或者false。当取值为true时，表示使用@Bean注解标注的方法具有唯一的方法名称，并且这些方法名称不会重叠。当取值为false时，表示使用@Bean注解标注的方法名称不唯一，存在被重叠的风险。默认取值为true。

@Configuration注解本质上是一个@Component注解，所以被@Configuration注解标注的配置类本身也会被注册到IOC容器中。同时，@Configuration注解也会被@ComponentScan注解扫描到。

### 源码时序图

@Configuration注解在源码层面的执行流程涉及到注册与实例化两种执行流程。

* 注册流程：涉及到Spring内部的ConfigurationClassPostProcessor类的Bean定义信息的注册，以及标注了@Configuration注解的Config配置类的Bean定义信息注册。
* 实例化流程：Spring IOC容器在启动过程中，最终会调用AnnotationConfigApplicationContext类的refresh()方法刷新IOC容器，刷新IOC容器的过程中就会对标注了@Configuration注解的配置类进行实例化。

#### **注册ConfigurationClassPostProcessor流程源码时序图**

ConfigurationClassPostProcessor后置处理器是解析@Configuration注解的核心类，Spring IOC容器启动时，会向IOC容器中注册ConfigurationClassPostProcessor类的Bean定义信息。

![图1-1](https://upload.yolo912.icu/mdImage/spring-core-2022-12-05-001.png)

#### **注册配置类流程源码时序图**

在配置类上标注了@Configuration注解，当Spring IOC容器启动时，也会将配置类的Bean定义信息注册到Spring IOC容器中

![图1-2](https://upload.yolo912.icu/mdImage/spring-core-2022-12-05-002.png)

> Spring IOC容器在启动时，会向IOC容器中注册ConfigurationClassPostProcessor类的bean定义信息和使用@Configuration注解标注的配置类的Bean定义信息。当Spring IOC容器再刷新时，会递归处理所有使用@Configuration注解标注的类，解析@Bean等注解标注的方法，解析成一个个ConfigurationClassBeanDefinition类型的BeanDefinition对象，注册到IOC容器中。

#### **实例化流程源码时序图**

Spring IOC容器在启动过程中，最终会调用AnnotationConfigApplicationContext类的refresh()方法刷新IOC容器，刷新IOC容器的过程中就会对标注了@Configuration注解的配置类进行实例化。

![图1-3-1](https://upload.yolo912.icu/mdImage/spring-core-2022-12-05-003.png)

![图1-3-2](https://upload.yolo912.icu/mdImage/spring-core-2022-12-05-004.png)

### 源码解析

#### 注册ConfigurationClassPostProcessor流程源码解析

（1）运行案例程序启动类ConfigurationAnnotationTest的main()方法

```java
public class ConfigurationAnnotationTest {

    private static final Logger LOGGER = LoggerFactory.getLogger(ConfigurationAnnotationTest.class);

    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ConfigurationAnnotationConfig.class);
        ConfigurationAnnotationConfig config = context.getBean(ConfigurationAnnotationConfig.class);
        Person person1 = config.person();
        Person person2 = config.person();
        LOGGER.info("person1 是否等于 person2 ===>> {}", (person1 == person2));
    }
}
```

在main()方法中会调用AnnotationConfigApplicationContext类的构造方法传入配置类ConfigurationAnnotationConfig的Class对象来创建IOC容器。接下来，会进入AnnotationConfigApplicationContext类的构造方法。

（2）解析AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext(Class<?>... componentClasses)构造方法

```java
public AnnotationConfigApplicationContext(Class<?>... componentClasses) {
    this();
    register(componentClasses);
    refresh();
}
```

上述构造方法中，会通过this()调用AnnotationConfigApplicationContext类的无参构造方法。

（3）解析AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext()无参构造方法

```java
public AnnotationConfigApplicationContext() {
    StartupStep createAnnotatedBeanDefReader = this.getApplicationStartup().start("spring.context.annotated-bean-reader.create");
    this.reader = new AnnotatedBeanDefinitionReader(this);
    createAnnotatedBeanDefReader.end();
    this.scanner = new ClassPathBeanDefinitionScanner(this);
}
```

在AnnotationConfigApplicationContext类的无参构造方法中，主要的逻辑就是实例化了AnnotatedBeanDefinitionReader类型的reader成员变量和ClassPathBeanDefinitionScanner类型的scanner成员变量。

* reader：表示注解类型的Bean定义信息读取器，主要就是读取通过注解方式进行实例化的Bean的定义信息。
* scanner：表示类路径下的Bean定义扫描器，主要就是扫描类路径下的Bean定义信息。

接下来会调用AnnotatedBeanDefinitionReader类中的AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry)构造方法。

（4）解析AnnotatedBeanDefinitionReader类中的AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry)构造方法

```java
public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry) {
    this(registry, getOrCreateEnvironment(registry));
}
```

在上述构造方法中，通过this调用了AnnotatedBeanDefinitionReader类的AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment)构造方法。

（5）解析AnnotatedBeanDefinitionReader类的AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment)构造方法

```java
public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment) {
    Assert.notNull(registry, "BeanDefinitionRegistry must not be null");
    Assert.notNull(environment, "Environment must not be null");
    this.registry = registry;
    this.conditionEvaluator = new ConditionEvaluator(registry, environment, null);
    AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);
}
```

在上述构造方法中，最核心的逻辑就是调用了AnnotationConfigUtils工具类的registerAnnotationConfigProcessors()方法，将BeanDefinitionRegistry类型的registry对象传入方法中。registry对象本质上就是一个AnnotationConfigApplicationContext类对象的实例，因为AnnotationConfigApplicationContext类继承了GenericApplicationContext类，而GenericApplicationContext类实现了BeanDefinitionRegistry接口。

（6）解析AnnotationConfigUtils类的registerAnnotationConfigProcessors(BeanDefinitionRegistry registry)方法

```java
public static void registerAnnotationConfigProcessors(BeanDefinitionRegistry registry) {
    registerAnnotationConfigProcessors(registry, null);
}
```

（7）解析AnnotationConfigUtils类的registerAnnotationConfigProcessors(BeanDefinitionRegistry registry, Object source)方法

```java
public static Set<BeanDefinitionHolder> registerAnnotationConfigProcessors(
			BeanDefinitionRegistry registry, @Nullable Object source) {

    // 获取默认的ListableBeanFactory
    DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);
    if (beanFactory != null) {
        // 如果依赖比较器不是AnnotationAwareOrderComparator的实例，则设置依赖比较器为AnnotationAwareOrderComparator
        if (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) {
            beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);
        }
        // 如果自动装配候选解析器不是ContextAnnotationAutowireCandidateResolver的实例，则设置自动装配候选解析器为新的ContextAnnotationAutowireCandidateResolver
        if (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) {
            beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());
        }
    }

    // 创建一个LinkedHashSet来存储bean定义
    Set<BeanDefinitionHolder> beanDefs = new LinkedHashSet<>(8);

    // 如果注册表中不存在CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME的bean定义
    if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {
        // 创建一个新的RootBeanDefinition实例，并设置其类为ConfigurationClassPostProcessor
        RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);
        // 设置bean定义的源为传入的source
        def.setSource(source);
        // 注册后处理器，并将返回的BeanDefinitionHolder添加到beanDefs集合中
        beanDefs.add(registerPostProcessor(registry, def,CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));
    }

    // 如果注册表中不存在AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME的bean定义
    if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {
        // 创建一个新的RootBeanDefinition实例，并设置其类为AutowiredAnnotationBeanPostProcessor
        RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);
        // 设置bean定义的源为传入的source
        def.setSource(source);
        // 注册后处理器，并将返回的BeanDefinitionHolder添加到beanDefs集合中
        beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));
    }

    // 检查是否存在Jakarta Annotations支持，如果存在则添加CommonAnnotationBeanPostProcessor
    // Check for Jakarta Annotations support, and if present add the CommonAnnotationBeanPostProcessor.
    if (jakartaAnnotationsPresent && !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) {
        // 创建一个新的RootBeanDefinition实例，并设置其类为CommonAnnotationBeanPostProcessor
        RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);
        // 设置bean定义的源为传入的source
        def.setSource(source);
        // 注册后处理器，并将返回的BeanDefinitionHolder添加到beanDefs集合中
        beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));
    }

    // 检查是否支持JSR-250，如果支持则添加InitDestroyAnnotationBeanPostProcessor用于javax的PostConstruct/PreDestroy注解
    if (jsr250Present && !registry.containsBeanDefinition(JSR250_ANNOTATION_PROCESSOR_BEAN_NAME)) {
        try {
            // 创建InitDestroyAnnotationBeanPostProcessor的RootBeanDefinition
            RootBeanDefinition def = new RootBeanDefinition(InitDestroyAnnotationBeanPostProcessor.class);
            // 添加initAnnotationType属性，值为javax.annotation.PostConstruct的Class对象
            def.getPropertyValues().add("initAnnotationType", classLoader.loadClass("javax.annotation.PostConstruct"));
            // 添加destroyAnnotationType属性，值为javax.annotation.PreDestroy的Class对象
            def.getPropertyValues().add("destroyAnnotationType", classLoader.loadClass("javax.annotation.PreDestroy"));
            // 设置bean定义的源为传入的source
            def.setSource(source);
            // 注册后处理器，并将返回的BeanDefinitionHolder添加到beanDefs集合中
            beanDefs.add(registerPostProcessor(registry, def, JSR250_ANNOTATION_PROCESSOR_BEAN_NAME));
        }
        catch (ClassNotFoundException ex) {
            // 加载javax注解类型的类失败，忽略异常
            // Failed to load javax variants of the annotation types -> ignore.
        }
    }

    // 检查是否支持JPA，如果支持则添加PersistenceAnnotationBeanPostProcessor
    if (jpaPresent && !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) {
        // 创建RootBeanDefinition
        RootBeanDefinition def = new RootBeanDefinition();
        try {
            // 设置bean的类为PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME指定的类
            def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,
                                                AnnotationConfigUtils.class.getClassLoader()));
        }
        catch (ClassNotFoundException ex) {
            // 抛出异常，无法加载可选的框架类
            throw new IllegalStateException(
                "Cannot load optional framework class: " + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);
        }
        // 设置bean定义的源为传入的source
        def.setSource(source);
        // 注册后处理器，并将返回的BeanDefinitionHolder添加到beanDefs集合中
        beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));
    }

    // 如果注册表中不存在EVENT_LISTENER_PROCESSOR_BEAN_NAME的bean定义
    if (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) {
        // 创建EventListenerMethodProcessor的RootBeanDefinition
        RootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);
        // 设置bean定义的源为传入的source
        def.setSource(source);
        // 注册后处理器，并将返回的BeanDefinitionHolder添加到beanDefs集合中
        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));
    }

    // 如果注册表中不存在EVENT_LISTENER_FACTORY_BEAN_NAME的bean定义
    if (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) {
        // 创建DefaultEventListenerFactory的RootBeanDefinition
        RootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);
        // 设置bean定义的源为传入的source
        def.setSource(source);
        // 注册后处理器，并将返回的BeanDefinitionHolder添加到beanDefs集合中
        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));
    }

    // 返回beanDefs集合
    return beanDefs;
}
```

其中将@Configuration注解涉及到的ConfigurationClassPostProcessor类的Bean定义信息注册到IOC容器中的核心代码为：

```java
public static Set<BeanDefinitionHolder> registerAnnotationConfigProcessors(
			BeanDefinitionRegistry registry, @Nullable Object source) {
    //################省略其他代码########################
    // 如果注册表中不存在CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME的bean定义
    if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {
        // 创建一个新的RootBeanDefinition实例，并设置其类为ConfigurationClassPostProcessor
        RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);
        // 设置bean定义的源为传入的source
        def.setSource(source);
        // 注册后处理器，并将返回的BeanDefinitionHolder添加到beanDefs集合中
        beanDefs.add(registerPostProcessor(registry, def,CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));
    }
    //################省略其他代码########################
}
```

（8）解析registerPostProcessor(BeanDefinitionRegistry registry, RootBeanDefinition definition, String beanName)方法

```java
private static BeanDefinitionHolder registerPostProcessor(
    BeanDefinitionRegistry registry, RootBeanDefinition definition, String beanName) {
    definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
    registry.registerBeanDefinition(beanName, definition);
    return new BeanDefinitionHolder(definition, beanName);
}
```

上述代码调用了registry参数的registerBeanDefinition()方法来注册ConfigurationClassPostProcessor类的Bean定义信息，definition参数本质上就是一个AnnotationConfigApplicationContext类的实例对象。最终会调用DefaultListableBeanFactory类的registerBeanDefinition()方法来注册ConfigurationClassPostProcessor类的Bean定义信息。

（9）解析DefaultListableBeanFactory类的registerBeanDefinition(String beanName, BeanDefinition beanDefinition)方法

```java
@Override
public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
    throws BeanDefinitionStoreException {

    // 断言beanName非空
    Assert.hasText(beanName, "Bean name must not be empty");
    // 断言beanDefinition非空
    Assert.notNull(beanDefinition, "BeanDefinition must not be null");

    // 判断beanDefinition是否是AbstractBeanDefinition的实例
    if (beanDefinition instanceof AbstractBeanDefinition abd) {
        try {
            // 验证bean定义
            abd.validate();
        }
        catch (BeanDefinitionValidationException ex) {
            // 抛出BeanDefinitionStoreException异常，包含bean定义资源描述、beanName以及异常信息
            throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
                                                   "Validation of bean definition failed", ex);
        }
    }

    // 获取beanName对应的BeanDefinition
    BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);

    if (existingDefinition != null) {
        if (!isAllowBeanDefinitionOverriding()) {
            // 如果不允许覆盖Bean定义，则抛出异常
            throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);
        }
        else if (existingDefinition.getRole() < beanDefinition.getRole()) {
            // 如果现有Bean定义的角色小于新Bean定义的角色，则进行覆盖
            // 例如，之前是ROLE_APPLICATION，现在用ROLE_SUPPORT或ROLE_INFRASTRUCTURE覆盖
            if (logger.isInfoEnabled()) {
                logger.info("Overriding user-defined bean definition for bean '" + beanName +
                            "' with a framework-generated bean definition: replacing [" +
                            existingDefinition + "] with [" + beanDefinition + "]");
            }
        }
        else if (!beanDefinition.equals(existingDefinition)) {
            // 如果新Bean定义与现有Bean定义不相等，则进行覆盖
            if (logger.isDebugEnabled()) {
                logger.debug("Overriding bean definition for bean '" + beanName +
                             "' with a different definition: replacing [" + existingDefinition +
                             "] with [" + beanDefinition + "]");
            }
        }
        else {
            // 如果新Bean定义与现有Bean定义相等，则进行覆盖（尽管它们相等，但可能由于其他原因需要覆盖）
            if (logger.isTraceEnabled()) {
                logger.trace("Overriding bean definition for bean '" + beanName +
                             "' with an equivalent definition: replacing [" + existingDefinition +
                             "] with [" + beanDefinition + "]");
            }
        }
        // 将新Bean定义放入beanDefinitionMap中，覆盖现有Bean定义
        this.beanDefinitionMap.put(beanName, beanDefinition);
    }
    else {
        if (isAlias(beanName)) {
            if (!isAllowBeanDefinitionOverriding()) {
                String aliasedName = canonicalName(beanName);
                if (containsBeanDefinition(aliasedName)) {
                    // 如果别名指向已存在的Bean定义
                    // alias for existing bean definition
                    throw new BeanDefinitionOverrideException(
                        beanName, beanDefinition, getBeanDefinition(aliasedName));
                }
                else {
                    // 如果别名指向不存在的Bean定义
                    // alias pointing to non-existing bean definition
                    throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
                                                           "Cannot register bean definition for bean '" + beanName +
                                                           "' since there is already an alias for bean '" + aliasedName + "' bound.");
                }
            }
            else {
                // 移除别名
                removeAlias(beanName);
            }
        }
        if (hasBeanCreationStarted()) {
            // 不能再修改启动时的集合元素（为了稳定的迭代）
            // Cannot modify startup-time collection elements anymore (for stable iteration)
            synchronized (this.beanDefinitionMap) {
                this.beanDefinitionMap.put(beanName, beanDefinition);
                List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);
                updatedDefinitions.addAll(this.beanDefinitionNames);
                updatedDefinitions.add(beanName);
                this.beanDefinitionNames = updatedDefinitions;
                removeManualSingletonName(beanName);
            }
        }
        else {
            // 仍然处于启动注册阶段
            // Still in startup registration phase
            this.beanDefinitionMap.put(beanName, beanDefinition);
            this.beanDefinitionNames.add(beanName);
            removeManualSingletonName(beanName);
        }
        this.frozenBeanDefinitionNames = null;
    }

    if (existingDefinition != null || containsSingleton(beanName)) {
        // 重置Bean定义
        resetBeanDefinition(beanName);
    }
    else if (isConfigurationFrozen()) {
        // 清除按类型缓存
        clearByTypeCache();
    }
}
```

向Spring的IOC容器中注册类的Bean定义信息，其实就是向beanDefinitionMap对象中添加元素，beanDefinitionMap对象本质上是一个ConcurrentHashMap对象。向beanDefinitionMap对象中添加的元素的Key为Bean的名称，Value为Bean的定义信息。

```java
@Override
public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
    throws BeanDefinitionStoreException {
    //##################省略其他代码###############
	this.beanDefinitionMap.put(beanName, beanDefinition);
    //##################省略其他代码###############
}
```

beanDefinitionMap源码:

```java
private final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>(256);
```

#### 注册配置类流程源码解析

（1）AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext(Class<?>... componentClasses)构造方法中调用了register()方法，传入componentClasses参数进行注册。

```java
public AnnotationConfigApplicationContext(Class<?>... componentClasses) {
    this();
    register(componentClasses);
    refresh();
}
```

（2）解析AnnotationConfigApplicationContext类的register(Class<?>... componentClasses)方法

```java
@Override
public void register(Class<?>... componentClasses) {
	//###########省略其他代码##############
    this.reader.register(componentClasses);
    //###########省略其他代码##############
}
```

（3）解析AnnotatedBeanDefinitionReader类的register(Class<?>... componentClasses)方法

```java
public void register(Class<?>... componentClasses) {
    for (Class<?> componentClass : componentClasses) {
        registerBean(componentClass);
    }
}
```

（4）解析AnnotatedBeanDefinitionReader类的registerBean(Class<?> beanClass)方法

```java
public void registerBean(Class<?> beanClass) {
    doRegisterBean(beanClass, null, null, null, null);
}
```

（5）解析AnnotatedBeanDefinitionReader类的doRegisterBean(Class<T> beanClass, String name, Class<? extends Annotation>[] qualifiers, Supplier<T> supplier, BeanDefinitionCustomizer[] customizers)方法。

```java
private <T> void doRegisterBean(Class<T> beanClass, @Nullable String name,@Nullable Class<? extends Annotation>[] qualifiers, @Nullable Supplier<T> supplier, @Nullable BeanDefinitionCustomizer[] customizers) {

    AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(beanClass);
    //###########################省略其他代码#############################
    String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));
    //###########################省略其他代码#############################
    BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);
    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
    BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
}
```

（6）解析BeanDefinitionReaderUtils类的registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)方法

```java
public static void registerBeanDefinition(
    BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
    throws BeanDefinitionStoreException {

    // Register bean definition under primary name.
    String beanName = definitionHolder.getBeanName();
    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
    //###########################省略其他代码#############################
}
```

在registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)方法中通过调用registry的registerBeanDefinition()方法来向IOC容器中注册Bean定义信息。

#### 实例化流程源码解析

（1）AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext(Class<?>... componentClasses)构造方法中会调用refresh()方法刷新IOC容器。

```java
public AnnotationConfigApplicationContext(Class<?>... componentClasses) {
    this();
    register(componentClasses);
    refresh();
}
```

（2）解析AbstractApplicationContext类的refresh()方法

```java
@Override
public void refresh() throws BeansException, IllegalStateException {
    synchronized (this.startupShutdownMonitor) {
		//#############省略其他代码#####################
        try {
            //#############省略其他代码#####################
            invokeBeanFactoryPostProcessors(beanFactory);
			//#############省略其他代码#####################
        }
        catch (BeansException ex) {
           //#############省略其他代码#####################
        }
        finally {
           //#############省略其他代码#####################
        }
    }
}
```

在refresh()方法中调用了invokeBeanFactoryPostProcessors()方法。

（3）解析AbstractApplicationContext类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory)方法

```java
protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
	//################省略其他代码####################
}
```

（4）解析PostProcessorRegistrationDelegate类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors)方法

```java
public static void invokeBeanFactoryPostProcessors(
    ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {
	//#################省略其他代码##################
    invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
	invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
    //#################省略其他代码##################
}
```

在invokeBeanFactoryPostProcessors()方法中会解析标注了@Configuration注解的类中标注了@Bean等注解的方法，生成相应的Bean定义信息注册到IOC容器中。这里主要关注的是标注了@Configuration注解的类的实例化过程

（5）解析PostProcessorRegistrationDelegate类的invokeBeanFactoryPostProcessors(Collection<? extends BeanFactoryPostProcessor> postProcessors, ConfigurableListableBeanFactory beanFactory)方法

```java
private static void invokeBeanFactoryPostProcessors(Collection<? extends BeanFactoryPostProcessor> postProcessors, ConfigurableListableBeanFactory beanFactory) {
    for (BeanFactoryPostProcessor postProcessor : postProcessors) {
        StartupStep postProcessBeanFactory = beanFactory.getApplicationStartup().start("spring.context.bean-factory.post-process")
            .tag("postProcessor", postProcessor::toString);
        postProcessor.postProcessBeanFactory(beanFactory);
        postProcessBeanFactory.end();
    }
}
```

可以看到在invokeBeanFactoryPostProcessors()方法中，会循环遍历传递进来的所有postProcessors集合，每次循环时，都会使用一个postProcessor对象来接收postProcessors集合中的每一个元素，调用postProcessor对象的postProcessBeanFactory()方法，并传入beanFactory来实例化对象。

（6）解析ConfigurationClassPostProcessor类中的postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)方法

```java
@Override
public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
    //##############省略其他代码###############
    enhanceConfigurationClasses(beanFactory);
    beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory));
}
```

（7）解析ConfigurationClassPostProcessor类的enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory)方法

```java
public void enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory) {
    //################省略其他代码########################
    ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer();
    for (Map.Entry<String, AbstractBeanDefinition> entry : configBeanDefs.entrySet()) {
        AbstractBeanDefinition beanDef = entry.getValue();
        // If a @Configuration class gets proxied, always proxy the target class
        beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);
        // Set enhanced subclass of the user-specified bean class
        Class<?> configClass = beanDef.getBeanClass();
        Class<?> enhancedClass = enhancer.enhance(configClass, this.beanClassLoader);
        if (configClass != enhancedClass) {
            //################省略其他代码###################
            beanDef.setBeanClass(enhancedClass);
        }
    }
    enhanceConfigClasses.tag("classCount", () -> String.valueOf(configBeanDefs.keySet().size())).end();
}
```

enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory)方法主要是使用ConfigurationClassEnhancer对象的enhance()方法生成代理类，也就是使用CGLib生成代理类。

（8）解析ConfigurationClassEnhancer类的enhance(Class<?> configClass, ClassLoader classLoader)方法

```java
public Class<?> enhance(Class<?> configClass, @Nullable ClassLoader classLoader) {
    //###################省略其他代码###############
    Class<?> enhancedClass = createClass(newEnhancer(configClass, classLoader));
    //###################省略其他代码###############
    return enhancedClass;
}
```

enhance(Class<?> configClass, ClassLoader classLoader)方法中调用了createClass()方法创建代理类，在这之前先调用newEnhancer()方法实例化Enhancer对象。

（9）解析ConfigurationClassEnhancer类的newEnhancer(Class<?> configSuperClass, ClassLoader classLoader)方法

```java
private Enhancer newEnhancer(Class<?> configSuperClass, @Nullable ClassLoader classLoader) {
    Enhancer enhancer = new Enhancer();
    enhancer.setSuperclass(configSuperClass);
    enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class});
    enhancer.setUseFactory(false);
    enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
    enhancer.setAttemptLoad(true);
    enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader));
    enhancer.setCallbackFilter(CALLBACK_FILTER);
    enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());
    return enhancer;
}
```

newEnhancer()方法中主要是生成CGLib动态代理的Enhancer对象，后续会使用Enhancer对象生成代理类。

在newEnhancer()方法中为要生成的代理类设置了父类和接口，由于为要生成的代理类设置的接口为EnhancedConfiguration，同时，EnhancedConfiguration接口继承了BeanFactoryAware接口，所以，在后续生成的代理类中可以调用BeanFactoryAware接口的setBeanFactory(BeanFactory beanFactory)方法获取到beanFactory对象。

（10）解析ConfigurationClassEnhancer类的createClass(Enhancer enhancer)方法

```java
private Class<?> createClass(Enhancer enhancer) {
    Class<?> subclass = enhancer.createClass();
    Enhancer.registerStaticCallbacks(subclass, CALLBACKS);
    return subclass;
}
```

在createClass(Enhancer enhancer)方法中主要调用了enhancer对象的createClass()方法来创建代理类，这里创建出来的代理类就是目标类的子类。。

（11）解析CALLBACKS

```java
static final Callback[] CALLBACKS = new Callback[] {
    new BeanMethodInterceptor(),
    new BeanFactoryAwareMethodInterceptor(),
    NoOp.INSTANCE
};
```

CALLBACKS是一个Callback类型的数组，数组中的每个元素都是一个Callback类型的对象。其中，BeanMethodInterceptor类和BeanFactoryAwareMethodInterceptor类也是拦截器类型。接下来，以BeanMethodInterceptor类为例进行介绍。

（12）解析BeanMethodInterceptor类

BeanMethodInterceptor实现了MethodInterceptor接口和ConditionalCallback接口，主要的作用就是对标注了@Bean的注解的方法进行拦截，执行intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,  MethodProxy  cglibMethodProxy)方法，生成Bean的实例对象。

```java
public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,
					MethodProxy cglibMethodProxy) throws Throwable {
    //如果已经创建了Bean的代理实例对象，则调用父类的方法。
    if (isCurrentlyInvokedFactoryMethod(beanMethod)) {
        //#################省略其他代码###############
        return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs);
    }
    return resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName);   
}
```

上述代码能够保证在类上添加@Configuration注解后，只会为类生成一个代理对象。也就是上述代码的逻辑能够保证标注了@Configuration注解的类生成的代理类是单例模式的。

因为使用CGLib创建出来的代理类是目标类的子类，所以第一次执行上述代码片段时，会调用cglibMethodProxy的invokeSuper()方法执行父类的方法，也就是执行目标类的方法。第二次执行上述代码片段时，会调用resolveBeanReference()方法。

（13）解析BeanMethodInterceptor类的resolveBeanReference(Method beanMethod, Object[] beanMethodArgs,  ConfigurableBeanFactory beanFactory, String beanName)方法

```java
private Object resolveBeanReference(Method beanMethod, Object[] beanMethodArgs, ConfigurableBeanFactory beanFactory, String beanName) {
    //##############省略其他代码###############
    boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName);
    try {
        //##############省略其他代码###############
        Object beanInstance = (useArgs ? beanFactory.getBean(beanName, beanMethodArgs) :
                               beanFactory.getBean(beanName));
       //##############省略其他代码###############
        return beanInstance;
    }
    finally {
       //##############省略其他代码###############
    }
}
```

resolveBeanReference()方法中会通过beanFactory获取已经初始化好的Bean对象，并将这个已经初始化好的bean对象返回。并不会再进行第二次初始化的操作。所以在类上添加@Configuration注解后，Spring能够保证为类生成的代理类是单例的。

### 思考

#### 1. Spring为何在创建IOC容器时先注册ConfigurationClassPostProcessor类后置处理器的Bean定义信息，随后才是注册标注了@Configuration注解的ConfigurationAnnotationConfig配置类的Bean定义信息？

Spring在创建IOC容器时首先注册`ConfigurationClassPostProcessor`类后置处理器的Bean定义信息，是因为`ConfigurationClassPostProcessor`是Spring框架用于处理带有`@Configuration`注解的类的核心组件。它负责扫描和处理这些配置类，进而解析其中的`@Bean`方法和其他相关注解。将其先注册为Bean定义，是为了在容器后续的启动和初始化过程中，能够尽早地获取到这个处理器，并利用它来解析和注册其他配置类中的Bean定义。

这种设计确保了Spring在正式解析和注册其他Bean之前，已经准备好了处理配置类的机制，从而能够有序、高效地处理整个配置过程，保证配置类中的元信息被正确处理。。

#### 2. Spring为何先将类的Bean定义信息注册到IOC容器？为何不是直接注册实例化后的对象？

Spring先将类的Bean定义信息注册到IOC容器，而不是直接注册实例化后的对象，主要是因为这种方式提供了更高的灵活性和控制力。通过注册Bean定义（包括类的信息、构造方法、依赖关系等），Spring能够在需要的时候（通常是Bean被使用时）再创建Bean的实例。这种延迟初始化的策略有助于减少启动时的内存消耗和初始化时间，同时也可以通过配置来控制Bean的创建时机和生命周期。

此外，注册Bean定义还允许Spring在创建Bean实例时应用各种依赖注入（DI）和AOP（面向切面编程）特性，如自动装配、代理创建等，从而增强了Spring框架的功能。

#### 3. Spring为何是在刷新IOC容器时，实例化标注了@Configuration注解的配置类的代理对象？为何不是在创建IOC容器时就进行实例化？

Spring在刷新IOC容器时实例化标注了`@Configuration`注解的配置类的代理对象，而不是在创建IOC容器时就进行实例化，主要是出于两个考虑：

1. **延迟加载**：通过延迟实例化配置类的代理对象，Spring可以在需要时再进行加载，这有助于减少应用启动时的初始化时间和内存消耗。
2. **增强功能**：配置类的代理对象在Spring中扮演着特殊角色，它们不仅包含了配置类的逻辑，还通过代理机制提供了额外的功能，如增强`@Bean`方法的调用（以确保每个`@Bean`方法只被调用一次并返回相同的实例）。Spring可以支持诸如`@Bean`方法的拦截，从而实现诸如条件判断、生命周期管理等功能。这种增强功能需要在容器启动和Bean创建过程中进行，因此延迟到容器刷新时再进行实例化是合理的。



## 1.2 @ComponentScans与@ComponentScan注解

@ComponentScans注解可以看作是@ComponentScan注解的一个数组，在@ComponentScans注解中可以多次标注@ComponentScan注解。@ComponentScan注解最核心的功能就是Spring IOC容器在刷新的时候会扫描对应包下标注了@Component注解、@Configuration注解、@Repository注解、@Service注解和@Controller等等注解的类，生成扫描到的类的Bean定义信息，整体流程与注册ConfigurationClassPostProcessor类的Bean定义信息的流程基本一致，最终都会将其保存到BeanFactory中的beanDefinitionMap中。

### 注解源码

**@ComponentScans注解源码**

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
public @interface ComponentScans {
	ComponentScan[] value();
}
```

**@ComponentScan注解源码**

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Repeatable(ComponentScans.class)
public @interface ComponentScan {

	@AliasFor("basePackages")
	String[] value() default {};

	@AliasFor("value")
	String[] basePackages() default {};

	Class<?>[] basePackageClasses() default {};

	Class<? extends BeanNameGenerator> nameGenerator() default BeanNameGenerator.class;

	Class<? extends ScopeMetadataResolver> scopeResolver() default AnnotationScopeMetadataResolver.class;

	ScopedProxyMode scopedProxy() default ScopedProxyMode.DEFAULT;

	String resourcePattern() default ClassPathScanningCandidateComponentProvider.DEFAULT_RESOURCE_PATTERN;

	boolean useDefaultFilters() default true;

	Filter[] includeFilters() default {};

	Filter[] excludeFilters() default {};

	boolean lazyInit() default false;

	@Retention(RetentionPolicy.RUNTIME)
	@Target({})
	@interface Filter {

		FilterType type() default FilterType.ANNOTATION;

		@AliasFor("classes")
		Class<?>[] value() default {};

		@AliasFor("value")
		Class<?>[] classes() default {};

		String[] pattern() default {};

	}
}
```

@ComponentScan注解中的每个属性的含义如下所示。

* value：作用同basePackages属性，String[]数组类型，指定要扫描的包名。如果指定了要扫描的包名，则Spring会扫描指定的包及其子包下的所有类。
* basePackages：作用同value属性，String[]数组类型，指定要扫描的包名。如果指定了要扫描的包名，则Spring会扫描指定的包及其子包下的所有类。
* basePackageClasses：Class<?>[]数组类型，指定要扫描的类的Class对象。
* nameGenerator：Class<? extends BeanNameGenerator>类型，指定扫描类时，向IOC注入Bean对象时的命名规则。
* scopeResolver：Class<? extends ScopeMetadataResolver>类型，扫描类时，用于处理并转换符合条件的Bean的作用范围。
* scopedProxy：ScopedProxyMode类型，指定生成Bean对象时的代理方式，默认的代理方法是DEFAULT，也就是不使用代理。
* resourcePattern：String类型，用于指定扫描的文件类型，默认是扫描指定包下的`**/*.class`。
* useDefaultFilters：boolean类型，是否自动检测@Component @Repository @Service @Controller注解，默认是true。
* includeFilters：Filter[]数组类型，自定义组件扫描过滤规则，符合过滤规则的类的Bean定义信息会被注册到IOC容器中。includeFilters表示只包含对应的规则，当使用includeFilters()来指定只包含哪些注解标注的类时，需要禁用默认的过滤规则，也就是需要将useDefaultFilters属性设置为false。并且，除了符合过滤规则的类外，Spring内置的如下名称的类的Bean定义信息注册到IOC容器时不受过滤规则限制，如下所示。

```bash
org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
```

* excludeFilters：Filter[]数组类型，自定义组件扫描过滤规则，excludeFilters表示排除使用对应的规则，符合过滤规则的类的Bean定义信息不会被注册到IScopedProxyMode枚举类表示Spring指定生成Bean对象时的代理方式OC容器中。
* lazyInit：boolean类型，表示Spring扫描组件时是否采用懒加载 ，默认false，表示不开启懒加载。

@Filter注解中的每个属性的含义如下所示。

* type：FilterType类型，表示过滤规则的类型。
* value：Class<?>[]数组类型，过滤符合规则的类，作用同classes属性。
* classes：Class<?>[]数组类型，过滤符合规则的类，作用同value属性。
* pattern：如果FilterType取值为ASPECTJ，则此属性表示ASPECTJ表达式。

ScopedProxyMode枚举类表示Spring指定生成Bean对象时的代理方式：

```java
public enum ScopedProxyMode {
	DEFAULT,
	NO,
	INTERFACES,
	TARGET_CLASS
}
```

ScopedProxyMode类每个属性的含义：

* DEFAULT：默认的代理方式，也就是不使用代理，除非在component-scan级别使用了不同的配置。
* NO：不使用代理。
* INTERFACES：基于JDK动态代理实现接口代理对象。
* TARGET_CLASS：基于CGLib动态代理创建类代理对象。

FilterType枚举类表示Spring扫描类时的过滤类型：

```java
public enum FilterType {
	ANNOTATION,
	ASSIGNABLE_TYPE,
	ASPECTJ,
	REGEX,
	CUSTOM
}
```

FilterType类每个属性的含义：

* ANNOTATION：按照注解进行过滤。
* ASSIGNABLE_TYPE：按照给定的类型进行过滤。
* ASPECTJ：按照ASPECTJ表达式进行过滤。
* REGEX：按照正则表达式进行过滤。
* CUSTOM：按照自定义规则进行过滤，使用自定义过滤规则时，自定义的过滤器需要实现org.springframework.core.type.filter.TypeFilter接口。

### 源码时序图

![图2-1](https://upload.yolo912.icu/mdImage/spring-core-2022-12-16-002.png)

![图2-2](https://upload.yolo912.icu/mdImage/spring-core-2022-12-16-003.png)

![图2-3](https://upload.yolo912.icu/mdImage/spring-core-2022-12-16-004.png)

### 源码解析

（1）运行ComponentScanTest类的main()方法。

```java
public static void main(String[] args) {
    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ComponentScanConfig.class);
    String[] names = context.getBeanDefinitionNames();
    Arrays.stream(names).forEach(System.out::println);
}
```

（2）解析AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext(Class<?>... componentClasses)构造方法

```java
public AnnotationConfigApplicationContext(Class<?>... componentClasses) {
    this();
    register(componentClasses);
    refresh();
}
```

（3）解析AbstractApplicationContext类的refresh()方法

```java
@Override
public void refresh() throws BeansException, IllegalStateException {
    synchronized (this.startupShutdownMonitor) {
        //############省略其他代码##############
        try {
            //############省略其他代码##############
            invokeBeanFactoryPostProcessors(beanFactory);
           //############省略其他代码##############
        }catch (BeansException ex) {
            //############省略其他代码##############
        }finally {
            //############省略其他代码##############
        }
    }
}
```

（4）解析AbstractApplicationContext类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory)方法

```java
protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
    if (!NativeDetector.inNativeImage() && beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
        beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
        beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
    }
}
```

（5）解析PostProcessorRegistrationDelegate类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors)方法

```java
public static void invokeBeanFactoryPostProcessors(
    ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {

    //############省略其他代码##############
    List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();

    // 首先，调用实现PriorityOrdered接口的BeanDefinitionRegistryPostProcessor
    String[] postProcessorNames =
        beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
    for (String ppName : postProcessorNames) {
        if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
        }
    }
    sortPostProcessors(currentRegistryProcessors, beanFactory);
    registryProcessors.addAll(currentRegistryProcessors);
    invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());
    currentRegistryProcessors.clear();

    // 接着，调用实现Ordered接口的BeanDefinitionRegistryPostProcessor
    postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
    for (String ppName : postProcessorNames) {
        if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
        }
    }
    sortPostProcessors(currentRegistryProcessors, beanFactory);
    registryProcessors.addAll(currentRegistryProcessors);
    invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());
    currentRegistryProcessors.clear();

    // 最后，循环调用其他BeanDefinitionRegistryPostProcessor，直到没有新的出现
    boolean reiterate = true;
    while (reiterate) {
        reiterate = false;
        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
        for (String ppName : postProcessorNames) {
            if (!processedBeans.contains(ppName)) {
                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                processedBeans.add(ppName);
                reiterate = true;
            }
        }
        sortPostProcessors(currentRegistryProcessors, beanFactory);
        registryProcessors.addAll(currentRegistryProcessors);
        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());
        currentRegistryProcessors.clear();
    }
    //############省略其他代码##############
}
```

BeanDefinitionRegistryPostProcessor的实现类在执行逻辑上会有先后顺序，并且最终都会调用invokeBeanDefinitionRegistryPostProcessors()方法。

（6）解析PostProcessorRegistrationDelegate类的invokeBeanDefinitionRegistryPostProcessors(Collection<? extends BeanDefinitionRegistryPostProcessor> postProcessors, BeanDefinitionRegistry registry, ApplicationStartup applicationStartup)方法

```java
private static void invokeBeanDefinitionRegistryPostProcessors(
    Collection<? extends BeanDefinitionRegistryPostProcessor> postProcessors, BeanDefinitionRegistry registry, ApplicationStartup applicationStartup) {

    for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {
        // 启动一个名为 "spring.context.beandef-registry.post-process" 的启动步骤，并为其添加一个标签 "postProcessor"，标签的值为 postProcessor 的字符串表示形式
        StartupStep postProcessBeanDefRegistry = applicationStartup.start("spring.context.beandef-registry.post-process")
            .tag("postProcessor", postProcessor::toString);
        // 调用 postProcessor 的 postProcessBeanDefinitionRegistry 方法，对 BeanDefinitionRegistry 注册Bean的定义信息
        postProcessor.postProcessBeanDefinitionRegistry(registry);
        // 结束启动步骤
        postProcessBeanDefRegistry.end();
    }
}
```

在invokeBeanDefinitionRegistryPostProcessors()方法中，会循环遍历postProcessors集合中的每个元素，调用postProcessBeanDefinitionRegistry()方法注册Bean的定义信息。

（7）解析ConfigurationClassPostProcessor类的postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)方法

```java
@Override
public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
	//##########省略其他代码###################
    processConfigBeanDefinitions(registry);
}
```

（8）解析ConfigurationClassPostProcessor类的processConfigBeanDefinitions(BeanDefinitionRegistry registry)方法

```java
public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
    //############省略其他代码#################
    // Parse each @Configuration class
    ConfigurationClassParser parser = new ConfigurationClassParser(
        this.metadataReaderFactory, this.problemReporter, this.environment,
        this.resourceLoader, this.componentScanBeanNameGenerator, registry);

    // 存储待解析的 Bean 定义持有者
    Set<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);
    // 存储已经解析过的配置类
    Set<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());
    do {
        // 启动一个名为 "spring.context.config-classes.parse" 的启动步骤
        StartupStep processConfig = this.applicationStartup.start("spring.context.config-classes.parse");
        // 解析配置类
        parser.parse(candidates);
        // 验证配置类
        parser.validate();
        // 获取解析后的配置类集合
        Set<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());
        // 移除已经解析过的配置类
        configClasses.removeAll(alreadyParsed);

        // 根据模型内容读取并创建 Bean 定义
        // Read the model and create bean definitions based on its content
        if (this.reader == null) {
            // 初始化 Bean 定义读取器
            this.reader = new ConfigurationClassBeanDefinitionReader(
                registry, this.sourceExtractor, this.resourceLoader, this.environment,
                this.importBeanNameGenerator, parser.getImportRegistry());
        }
        // 加载 Bean 定义
        this.reader.loadBeanDefinitions(configClasses);
        // 将已解析的配置类添加到已解析集合中
        alreadyParsed.addAll(configClasses);
        // 结束启动步骤，并标记解析的配置类数量
        processConfig.tag("classCount", () -> String.valueOf(configClasses.size())).end();

        // 清空待解析的 Bean 定义持有者集合
        candidates.clear();
        // 如果当前注册的 Bean 定义数量大于候选名称的数量
        if (registry.getBeanDefinitionCount() > candidateNames.length) {
            // 获取当前所有注册的 Bean 名称
            String[] newCandidateNames = registry.getBeanDefinitionNames();
            // 将候选名称转换为集合
            Set<String> oldCandidateNames = Set.of(candidateNames);
            // 存储已经解析过的配置类名称
            Set<String> alreadyParsedClasses = new HashSet<>();
            // 遍历已解析的配置类
            for (ConfigurationClass configurationClass : alreadyParsed) {
                // 添加配置类名称到已解析集合中
                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
            }
            // 遍历新的候选名称
            for (String candidateName : newCandidateNames) {
                // 如果旧的候选名称集合中不包含当前候选名称
                if (!oldCandidateNames.contains(candidateName)) {
                    // 获取 Bean 定义
                    BeanDefinition bd = registry.getBeanDefinition(candidateName);
                    // 判断 Bean 定义是否是配置类候选
                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &&
                        // 并且配置类名称不在已解析集合中
                        !alreadyParsedClasses.contains(bd.getBeanClassName())) {
                        // 将新的 Bean 定义持有者添加到待解析集合中
                        candidates.add(new BeanDefinitionHolder(bd, candidateName));
                    }
                }
            }
            // 更新候选名称数组
            candidateNames = newCandidateNames;
        }
    }
    // 循环直到待解析集合为空
    while (!candidates.isEmpty());
    //############省略其他代码#################
}
```

在processConfigBeanDefinitions()方法中，创建了一个ConfigurationClassParser类型的对象parser，并且调用了parser的parse()方法来解析类的配置信息。

（9）解析ConfigurationClassParser类的parse(Set<BeanDefinitionHolder> configCandidates)方法

```java
public void parse(Set<BeanDefinitionHolder> configCandidates) {
    for (BeanDefinitionHolder holder : configCandidates) {
        BeanDefinition bd = holder.getBeanDefinition();
        try {
            if (bd instanceof AnnotatedBeanDefinition) {
                // 如果 BeanDefinition 是 AnnotatedBeanDefinition 类型
                parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
            }
            else if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {
                // 如果 BeanDefinition 是 AbstractBeanDefinition 类型，并且存在 BeanClass
                parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());
            }
            else {
                // 其他情况
                parse(bd.getBeanClassName(), holder.getBeanName());
            }
        }
        catch (BeanDefinitionStoreException ex) {
            // 如果发生 BeanDefinitionStoreException 异常，则直接抛出
            throw ex;
        }
        catch (Throwable ex) {
            // 如果发生其他异常，则包装为 BeanDefinitionStoreException 异常并抛出
            throw new BeanDefinitionStoreException(
                "Failed to parse configuration class [" + bd.getBeanClassName() + "]", ex);
        }
    }
    this.deferredImportSelectorHandler.process();
}
```

（10）解析ConfigurationClassParser类的parse(AnnotationMetadata metadata, String beanName)方法

```java
protected final void parse(AnnotationMetadata metadata, String beanName) throws IOException {
    processConfigurationClass(new ConfigurationClass(metadata, beanName), DEFAULT_EXCLUSION_FILTER);
}
```

（11）解析ConfigurationClassParser类的processConfigurationClass(ConfigurationClass configClass, Predicate<String> filter)方法

```java
protected void processConfigurationClass(ConfigurationClass configClass, Predicate<String> filter) throws IOException {
    //###############省略其他代码####################
    // 递归处理配置类及其超类层次结构
    SourceClass sourceClass = asSourceClass(configClass, filter);
    do {
        // 处理配置类
        sourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);
    }
    while (sourceClass != null);
    // 将配置类放入配置类集合中
    this.configurationClasses.put(configClass, configClass);
}
```

在processConfigurationClass()方法中，会通过do-while()循环获取配置类和其父类的注解信息，SourceClass类中会封装配置类上注解的详细信息。

（12）解析ConfigurationClassParser类的doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)方法

```java
protected final SourceClass doProcessConfigurationClass(
    ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)
    throws IOException {
    //##############省略其他代码################
    // 处理任何@ComponentScan注解
    // Process any @ComponentScan annotations
    Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(
        sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
    if (!componentScans.isEmpty() &&
        !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
        for (AnnotationAttributes componentScan : componentScans) {
            // 如果配置类被注解为@ComponentScan -> 立即执行扫描
            // The config class is annotated with @ComponentScan -> perform the scan immediately
            Set<BeanDefinitionHolder> scannedBeanDefinitions =
                this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
            // 检查扫描到的定义集合中是否有其他配置类，如果需要则递归解析
            // Check the set of scanned definitions for any further config classes and parse recursively if needed
            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
                BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
                if (bdCand == null) {
                    bdCand = holder.getBeanDefinition();
                }
                if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
                    // 解析配置类
                    parse(bdCand.getBeanClassName(), holder.getBeanName());
                }
            }
        }
    }
  	//##############省略其他代码################
    // No superclass -> processing is complete
    return null;
}
```

在上述处理@ComponentScan注解的逻辑中，通过componentScanParser的parse()方法对@ComponentScan注解进行解析。

（13）解析ComponentScanAnnotationParser类的parse(AnnotationAttributes componentScan, String declaringClass)方法

```java
public Set<BeanDefinitionHolder> parse(AnnotationAttributes componentScan, String declaringClass) {
    // 创建ClassPathBeanDefinitionScanner实例
    ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry,
                                                                                componentScan.getBoolean("useDefaultFilters"), this.environment, this.resourceLoader);
    // 获取BeanNameGenerator类的Class对象
    Class<? extends BeanNameGenerator> generatorClass = componentScan.getClass("nameGenerator");
    // 判断是否使用继承的BeanNameGenerator
    boolean useInheritedGenerator = (BeanNameGenerator.class == generatorClass);
    // 设置BeanNameGenerator
    scanner.setBeanNameGenerator(useInheritedGenerator ? this.beanNameGenerator :
                                 BeanUtils.instantiateClass(generatorClass));
    // 获取ScopedProxyMode枚举值
    ScopedProxyMode scopedProxyMode = componentScan.getEnum("scopedProxy");
    if (scopedProxyMode != ScopedProxyMode.DEFAULT) {
        // 设置ScopedProxyMode
        scanner.setScopedProxyMode(scopedProxyMode);
    }
    else {
        // 获取ScopeMetadataResolver类的Class对象
        Class<? extends ScopeMetadataResolver> resolverClass = componentScan.getClass("scopeResolver");
        // 设置ScopeMetadataResolver
        scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));
    }
    // 设置资源匹配模式
    scanner.setResourcePattern(componentScan.getString("resourcePattern"));
    // 遍历includeFilters
    for (AnnotationAttributes includeFilterAttributes : componentScan.getAnnotationArray("includeFilters")) 	{
        // 创建TypeFilter列表
        List<TypeFilter> typeFilters = TypeFilterUtils.createTypeFiltersFor(includeFilterAttributes, this.environment,
                                                                            this.resourceLoader, this.registry);
        // 遍历TypeFilter列表，并添加到scanner中
        for (TypeFilter typeFilter : typeFilters) {
            scanner.addIncludeFilter(typeFilter);
        }
    }
    // 遍历excludeFilters
    for (AnnotationAttributes excludeFilterAttributes : componentScan.getAnnotationArray("excludeFilters")) 	{
        // 创建TypeFilter列表
        List<TypeFilter> typeFilters = TypeFilterUtils.createTypeFiltersFor(excludeFilterAttributes, this.environment,
                                                                            this.resourceLoader, this.registry);
        // 遍历TypeFilter列表，并添加到scanner中
        for (TypeFilter typeFilter : typeFilters) {
            scanner.addExcludeFilter(typeFilter);
        }
    }

    // 获取lazyInit的值
    boolean lazyInit = componentScan.getBoolean("lazyInit");
    if (lazyInit) {
        // 设置Bean定义默认的懒加载属性
        scanner.getBeanDefinitionDefaults().setLazyInit(true);
    }

    // 创建basePackages集合
    Set<String> basePackages = new LinkedHashSet<>();
    // 获取basePackages数组
    String[] basePackagesArray = componentScan.getStringArray("basePackages");
    // 遍历basePackages数组
    for (String pkg : basePackagesArray) {
        // 解析并添加包名到basePackages集合中
        String[] tokenized = StringUtils.tokenizeToStringArray(this.environment.resolvePlaceholders(pkg),
                                                               ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);
        Collections.addAll(basePackages, tokenized);
    }
    // 遍历basePackageClasses数组
    for (Class<?> clazz : componentScan.getClassArray("basePackageClasses")) {
        // 获取包名并添加到basePackages集合中
        basePackages.add(ClassUtils.getPackageName(clazz));
    }
    // 如果basePackages集合为空，则添加声明类的包名到集合中
    if (basePackages.isEmpty()) {
        basePackages.add(ClassUtils.getPackageName(declaringClass));
    }

    // 添加自定义的excludeFilter
    scanner.addExcludeFilter(new AbstractTypeHierarchyTraversingFilter(false, false) {
        @Override
        protected boolean matchClassName(String className) {
            // 判断是否为声明类的类名
            return declaringClass.equals(className);
        }
    });
		// 执行扫描并返回结果
    return scanner.doScan(StringUtils.toStringArray(basePackages));
}
```

在parse()方法中，会创建一个ClassPathBeanDefinitionScanner类型的扫描器scanner，将@ComponentScan注解上配置的信息都设置到扫描器scanner中，最后调用扫描器scanner的doScan()方法进行扫描。

（14）解析ClassPathBeanDefinitionScanner类的doScan(String... basePackages)方法

```java
protected Set<BeanDefinitionHolder> doScan(String... basePackages) {
    // 断言basePackages不为空，至少指定一个基础包
    Assert.notEmpty(basePackages, "At least one base package must be specified");
    Set<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<>();
    for (String basePackage : basePackages) {
        // 在基础包中查找候选组件
        Set<BeanDefinition> candidates = findCandidateComponents(basePackage);
        for (BeanDefinition candidate : candidates) {
            // 解析候选组件的作用域元数据
            ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
            // 设置候选组件的作用域
            candidate.setScope(scopeMetadata.getScopeName());
            // 生成候选组件的Bean名称
            String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
            // 如果候选组件是AbstractBeanDefinition类型
            if (candidate instanceof AbstractBeanDefinition) {
                // 对候选组件进行后处理
                postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
            }
            // 如果候选组件是AnnotatedBeanDefinition类型
            if (candidate instanceof AnnotatedBeanDefinition) {
                // 处理候选组件的通用定义注解
                AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
            }
            // 检查候选组件是否满足条件
            if (checkCandidate(beanName, candidate)) {
                // 创建BeanDefinitionHolder对象
                BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
                // 应用作用域代理模式
                definitionHolder =
                    AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
                // 将BeanDefinitionHolder添加到beanDefinitions集合中
                beanDefinitions.add(definitionHolder);
                // 注册BeanDefinitionHolder到注册中心
                registerBeanDefinition(definitionHolder, this.registry);
            }
        }
    }
    // 返回beanDefinitions集合
    return beanDefinitions;
}
```

在doScan()方法中，会遍历传入的每个包路径，调用findCandidateComponents()方法来扫描带有注解（例如@Component注解）的类。

（15）解析ClassPathScanningCandidateComponentProvider类的findCandidateComponents(String basePackage)方法

```java
public Set<BeanDefinition> findCandidateComponents(String basePackage) {
    // 如果组件索引不为空，并且索引支持包含过滤器
    if (this.componentsIndex != null && indexSupportsIncludeFilters()) {
        // 从索引中添加候选组件
        return addCandidateComponentsFromIndex(this.componentsIndex, basePackage);
    }
    else {
        // 扫描候选组件
        return scanCandidateComponents(basePackage);
    }
}
```

（16）解析ClassPathScanningCandidateComponentProvider类的scanCandidateComponents(String basePackage)方法

```java
private Set<BeanDefinition> scanCandidateComponents(String basePackage) {
    Set<BeanDefinition> candidates = new LinkedHashSet<>();
    try {
        String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +
            resolveBasePackage(basePackage) + '/' + this.resourcePattern;
        Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);
        boolean traceEnabled = logger.isTraceEnabled();
        boolean debugEnabled = logger.isDebugEnabled();
        for (Resource resource : resources) {
            String filename = resource.getFilename();
            if (filename != null && filename.contains(ClassUtils.CGLIB_CLASS_SEPARATOR)) {
                // 忽略classpath中CGLIB生成的类
                // Ignore CGLIB-generated classes in the classpath
                continue;
            }
            if (traceEnabled) {
                // 跟踪日志，扫描资源
                logger.trace("Scanning " + resource);
            }
            try {
                // 获取资源的元数据读取器
                MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);
                // 判断是否为候选组件
                if (isCandidateComponent(metadataReader)) {
                    // 创建扫描到的泛型Bean定义
                    ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
                    // 设置资源来源
                    sbd.setSource(resource);
                    // 再次判断是否为候选组件
                    if (isCandidateComponent(sbd)) {
                        if (debugEnabled) {
                            // 调试日志，识别候选组件类
                            logger.debug("Identified candidate component class: " + resource);
                        }
                        // 将候选组件添加到候选集合中
                        candidates.add(sbd);
                    }
                    else {
                        if (debugEnabled) {
                            // 调试日志，忽略非具体的顶层类
                            logger.debug("Ignored because not a concrete top-level class: " + resource);
                        }
                    }
                }
                else {
                    if (traceEnabled) {
                        // 跟踪日志，忽略不符合任何过滤器的资源
                        logger.trace("Ignored because not matching any filter: " + resource);
                    }
                }
            }
            catch (FileNotFoundException ex) {
                if (traceEnabled) {
                    // 跟踪日志，忽略不可读资源
                    logger.trace("Ignored non-readable " + resource + ": " + ex.getMessage());
                }
            }
            catch (Throwable ex) {
                throw new BeanDefinitionStoreException(
                    // 抛出Bean定义存储异常，读取候选组件类失败
                    "Failed to read candidate component class: " + resource, ex);
            }
        }
    catch (IOException ex) {
        throw new BeanDefinitionStoreException("I/O failure during classpath scanning", ex);
    }
    return candidates;
}
```

可以看到，在scanCandidateComponents()方法中，会调用isCandidateComponent()方法来判断当前注解是不是要扫描的注解。

（17）解析ClassPathScanningCandidateComponentProvider类的isCandidateComponent(MetadataReader metadataReader)方法

```java
protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException {
    // 遍历排除过滤器列表
    for (TypeFilter tf : this.excludeFilters) {
        // 如果当前过滤器匹配给定的元数据读取器
        if (tf.match(metadataReader, getMetadataReaderFactory())) {
            // 返回false，表示不是候选组件
            return false;
        }
    }
    // 遍历包含过滤器列表
    for (TypeFilter tf : this.includeFilters) {
        // 如果当前过滤器匹配给定的元数据读取器
        if (tf.match(metadataReader, getMetadataReaderFactory())) {
            // 调用isConditionMatch方法判断条件是否匹配
            return isConditionMatch(metadataReader);
        }
    }
    // 如果都不匹配，则返回false，表示不是候选组件
    return false;
}
```

可以看到，isCandidateComponent()方法的逻辑还是比较简单的，就是遍历匹配excludeFilters和includeFilters指定的规则。

优先匹配excludeFilters指定的规则，如果匹配excludeFilters指定的规则，直接返回false。接下来，匹配includeFilters指定的规则，匹配成功，则调用isConditionMatch()方法进行条件匹配。

其中，对于includeFilters而言，默认的过滤规则如下所示。

```java
protected void registerDefaultFilters() {
    this.includeFilters.add(new AnnotationTypeFilter(Component.class));
    ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();
    try {
        this.includeFilters.add(new AnnotationTypeFilter(
            ((Class<? extends Annotation>) ClassUtils.forName("jakarta.annotation.ManagedBean", cl)), false));
        logger.trace("JSR-250 'jakarta.annotation.ManagedBean' found and supported for component scanning");
    }
    catch (ClassNotFoundException ex) {
        // JSR-250 1.1 API (as included in Jakarta EE) not available - simply skip.
    }
    try {
        this.includeFilters.add(new AnnotationTypeFilter(
            ((Class<? extends Annotation>) ClassUtils.forName("jakarta.inject.Named", cl)), false));
        logger.trace("JSR-330 'jakarta.inject.Named' annotation found and supported for component scanning");
    }
    catch (ClassNotFoundException ex) {
        // JSR-330 API not available - simply skip.
    }
}
```

可以看到，对于includeFilters而言，默认的过滤规则会匹配@Component注解，JSR-250中的注解和JSR-330中的注解。

（18）回到ClassPathScanningCandidateComponentProvider类的scanCandidateComponents(String basePackage)方法

在ClassPathScanningCandidateComponentProvider类的scanCandidateComponents(String basePackage)方法中，会将标注了@Component注解，JSR-250中的注解和JSR-330中的注解的类信息封装成ScannedGenericBeanDefinition类对象，也就是类的Bean定义信息。

ScannedGenericBeanDefinition类的构造方法如下所示。

```java
public ScannedGenericBeanDefinition(MetadataReader metadataReader) {
    Assert.notNull(metadataReader, "MetadataReader must not be null");
    this.metadata = metadataReader.getAnnotationMetadata();
    setBeanClassName(this.metadata.getClassName());
    setResource(metadataReader.getResource());
}
```

（19）回到ClassPathBeanDefinitionScanner类的doScan(String... basePackages)方法

在ClassPathBeanDefinitionScanner类的doScan(String... basePackages)方法中，会将扫描到的类的Bean定义信息注册到IOC容器中，如下代码片段所示。

```java
if (checkCandidate(beanName, candidate)) {
    BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
    definitionHolder =
        AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
    beanDefinitions.add(definitionHolder);
    registerBeanDefinition(definitionHolder, this.registry);
}
```

可以看到，在doScan()方法中，会调用registerBeanDefinition()注册Bean定义信息。

（20）解析ClassPathBeanDefinitionScanner类的registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)方法

```java
protected void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) {
    BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry);
}
```

可以看到，在方法中直接调用了BeanDefinitionReaderUtils类的registerBeanDefinition()方法。

（21）解析BeanDefinitionReaderUtils类的registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)方法。

```java
public static void registerBeanDefinition(
    BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
    throws BeanDefinitionStoreException {

    // Register bean definition under primary name.
    String beanName = definitionHolder.getBeanName();
    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
	//###########省略其他代码###################
}
```

可以看到，在上述代码中，会继续调用BeanDefinitionRegistry类型的对象registry的registerBeanDefinition()方法，将类的Bean定义信息注册到IOC容器。

（22）解析DefaultListableBeanFactory类的registerBeanDefinition(String beanName, BeanDefinition beanDefinition)方法

```java
@Override
public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
    throws BeanDefinitionStoreException {
	//##############省略其他代码#################
    BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
    if (existingDefinition != null) {
        //##############省略其他代码#################
        this.beanDefinitionMap.put(beanName, beanDefinition);
    }
    else {
        //##############省略其他代码#################
        if (hasBeanCreationStarted()) {
            // Cannot modify startup-time collection elements anymore (for stable iteration)
            synchronized (this.beanDefinitionMap) {
                this.beanDefinitionMap.put(beanName, beanDefinition);
                List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);
                updatedDefinitions.addAll(this.beanDefinitionNames);
                updatedDefinitions.add(beanName);
                this.beanDefinitionNames = updatedDefinitions;
                removeManualSingletonName(beanName);
            }
        }
        else {
            // Still in startup registration phase
            this.beanDefinitionMap.put(beanName, beanDefinition);
            this.beanDefinitionNames.add(beanName);
            removeManualSingletonName(beanName);
        }
        this.frozenBeanDefinitionNames = null;
    }
    if (existingDefinition != null || containsSingleton(beanName)) {
        resetBeanDefinition(beanName);
    }
    else if (isConfigurationFrozen()) {
        clearByTypeCache();
    }
}
```

可以看到，Spring会将扫描到的标注了符合过滤规则的注解的类封装成对应的Bean定义信息，最终会将这些Bean定义信息注册到beanDefinitionMap中。

### 思考

#### 1.Spring扫描指定包的逻辑为何复杂？

Spring扫描指定包的逻辑之所以看起来复杂，主要是因为其设计需要兼顾灵活性、可扩展性和性能。Spring的组件扫描（Component Scanning）机制允许开发者通过注解（如`@Component`、`@Service`、`@Repository`等）自动注册bean到Spring的IoC容器中，而无需显式地在XML配置文件中声明每一个bean。为了实现这一功能，Spring需要：

1. **灵活性**：允许开发者自定义扫描的包路径、过滤规则等，以适应不同的项目结构和需求。
2. **可扩展性**：通过提供TypeFilter接口等机制，允许开发者自定义过滤逻辑，以排除或包含特定的类。
3. **性能**：在大型项目中，可能需要扫描成百上千个类，Spring的扫描机制需要优化以减少扫描时间和内存消耗。

为了实现这些目标，Spring的组件扫描逻辑需要处理多种情况，包括但不限于：处理类路径资源、解析注解、应用过滤规则、注册bean定义等。

#### 2.配置类上不标注@ComponentScans或@ComponentScan能扫描到哪些包下的类？

如果在Spring Boot的配置类（通常是带有`@Configuration`注解的类）上不标注`@ComponentScans`或`@ComponentScan`注解，Spring Boot会采用默认行为。具体来说，Spring Boot会从主应用类（带有`@SpringBootApplication`注解的类）所在的包开始，扫描这个包及其子包下的所有类。这意味着，只要你的`@Component`注解的类位于主应用类所在的包或其子包下，它们就会被自动扫描并注册到IoC容器中。

#### 3.@ComponentScan注解中的basePackages或value属性可以设置任意包名吗？

是的，`@ComponentScan`注解中的`basePackages`或`value`属性可以设置任意包名（前提是这些包在类路径上确实存在）。这些属性用于指定Spring应该扫描哪些包以查找带有`@Component`、`@Service`、`@Repository`等注解的类。如果指定的包不存在于应用的类路径中，Spring在启动时会抛出异常，提示找不到指定的包。

因此，当使用`@ComponentScan`注解时，务必确保指定的包是真实存在的，并且包含了你想要自动注册为Spring bean的类。如果希望从多个不同的包中扫描组件，可以使用`@ComponentScans`注解，并在其中指定多个`@ComponentScan`。



## 1.3 @Bean注解

@Bean注解可以标注到方法上，将当前方法的返回值注入到IOC容器中。@Bean注解也可以标注到注解上，作为元注解使用。

### 注解源码

```java
@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Bean {
	//Since: 4.3.3
	@AliasFor("name")
	String[] value() default {};

	@AliasFor("value")
	String[] name() default {};
	
    //Since: 5.1
	boolean autowireCandidate() default true;

	String initMethod() default "";

	String destroyMethod() default AbstractBeanDefinition.INFER_METHOD;
}
```

注解中各个属性的含义如下所示。

* name：String[]数组类型，指定注入到IOC容器中的Bean的名称，可以指定多个名称。如果不指定name属性和value属性的值，则注入到IOC容器中的Bean的名称默认是方法的名称。
* value：String[]数组类型，作用与name属性相同。
* autowireCandidate：boolean类型，表示是否支持自动按照类型注入到其他的Bean中。此属性会影响@Autowired注解，不会响应@Resource注解，默认为true，表示支持自动按照类型注入到其他的Bean中。
* initMethod：指定初始化的方法。
* destroyMethod：指定销毁的方法。

### 源码时序图

#### 注册Bean的流程

![图3-1](https://upload.yolo912.icu/mdImage/spring-core-2022-12-21-001.png)

![图3-2](https://upload.yolo912.icu/mdImage/spring-core-2022-12-21-002.png)

#### 调用初始化方法

![图3-3](https://upload.yolo912.icu/mdImage/spring-core-2022-12-21-003.png)

![图3-4](https://upload.yolo912.icu/mdImage/spring-core-2022-12-21-004.png)

#### 调用销毁方法

![图3-5](https://upload.yolo912.icu/mdImage/spring-core-2022-12-21-005.png)
